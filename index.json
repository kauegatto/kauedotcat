[{"content":"Arquitetura √† nivel de Software: Refere-se √† organiza√ß√£o e defini√ß√£o de regras a serem seguidas no seu projeto em si, seja ele um microservi√ßo, monolito ou qualquer outra parte de uma solu√ß√£o maior, nossa √™nfase est√° no n√≠vel do seu servi√ßo, um servi√ßo seu pode seguir √† risca SOLID, arquitetura hexagonal e uma PoC pode seguir o famoso: faz r√°pido e funcionando.\nDe outro lado, cuidando e decidindo se temos SOA, Microservi√ßos, Monolitos ou qual protocolo de comunica√ß√£o usamos, temos a arquitetura de solu√ß√µes, o que n√£o √© o foco do artigo\nModelo Baseado em Camadas √â bem comum dividirmos nosso software em camadas, √© o que fazemos na maior parte das arquiteturas de software modernas, essa divis√£o tem como objetivo separar partes do c√≥digo que n√£o devem interagir muito entre si exceto por alguns pontos de contato (que podem ser outras camadas), e tamb√©m garantir que exista um ‚Äúmeio de campo‚Äù entre certas camadas, ou seja, a interface n√£o vai falar diretamente com o banco de dados, existe um caminho para isso.\nUm dos pontos negativos desses modelos √© que eles n√£o costumam definir a obriga√ß√£o ou sugest√£o de interfaces para comunica√ß√£o com servi√ßos externos, normalmente services s√£o totalmente acoplados √† infraestrutura, em alguns casos, at√© mesmo temos DAO‚Äôs que implementam regras de persist√™ncia na camada de modelo. O problema disso √© claro, nossas regras de neg√≥cio muitas vezes acabam acopladas √† meras ferramentas, trocar o banco de dados exige que voc√™ mexa em um peda√ßo que deveria representar sua regra de neg√≥cio, o que n√£o acontece em outros modelos como arquitetura hexagonal (a menos que voc√™ adapte seu padr√£o em camadas para ter abstra√ß√µes significativas, o que √© totalmente v√°lido üôÇ).\nMVC O MVC (Model-View-Controller) √© um pattern arquitetural usado como um molde pra distribui√ß√£o de responsabilidades em trechos de c√≥digo que tratam de interfaces com o usu√°rio (UI). H√° tr√™s responsabilidades pre-estabelecidas:\nView: cont√©m a l√≥gica que monta a UI (telas ou equivalente) e que trata a entrada de dados, recebendo eventos do usu√°rio (clique, digita√ß√£o etc.). As do usu√°rio s√£o repassadas para o Controller. A View pode buscar dados diretamente do Model para exibi√ß√£o na UL Controller. o \u0026ldquo;meio de campo\u0026rdquo;, recebe intera√ß√µes do usu√°rio da View e colabora com o Model para enviar e obter dados, que s√£o repassados para a View. Model: o resto do c√≥digo, que n√£o tem a ver com UI. Realiza c√°lculos, regras de neg√≥cio, persist√™ncia, integra√ß√µes com outros sistemas etc. H√° diversas varia√ß√µes como MVP, MVVM, entre outros. Outros exemplos ‚Üí MVVM The main thrust of the Model/View/ViewModel architecture seems to be that on top of the data (‚Äùthe Model‚Äù), there‚Äôs another layer of non-visual components (‚Äùthe ViewModel‚Äù) that map the concepts of the data more closely to the concepts of the view of the data (‚Äùthe View‚Äù). It‚Äôs the ViewModel that the View binds to, not the Model directly.\nArquitetura Hexagonal - Ports And Adapters A arquitetura hexagonal √© uma proposta de arquitetura de software que segue l√≥gicas de desenvolvimento de software que pensam em acoplamento e coes√£o, basicamente, m√≥dulos de alto n√≠vel (que possuem regras de neg√≥cio) n√£o devem depender de implementa√ß√µes de m√≥dulos de baixo n√≠vel (frameworks, bibliotecas de terceiros, et cetera.). Tudo que acessa o cora√ß√£o / dom√≠nio / regra de neg√≥cio da sua aplica√ß√£o deve passar por portas, que s√£o basicamente interfaces que representam o que aquela biblioteca far√° para voc√™, chamamos a implementa√ß√£o dessas interfaces de adaptadores.\nOu seja, em um sistema de login, podemos disparar um evento em uma fila de mensagens RabbitMQ que ser√° consumido por um outro servi√ßo de notifica√ß√£o, pensando em um n√≠vel um pouco mais abstrato, esquecendo bibliotecas ou ferramentas, podemos criar uma interface de publicador de eventos e dizer que vamos usar ela, ou seja, nossa l√≥gica de neg√≥cio precisa enviar uma notifica√ß√£o de cadastro e um payload, independente se rabbitMQ, kafka ou outra porta est√° sendo usada:\nprivate final Notifier messagePublisher; public class TicketService { public Ticket create(Ticket ticket){ messagePublisher.Notify(TicketEventsEnum.TICKET_CREATED); return repository.save(ticket); } } No service, a regra de neg√≥cio de cria√ß√£o de um ticket √© exatamente essa, note que n√£o estou usando uma regra de rabbitMQ necessariamente, nem mesmo o seu vocabul√°rio (normalmente usar√≠amos publish) o importante para a regra de cria√ß√£o, √© enviar uma notifica√ß√£o!\nA depend√™ncia Notifier √© na realidade uma interface pr√≥pria, que representa o que necessitamos, o envio de uma notifica√ß√£o, √© uma porta.\npublic interface Notifier { void Notify(Object message); } O Adaptador, que √© basicamente uma das op√ß√µes de notificadores que vc tem √© a implementa√ß√£o real, voc√™ poderia trocar os adaptadores e ainda assim n√£o ter problemas no seu dom√≠nio, tendo em vista que todo adaptadores respeita a mesma interface (porta).\nImagine que voc√™ est√° indo viajar, o n√∫cleo da aplica√ß√£o √© o conte√∫do essencial da sua mala - os itens vitais que voc√™ n√£o pode deixar para tr√°s. Os adaptadores s√£o os diversos compartimentos e bolsos especializados na mala, cada um projetado para acomodar diferentes necessidades, voc√™ tem um plugue para tomadas da europa, outros para os estados unidos e outra que suporta o padr√£o adotado na √°sia (n√£o sei nem se √© diferente). Da mesma forma, os adaptadores na arquitetura hexagonal conectam o n√∫cleo da aplica√ß√£o a interfaces externas variadas, como bancos de dados, interfaces de usu√°rio e servi√ßos externos, esses adaptadores permitem que a aplica√ß√£o funcione em ambientes diversos.\nClean Architecture N√£o entrarei em detalhes pela sua complexidade e individualidades, mas saiba que tanto a clean architecture quanto a onion se baseiam no mesmo fundamento, de proteger a camada de dom√≠nio, com os mesmos princ√≠pios de abstra√ß√£o por interfaces, e adaptadores implementando-as\nDDD - Isso n√£o √© sobre DDD O Deisgn orientado √† Dom√≠nio (Domain Driven Design / DDD) √© um conceito extenso e vai al√©m de um sugest√µes sobre como dividir seu c√≥digo em camadas (esse nem √© o foco), comentando a maneira com que o software √© escrito, a linguagem utilizada no processo de fabrica√ß√£o, o que s√£o as fronteiras entre suas entidades e regras de neg√≥cio e como elas devem ser implementadas, realmente fazendo com que a preocupa√ß√£o de dom√≠nio seja a central na constru√ß√£o de software.\nEncare o DDD como uma prescri√ß√£o de metodologia e processo para o desenvolvimento de sistemas complexos cujo foco √© mapear atividades, tarefas, eventos e dados dentro de um dom√≠nio de problema nos artefatos de tecnologia de um dom√≠nio de solu√ß√£o.\nApesar disso, Evans em seu livro deu diversas sugest√µes arquiteturais, como por exemplo, os services, muitas vezes, mal utilizados ou interpretados. Veremos agora algumas sugest√µes e pontos do autor.\nDDD - Sugest√µes Arquiteturais ‚Üí e de design de c√≥digo Antes de tudo, acho importante definir o que √© o dom√≠nio de uma aplica√ß√£o:\nDom√≠nio: No contexto de Engenharia de Software √© o ‚Äúconhecimento‚Äù¬†utilizado em uma determinada √°rea de aplica√ß√£o, um campo espec√≠fico para qual o sistema foi desenvolvido, ou seja, os problemas, regras e solu√ß√µes que envolvem uma parte da aplica√ß√£o, apesar disso, muitas vezes nos referimos ao dom√≠nio de neg√≥cio (n√∫cleo de regras e conhecimentos que envolvem o neg√≥cio) somente como dom√≠nio, leve isso em considera√ß√£o, por√©m tenha em mente que uma aplica√ß√£o tem diversos dom√≠nios.\nQuando o c√≥digo relacionado ao dom√≠nio √© distribu√≠do por uma por√ß√£o t√£o grande de outros c√≥digos (espalhado), torna-se extremamente dif√≠cil distingui-los e raciocinar. Altera√ß√µes superficiais na interface do usu√°rio podem realmente alterar a l√≥gica de neg√≥cios (altera√ß√µes vazam para onde n√£o devem).\nAssim sendo:\nIsole o modelo do dom√≠nio e a l√≥gica de neg√≥cios e elimine qualquer depend√™ncia que eles possam ter na infraestrutura, na interface do usu√°rio ou mesmo na l√≥gica do aplicativo que n√£o seja l√≥gica de neg√≥cios. Particione um programa complexo em camadas. Desenvolva um design dentro de cada camada que seja coeso e que dependa apenas das camadas abaixo. Concentre todo o c√≥digo relacionado ao modelo do dom√≠nio em uma camada e isole-o do c√≥digo da interface do usu√°rio, do aplicativo e da infraestrutura. Os objetos de dom√≠nio, livres da responsabilidade de se exibir, de se armazenar, de gerenciar tarefas do aplicativo, e assim por diante, podem se concentrar em expressar o modelo do dom√≠nio. Isso permite que um modelo evolua para se tornar rico e limpo o suficiente para capturar o conhecimento essencial do neg√≥cio e coloc√°-lo para funcionar, sempre que uma regra de neg√≥cio surgir, o modelo de dom√≠nio deve ser o necess√°rio por implement√°-la, quem deve se adaptar √†s regras de neg√≥cio √© a implementa√ß√£o, e nunca o contr√°rio.\nDito isso, colocar as responsabilidades certas no dom√≠nio n√£o significa que o modelo deve ser an√™mico, o modelo pode (e deve) manter regras e formas para que seu escopo seja v√°lido. Ou seja, fazemos o poss√≠vel para que uma entidade de dom√≠nio nas√ßa e continue sempre de acordo com suas regras de neg√≥cio.\nModelos An√™micos - Um problema Conceito muito difundido no artigo Anemic Domain Model, de Martin Fowler.\nQuando falamos de modelos de dom√≠nio an√™micos dizemos de modelos onde as regras de neg√≥cio associadas √† uma entidade √© externa √† pr√≥pria entidade. Temos uma classe pedido mas o m√©todo para verificar se o pedido cont√©m itens ou n√£o est√° em um ‚Äúservice‚Äù, que acaba sendo uma classe que possui regras que poderiam existir dentro de uma pr√≥pria entidade (se contiver somente o seu comportamento).\nClasses que possuem somente atributos s√£o classes de dom√≠nio an√™micas, idealmente, uma classe deve conter comportamento e atributos.\nPodemos chamar classes JAVA ou C# que s√£o totalmente desacoplada de outras bibliotecas ou framewrks de POCO (no C#) ou POJO (no JAVA). Por serem c√≥digos puros escritos em java ou c#, que n√£o deviram de uma classe base e nem retornam ou utilizam de tipos especiais, ou seja, s√£o classes simples que sabem apenas de seu dom√≠nio, devemos sempre seguir os princ√≠pios da ignor√¢ncia da infraestrutura e ignor√¢ncia da persist√™ncia para essas classes.\nPortanto, as entidades n√£o devem ser associadas aos modos de exibi√ß√£o do cliente pois, no n√≠vel da interface do usu√°rio, alguns dados podem ainda n√£o ter sido validados. √â por esse motivo que o ViewModel existe. O ViewModel √© um modelo de dados exclusivamente para necessidades de camada de apresenta√ß√£o. As entidades de dom√≠nio n√£o pertencem diretamente ao ViewModel. Em vez disso, voc√™ precisa converter entre entidades de dom√≠nio e ViewModels e vice-versa. - Projetar um microsservi√ßo orientado a DDD, Microsoft\nRefatorando um Dom√≠nio an√™mico Atributos distantes do comportamento Para come√ßar, recomendo ler o caso 1 de 3. Refatora√ß√£o ‚Üí Casos Usuais, depois volte aqui. De maneira geral, classes devem guardar dentro de si atributos e comportamentos, se voc√™ possui comportamentos que agem sobre os atributos de uma classe espec√≠fica, costuma fazer sentido encapsul√°-los dentro da classe.\nExemplo:\nClass ComprarIngressoService{ void comprar(Pessoa pessoa, Evento evento){ ... if(pessoa.idade\u0026lt;18){ // menor de idade } if(pessoa.getCadastro()==\u0026#34;ativo\u0026#34;){ // } } } Esse tipo de valida√ß√£o √© aparentemente inofensiva, contudo, fr√°gil, pode causar diversas repeti√ß√µes no c√≥digo e aumentar pontos de contato para uma poss√≠vel altera√ß√£o, em alguns casos, esse tipo de erro piora muito a leitura. Faz sentido que a classe Pessoa cuide de propriedades das pessoas, logo, a refatora√ß√£o a seguir √© poss√≠vel:\nClass ComprarIngressoService{ void comprar(Pessoa pessoa, Evento evento){ ... if(pessoa.maiorDeIdade()){ // menor de idade } if(pessoa.estaAtiva()){ // } } } Construtores, Builders e falta de amor aos erros de compila√ß√£o Um grande motivo para escrevermos c√≥digos que s√£o fortemente tipados √© a possibilidade de perceber erros em tempo de compila√ß√£o, erros que impedem que fa√ßamos coisas que n√£o fazem sentido dado o contexto do que estamos tentando fazer, a sem√¢ntica de string, por exemplo, entendida como cadeia de caracteres, n√£o permite a soma de n√∫meros a ela (Some um √† kaue).\nDito isto, grande parte das classes de dom√≠nio n√£o validam seu estado, muitas vezes nem em sua cria√ß√£o. √â comum ver por ai classes com construtores vazios e c√≥digos setters p√∫blicos (pois getters e setters teoricamente protegem o encapsulamento) isso por si s√≥ n√£o garante que uma classe ir√° ser usada como esperada, veja o exemplo a seguir.\nclass Pessoa{ Pessoa(){ // construtor vazio, no java √© opcional\t} @Getter @Setter // simulando o lombok, mas pode imaginar que s√£o m√©todos getter e setters p√∫blicos private Long id; @Getter @Setter private String nome; @Getter @Setter private Int peso; } // em algum outro lugar: Pessoa kaue = new Pessoa(); kaue.setId(1); kaue.setNome(\u0026#34;kaue\u0026#34;); kaue.setPeso(65); // teoricamente kaue est√° tranquilo levando em conta que todos os campos foram preenchidos, mas e o seguinte? Pessoa douglas = new Pessoa(); douglas.setPeso(70); N√£o existe erro de compila√ß√£o e nem de execu√ß√£o (POR ENQUANTO) aqui.\n√â √≥bvio que os setters deveriam validar se os campos foram preenchidos de seguindo um certo padr√£o e que faltam m√©todos para lidar com o objeto pessoa como indicado no ponto anterior, o modelo est√° an√™mico, mas esse n√£o √© o foco, criamos um objeto de uma Pessoa chamado douglas, que possui apenas seu peso definido, o que provavelmente n√£o faz sentido quando pensamos na cria√ß√£o de uma pessoa em um sistema, dever√≠amos (dependendo do neg√≥cio) ao menos for√ßar o preenchimento de id e nome.\nclass Pessoa{ Pessoa(String id, String nome){ // √∫nico construtor recebendo os campos opcionais. this.id=id; this.nome=nome; } @Getter // setter n√£o existe mais private Long id; @Getter // setter pode at√© existir, mas nesse caso n√£o vou criar. private String nome; @Getter @Setter private Int peso; } // em algum outro lugar: Pessoa kaue = new Pessoa(1,\u0026#34;kaue\u0026#34;); kaue.setPeso(65); Pessoa douglas = new Pessoa(); // erro douglas.setPeso(70); Mas e classes builders? Tamb√©m n√£o √© incomum ver builders que esquecem de implementar os campos obrigat√≥rios, para nossa felicidade, √© algo simples de ser resolvido.\nPessoaBuilder pessoaBuilder = new PessoaBuilder(1,\u0026#34;kaue\u0026#34;); // construtor do BUILDER tem em si os par√¢metros necess√°rios para criar a classe que constr√≥i // se o m√©todo para pegar o builder for um m√©todo est√°tico, s√≥ passar em seu par√¢metro Pessoa kaue = pessoaBuilder .withPeso(70) .build(); Usando o lombok @Builder, podemos fazer:\nimport lombok.Builder; @Builder(builderMethodName = \u0026#34;hiddenBuilder\u0026#34;) public class Person { @NotNull private String name; private String surname; public static PersonBuilder builder(String name) { return hiddenBuilder().name(name); // o nome desse builder interno √© arbitr√°rio } } // Person p = Person.builder(\u0026#34;Kaue\u0026#34;).surname(\u0026#34;Surname\u0026#34;).build(); Essa t√°tica, usando o lombok ou n√£o, tem alguns problemas e normalmente n√£o faz sentido em classes que tem muitos par√¢metros obrigat√≥rios e at√© mesmo em algumas classes simples, pois depreca, mesmo que um pouco, uma das grandes vantagens que a classe builder tem, a visibilidade, imagine isso:\nEndereco e = Endereco.builder(\u0026#34;Osvaldo Albherto\u0026#34;, \u0026#34;Parque Bitaru\u0026#34;, \u0026#34;42\u0026#34;, \u0026#34;Abilio\u0026#34;) .complemento(\u0026#34;Ap 1\u0026#34;) .maisInformacoes(\u0026#34;Pode entregar pro vizinho\u0026#34;) .build(); Somente lendo esse c√≥digo, voc√™ s√≥ consegue ter certeza do complemento e maisInformacoes, os outros campos n√£o s√£o t√£o vis√≠veis, ainda assim, como opini√£o pessoal, prefiro por ter esse c√≥digo, que se torna um pouco menos vis√≠vel mas garante o uso correto da classe, mostrando erros de compila√ß√£o na pr√≥pria IDE caso os atributos obrigat√≥rios n√£o estejam preenchidos.\nModelos Ricos: como lidar com depend√™ncias excessivas Se sua classe POJO de dom√≠nio necessitar de bibliotecas ou outras depend√™ncias (fa√ßa-as serem interfaces üôè), instanci√°-la ficar√° extremamente inconveniente, para isso existe o Design Pattern: Factory\nDesign Pattern: Factory Factories s√£o m√©todos (ou classes) que possuem como retorno a cria√ß√£o de um outro objeto, em casos mais simples, podem ser m√©todos est√°ticos dentro da pr√≥pria classe, em casos mais complexos, onde teremos diferentes depend√™ncias a serem injetadas nas classes de dom√≠nio atr√°ves de um framework ou container de inje√ß√£o de depend√™ncia, como o Spring faz, podemos usar classes.\nImagine a exist√™ncia de uma classe usu√°rio, que necessita que seu pr√≥prio email seja validado, e para isso, voc√™ quer usar uma biblioteca x ou y, voc√™, respeitando princ√≠pios b√°sicos, criar√° uma interface a qual Usu√°rio depender√°, e far√° com que a inje√ß√£o de depend√™ncia passe a voc√™ uma inst√¢ncia do validador em algum momento, isso ir√° se tornar extremamente inconveniente muito r√°pido, portanto, podemos fazer:\npublic class Usuario { private String email; private EmailValidator emailValidator; public Usuario(String email, EmailValidator emailValidator) { this.email = email; this.emailValidator = emailValidator; } public boolean isEmailValid() { return emailValidator.isValid(email); } // Outros m√©todos da classe Usuario } public class UsuarioFactory { private final EmailValidator emailValidator; // Construtor com inje√ß√£o de depend√™ncia! public UsuarioFactory(EmailValidator emailValidator) { this.emailValidator = emailValidator; } // M√©todo para criar inst√¢ncia de Usuario usando o validador de e-mail fornecido pelo Spring (ou pelo seu framework de DI) public Usuario createUsuario(String email) { return new Usuario(email, emailValidator); } } E os Services? Evans Descreve em seu livro tr√™s tipos de services:\nApplication Service:\nFornece para o usu√°rio opera√ß√µes que o seu software pode executar, e controla a execu√ß√£o dessas opera√ß√µes atrav√©s de chamadas a m√©todos de objetos das outras camadas (dom√≠nio, infraestrutura, etc.). √â importante dizer que a Application Service¬†n√£o cont√©m regras de neg√≥cios ou conhecimento do dom√≠nio, sendo assim, ela apenas coordena as chamadas a m√©todos de outras camadas e mant√©m o estado que reflete o progresso de uma opera√ß√£o para o usu√°rio. Application Layer: Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems. The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems. This layer is kept thin. It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down. It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program. - Evans DDD\nDomain Services:\nFornece para a¬†Application Service¬†m√©todos que permitam a execu√ß√£o de opera√ß√µes sobre os objetos de Dom√≠nio (camada mais interna). Embora seja comum representar grande parte dos conceitos e regras principais do neg√≥cio aqui, o ideal √© que esses detalhes sejam representados diretamente nos Domain Models. Sendo assim, o Domain Service deve chamar e controlar a execu√ß√£o de m√©todos dos objetos do Domain Model¬†quando n√£o √© trivial ou l√≥gico declarar um m√©todo diretamente no modelo de dom√≠nio As vezes, a situa√ß√£o simplesmente n√£o se trata de uma coisa.\nAlguns conceitos do dom√≠nio n√£o s√£o naturais para serem modelados na forma de objetos.\nFor√ßar a funcionalidade do dom√≠nio necess√°ria para que ela seja a responsabilidade de uma Entidade ou Objeto de Valor distorce a defini√ß√£o de um objeto baseado em modelos ou adiciona objetos artificiais sem sentido.\nAssim sendo:\nQuando um processo ou transforma√ß√£o significativa no dom√≠nio n√£o √© uma responsabilidade natural de uma Entidade ou Objeto de Valor, adicione uma opera√ß√£o no modelo como uma interface aut√¥noma declarada como Servi√ßo. Defina um contrato de servi√ßo, um conjunto de asser√ß√µes sobre intera√ß√µes com o Servi√ßo. (Veja ‚Äúasser√ß√µes‚Äù) Torne essas asser√ß√µes participantes da Linguagem Onipresente de um Contexto Delimitado espec√≠fico. D√™ um nome ao Servi√ßo, que tamb√©m se torne parte da Linguagem Onipresente. Evans - DDD\nInfrastructure Services:\nFornece m√©todos que permitem a execu√ß√£o de opera√ß√µes sobre a infraestrutura na qual o software est√° sendo executado. Isso significa que esses servi√ßos tem conhecimento sobre detalhes das implementa√ß√µes concretas da infraestrutura tais como: acesso a bancos de dados, acesso a rede, controle de opera√ß√µes de IO, acesso a hardware etc. Geralmente esse service √© utilizado pelos Application Services para complementar e auxiliar suas opera√ß√µes, por exemplo, fornecer um m√©todo que permita a cria√ß√£o e controle de um buffer para realizar download de arquivos. Contrapontos: Design a microservice domain model - Microsoft\nSome people say that the anemic domain model is an anti-pattern. It really depends on what you are implementing. If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern. However, if you need to tackle the complexity of a microservice‚Äôs domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context. In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.\nMicrosoft resource Aqui entendemos uma coisa que deve ser clara, n√£o existe bala de prata na computa√ß√£o, faz sentido abstra√≠rmos o SPRING, Controllers, Services e outras funcionalidades ou entedemos que nossa aplica√ß√£o nasce acoplada ao SPRING e morre com ele?\nAqui, tudo cabe √† voc√™ entender pontos, contrapontos e o seu contexto, no seu caso. Se sua aplica√ß√£o s√≥ existe junto √† infraestrutura de uma biblioteca, talvez n√£o haja motivo para desacopl√°-la, se voc√™ n√£o v√™ perspectivas para deixar de usar lombok, n√£o necessariamente precisa fazer seu modelo de dom√≠nio POJOS realmente puras use seu lombok, e seja feliz. Um projeto simples ou que necessita ser entregue muito rapidamente n√£o usar de conceitos como Arquitetura Hexagonal, DDD, CQRS ou qualquer outro pattern n√£o se traduz emprojeto simples ou que significa c√≥digo ruim.\nRefer√™ncias: The Software Architecture Chronicles\nEsse blog, essa cr√¥nica em espec√≠fico - √© maravilhosa!! Se estiver off, procure no wayback machine.\nDomain Driven Design, Eric Evans\nAnemic Domain Model, Martin Fowler (Cosigned by Evans)\nSum√°rio de Padr√µes e Defini√ß√µes do DDD - Traduzido por Ricardo Pereira Dias\nProjetando um microsservi√ßo orientado a DDD\nhttps://www.youtube.com/watch?v=1Lcr2c3MVF4\nPersistence Ignorance | DevIQ\nInfrastructure Ignorance\nHexagonal Architecture, DDD, and Spring | Baeldung\n","permalink":"https://kaue.cat/posts/software-architecture-basics/","summary":"Arquitetura √† nivel de Software: Refere-se √† organiza√ß√£o e defini√ß√£o de regras a serem seguidas no seu projeto em si, seja ele um microservi√ßo, monolito ou qualquer outra parte de uma solu√ß√£o maior, nossa √™nfase est√° no n√≠vel do seu servi√ßo, um servi√ßo seu pode seguir √† risca SOLID, arquitetura hexagonal e uma PoC pode seguir o famoso: faz r√°pido e funcionando.\nDe outro lado, cuidando e decidindo se temos SOA, Microservi√ßos, Monolitos ou qual protocolo de comunica√ß√£o usamos, temos a arquitetura de solu√ß√µes, o que n√£o √© o foco do artigo","title":"Arquitetura de Software para devs: MVC, Hexagonal, DDD"},{"content":"Leitura no Notion: SOLID\nSei que existem 1 milh√£o de posts sobre SOLID, considero esse \u0026ldquo;guia\u0026rdquo; um pouco fora do comum pelo seu aprofundamento, tentei esclarecer todas as d√∫vidas que tinha ou poderia ter e sempre trazer exemplos, al√©m de usar boas refer√™ncias. Espero que esse post seja o seu guia definitivo de SOLID, assim como √© para mim!\nO que √© SOLID? SOLID √© um Acr√¥nimo para 5 boas pr√°ticas e/ou princ√≠pios que envolvem o desenvolvimento de um bom c√≥digo orientado √† objetos, n√£o quero me estender na origem, vamos para os princ√≠pios!\nSingle Responsability Principle O nome, embora auto-explicativo e que muitas vezes levava esse princ√≠pio a ser explicado como ‚ÄúUma classe deve ter uma, e apenas uma responsabilidade‚Äù n√£o √© necessariamente o que voc√™ deve pensar na hora de implement√°-lo. Entenda esse padr√£o como : ‚ÄúUma classe deve ter um, e apenas um motivo para mudar‚Äù. Ou seja, n√£o crie uma classe com a fun√ß√£o de Emitir Nota Fiscal, crie uma classe NotaFiscal, e garanta que apenas coisas que envolvem o dom√≠nio de Nota Fiscal ir√£o altera-l√°, a mudan√ßa da emiss√£o n√£o muda o seu dom√≠nio de Nota Fiscal. Se uma altera√ß√£o na impressora fizer a classe Nota Fiscal ser alterada, algo est√° incorreto.\nA quest√£o principal do SRP √© o motivo para uma classe ser modificada. E esse motivo para mudan√ßa, em geral, est√° relacionado a um grupo de usu√°rios ou stakeholders, que Uncle Bob chama de atores. - Desbravando Solid\nLevando em conta o que dizemos acima, tamb√©m podemos dizer que o SRP pode ser definido por: ‚ÄúUm m√≥dulo deve ser respons√°vel por um , e apenas um ator‚Äù. O ator que se importa com a fun√ß√£o da emiss√£o nota fiscal √© o setor de vendas, o ator que se importa com suas horas extras, o rh, o ator que se importa com salvar no banco por id √© a implementa√ß√£o de persist√™ncia.\nCada \u0026ldquo;interessado\u0026rdquo;, de neg√≥cio ou t√©cnico, faz com que a classe tenha uma responsabilidade diferente.\nIdentificar classes que mudam por diversos motivos (ou atores) √© simples, a coes√£o pode ser uma das m√©tricas utilizadas:\nClasses coesas t√™m uma caracter√≠stica semelhante: os conceitos que essas classes representam estariam relacionados e separ√°-los seria pouco natural. O SRP, no fim das contas, √© uma outra maneira de falar sobre a necessidade de c√≥digo coeso. - Desbravando Solid\nAniche (OOP E SOLID para ninjas) sugere que, para encontrar classes pouco coesas, devemos procurar classes que:\nPossuem muitos m√©todos diferentes. S√£o modificadas com frequ√™ncia. N√£o param nunca de crescer. Outro fator importante √© perceber a duplica√ß√£o (ou pior, repeti√ß√£o) de c√≥digo. Se seu c√≥digo possui partes repetidas diversas vezes, tenha isso como um forte indicativo que essa responsabilidade provavelmente deveria estar encapsulada em algum lugar (e muito provavelmente em uma classe).\nPortanto, se seu sistema pega os dados, busca coisas no banco, salva como ePUB ou PDF, tudo em uma classe s√≥, ele provavelmente n√£o √© coeso e muito menos segue o SRP. Um exemplo disso √© que toda vez que a maneira que um pdf for gerado houver de mudar, voc√™ ter√° que mexer nessa classe principal, e se voc√™ tiver que repetir essa altera√ß√£o em diversos pontos onde o c√≥digo est√° repetido (o que j√° n√£o √© um bom indicador), voc√™ provavelmente ter√° problemas em algum momento (e mesmo que n√£o tenha, sua manuten√ß√£o definitivamente n√£o est√° facilitada).\nCaso real Recentemente ajudei um amigo em um projeto pessoal, onde ele enviava emails para a confirma√ß√£o de cadastro de usu√°rios, todas essas responsabilidades ficavam dentro da mesma classe Usu√°rio (Gerar token, enviar email, registrar usu√°rio). A partir da√≠, trabalhamos para termos um c√≥digo mais coeso, no momento em que um usu√°rio √© registrado, ele envia um evento de registro de usu√°rio (o que √© s√≥ um aviso falando: cadastrei um usu√°rio). Com isso, uma classe chamada enviarEmailListener se prontificava a ouvir eventos de registro e altera√ß√£o de senha de usu√°rio e ela era a respons√°vel por enviar emails. Portanto, com o refactor, a classe de Usu√°rio n√£o se preocupa com o que acontece ap√≥s o registro do usu√°rio, ela apenas notifica que isso aconteceu. Outro ponto de melhoria nisso foi a possibilidade de tornar o envio do email ass√≠ncrono, ent√£o para cadastrar um usu√°rio, n√£o precisavamos esperar o servi√ßo de email fazer sua a√ß√£o, ela √© independente (nesse caso, n√£o fazia sentido ser uma transa√ß√£o, o cadastro de um usu√°rio n√£o depende do email, se um erro ocorrer nessa etapa, ele pode s√≥ pedir outro email)\nNote que se tivermos mais ocasi√µes onde devemos enviar emails de usu√°rio (al√©m de cadastro e altera√ß√£o de emails) podemos apenas adicionar um novo evento a ser ouvido pelo listener e se precisarmos mudar a forma de enviar email, mudamos apenas em um √∫nico m√©todo (o que aumenta MUITO a capacidade de manter o c√≥digo), essa √© a fun√ß√£o do SRP.\nOpen-Closed Principle Software entities \u0026hellip; should be open for extension, but closed for modification.\nA module will be said to be open if it is still available for extension. For example, it should be possible to add fields to the data structures it contains, or new elements to the set of functions it performs.\nEssas cita√ß√µes trazem uma no√ß√£o base do que o OCP quer dizer, nosso c√≥digo deve estar sempre pronto para evoluir. e de maneira natural, n√£o devemos sentir a necessidade de modificar muitos arquivos diferentes, ou mesmo procurar (usando o CTRL+F, por exemplo) os lugares que devem ser alterados.\nA segunda parte diz sobre ser fechada para modifica√ß√£o. nesse aspecto, podemos entender que elas n√£o devem ter seu comportamento alterado a todo momento.\nUm exemplo public class CalculadoraDePrecos { public double calcula(Compra produto) { Frete correios = new Frete(); double desconto = 0.0; // Inicialize desconto com um valor padr√£o if (REGRA 1) { // faz algo } if (REGRA 2) { // faz algo } return produto.getValor() * (1 - desconto) + frete; } } Note que sempre que adicionarmos regras de frete, nosso c√≥digo precisar√° alterar a classe calculadora de pre√ßos, incluindo um novo IF, ou seja, a classe que implementar a regra de frete est√° acoplada √† Calculadora de Pre√ßos\nUma segunda implementa√ß√£o comum √© colocar os ifs dentro das classes espec√≠ficas. Por exemplo, a classe Frete passaria a ter as diferentes regras de neg√≥cio (os mesmos if-else). Apesar de ficar melhor, continua claro que n√£o √© a melhor abordagem.\nMelhorando Se temos diferentes regras de desconto e de frete, basta criarmos interfaces que as representam:\npublic interface TabelaDePreco { double descontoPara(double valor); } public class TabelaDePreco1 implements TabelaDePreco { } public class TabelaDePreco2 implements TabelaDePreco { } public class TabelaDePreco3 implements TabelaDePreco { } public interface ServicoDeEntrega { double para(String cidade); } public class Frete1 implements ServicoDeEntrega {} public class Frete2 implements ServicoDeEntrega {} public class Frete3 implements ServicoDeEntrega {} \u0026ldquo;Veja que essa simples mudan√ßa altera toda a maneira de se lidar com a classe. Com ela \u0026lsquo;aberta\u0026rsquo;, ou seja, recebendo as depend√™ncias pelo construtor, podemos passar a implementa√ß√£o concreta que quisermos para ela. Se passarmos a implementa√ß√£o TabelaDePreco1, e invocarmos o m√©todo calcula(), o resultado ser√° um; se passarmos a implementa√ß√£o TabelaDePreco2 e invocarmos o mesmo m√©todo, o resultado ser√° outro.\u0026rdquo; (ANICHE, 2015).\npublic class CalculadoraDePrecos { private TabelaDePreco tabela; private ServicoDeEntrega entrega; public CalculadoraDePrecos(TabelaDePreco tabela, ServicoDeEntrega entrega) { this.tabela = tabela; this.entrega = entrega; } public double calcula(Compra produto) { double desconto = tabela.descontoPara(produto.getValor()); double frete = entrega.para(produto.getCidade()); return produto.getValor() * (1 - desconto) + frete; } } Note que aqui trabalhamos tamb√©m com a invers√£o de depend√™ncias (DIP), o ‚ÄúD‚Äù, do SOLID.\n\u0026ldquo;Se o OCP declara\to objetivo de\tuma\tarquitetura OO, o DIP declara o seu mecanismo\tfundamental.\u0026rdquo;\nSe voc√™ ainda n√£o leu sobre o DIP, continue lendo o post, mais tarde revisite esse ponto, vai fazer sentido üòÉ\nAbstra√ß√µes e Capacidade de Extens√£o \u0026ldquo;O que discutimos aqui, de certa forma, mistura-se com a discuss√£o do cap√≠tulo anterior sobre estabilidade e invers√£o de depend√™ncias. As interfaces (abstra√ß√µes) TabelaDePreco e ServicoDeEntrega tendem a ser est√°veis. A CalculadoraDePrecos √© uma implementa√ß√£o mais inst√°vel e que s√≥ depende de abstra√ß√µes est√°veis. Pensar em abstra√ß√µes nos ajuda a resolver o problema do acoplamento e, de quebra, ainda nos ajuda a ter c√≥digos facilmente extens√≠veis. Isso √© programar orientado a objetos. √â lidar com acoplamento, coes√£o, pensando em abstra√ß√µes para nossos problemas. Quando se tem uma boa abstra√ß√£o, √© f√°cil evoluir o sistema. Seu sistema deve evoluir por meio de novas implementa√ß√µes dessas abstra√ß√µes, previamente pensadas, e n√£o por meio de diversos ifs espalhados por todo o c√≥digo.\u0026rdquo; (ANICHE, 2015).\nDesign Pattern: Command N√£o vou me aprofundar em patterns nesse post, mas acho legal repassar alguns exemplos que vi no material base\npublic class EmissorNotaFiscal\t{ private\tRegrasDeTributacao\ttributacao; private\tLegislacaoFiscal\tlegislacao; private\tList\u0026lt;AcaoPosEmissao\u0026gt;\tacoes; //... public\tNotaFiscal\tgera(Fatura\tfatura) { List\u0026lt;Imposto\u0026gt;\timpostos\t=\ttributacao.verifica(fatura); List\u0026lt;Isencao\u0026gt;\tisencoes\t=\tlegislacao.analisa(fatura); //\tm√©todo\tauxiliar NotaFiscal\tnota\t=\taplica(impostos,\tisencoes); //\tmodificado for\t(AcaoPosEmissao\tacao:\tacoes)\t{ acao.faz(nota); } return\tnota; } Exemplo do livro Desbravando Solid (AQUILES, 2022)\nNote que √© muito f√°cil adicionar novos comportamentos depois de uma nota fiscal ser emitida, podemos simplesmente adicionar um objeto na lista de a√ß√µes, isso caracteriza o padr√£o Command.\nRecomendo a leitura mais aprofundada em: https://refactoring.guru/design-patterns/command\nDesign Pattern: Strategy Exemplo de: https://en.wikipedia.org/wiki/Strategy_pattern\n\u0026ldquo;Strategy permite que o algoritmo varie independentemente dos clientes que o utilizam. Strategy √© um dos padr√µes inclu√≠dos no influente livro \u0026ldquo;Design Patterns\u0026rdquo; de Gamma et al., que popularizou o conceito de usar padr√µes de design para descrever como projetar software orientado a objetos flex√≠vel e reutiliz√°vel. Adiar a decis√£o sobre qual algoritmo usar at√© o tempo de execu√ß√£o permite que o c√≥digo chamador seja mais flex√≠vel e reutiliz√°vel.\u0026rdquo; https://en.wikipedia.org/wiki/Strategy_pattern\npublic interface IComportamentoDeFreio { public void frear(); } public class FreioComABS implements IComportamentoDeFreio { public void frear() { System.out.println(\u0026#34;Freio com ABS aplicado\u0026#34;); } } public class FreioSimples implements IComportamentoDeFreio { public void frear() { System.out.println(\u0026#34;Freio simples aplicado\u0026#34;); } } /* Cliente que pode usar os algoritmos acima de forma intercambi√°vel */ public abstract class Carro { private IComportamentoDeFreio comportamentoDeFreio; public Carro(IComportamentoDeFreio comportamentoDeFreio) { this.comportamentoDeFreio = comportamentoDeFreio; } public void aplicarFreio() { comportamentoDeFreio.frear(); // note que usamos a interface! } public void setComportamentoDeFreio(IComportamentoDeFreio tipoDeFreio) { this.comportamentoDeFreio = tipoDeFreio; // podemos mudar livremente! } } public class SUV extends Carro { public SUV() { super(new FreioComABS()); } } public class CarExample { public static void main(final String[] arguments) { Carro suvCar = new SUV(); suvCar.frear(); // freio com abs suvCar.setBrakeBehavior( new FreioSimples() ); suvCar.frear(); // freia, mas sem abs. } } Nesse exemplo, note que definimos uma interface comum, a qual um carro se acopla, podemos trocar a implementa√ß√£o dessa interface livremente, tamb√©m ajuda no OCP.\nLiskov Substitution Principle Fun√ß√µes que utilizam ponteiros ou refer√™ncias para classes base devem ser capazes de usar objetos de classes derivadas sem saber disso\nNesse caso, vamos come√ßar com cita√ß√µes:\n\u0026ldquo;Se um gato possui ra√ßa e patas, e um cachorro possui ra√ßa, patas e tipoDoPelo, logo Cachorro extends Gato? Pode parecer engra√ßado, mas √© (\u0026hellip;) heran√ßa por pregui√ßa, por comodismo, porque vai dar uma ajudinha. A rela√ß√£o ‚Äú√© um‚Äù n√£o se encaixa aqui, e vai nos gerar problemas.\u0026rdquo; Paulo Silveira, no artigo Como n√£o aprender orienta√ß√£o a objetos: Heran√ßa (SILVEIRA, 2006)\nO Princ√≠pio da Substitui√ß√£o de Liskov (LSP) estabelece uma diretriz fundamental : Ele afirma que objetos de classes derivadas ou subclasses devem poder ser usados no lugar de objetos da classe base ou superclasse sem quebrar o comportamento esperado do programa. Em outras palavras, uma classe derivada deve estender ou especializar o comportamento da classe base sem modificar seu contrato.\n\u0026ldquo;A ideia intuitiva de um subtipo √© aquela cujos objetos fornecem todo o comportamento de objetos de outro tipo (o supertipo) mais algo extra.\u0026rdquo; Data Abstraction and Hierarchy (LISKOV, 1988)\nImagine um exemplo em que temos uma classe base chamada Animal e classes derivadas, como Cachorro e Gato. O LSP nos orienta a garantir que qualquer c√≥digo que funcione com objetos Animal tamb√©m funcione corretamente com objetos Cachorro e Gato. Isso significa que as subclasses n√£o devem introduzir comportamentos que contradigam as expectativas estabelecidas pela classe base. Ou seja, se todo animal implementa o m√©todo comer, classes derivadas desse Animal devem tamb√©m incluir o m√©todo comer, que funciona como esperado. (Se seu animal n√£o come, reveja suas abstra√ß√µes, o pr√≥ximo princ√≠pio, ISP, pode ser √∫til aqui!)\nFavore√ßa composi√ß√£o sobre Heran√ßa Essa √© uma frase amplamente falada no meio da computa√ß√£o, algo que voc√™ j√° ouviu milhares de vezes, seja em artigos, livros como o Design Patterns, do GoF ou at√© mesmo v√≠deos no youtube, mas por qu√™?\nEm vez de herdar comportamentos de uma classe base, prefira compor objetos que fornecem os comportamentos necess√°rios. O princ√≠pio de design normalmente come√ßa pela defini√ß√£o de interfaces que representam o comportamento que o sistema deve exibir, as classes recebem objetos dessas interfaces e fazem os comportamentos a partir da√≠\nBenef√≠cios Favorecer a composi√ß√£o proporciona maior flexibilidade no design. √â mais natural construir classes de dom√≠nio de neg√≥cios a partir de v√°rios componentes do que tentar encontrar pontos em comum entre eles e criar uma √°rvore de heran√ßa. Por exemplo, um pedal de acelerador e um volante t√™m poucos tra√ßos em comum, mas s√£o componentes vitais em um carro.\nAl√©m disso, a composi√ß√£o oferece um dom√≠nio de neg√≥cios mais est√°vel, pois est√° menos sujeito √†s peculiaridades dos membros da fam√≠lia. Em outras palavras, √© melhor compor o que um objeto pode fazer (tem-um) do que estender o que ele √© (√©-um).\nDrawbacks ‚ÄúComposition is good until it is not‚Äù - O uso excessivo de composi√ß√£o pode levar a classes superlotadas e complexas, mas de maneira geral, se voc√™ mantiver : A divis√£o de responsabilidades, O acoplamento controlado, Uso de Design Patterns adequados, isso provavelmente n√£o ser√° um problema.\nInterface Segregation Principle ‚Äú*Make fine grained interfaces that are client specific.‚Äù ‚ÄùClients should not be forced to depend upon interfaces that they do not use‚Äù\nUncle Bob*\nO Interface Segregation Principle (ISP) basicamente nos orienta a escrever interfaces coesas, em que seus m√©todos conversem entre si e sempre sejam implementados.\nVamos a um exemplo:\ninterface Imposto { NotaFiscal geraNota(); double imposto(double valorCheio); } Imagine que em algum momento da exist√™ncia da sua aplica√ß√£o, um imposto n√£o gere nota fiscal, nesse caso, ele ir√° jogar uma exception? retornar nulo? √â exatamente esse tipo de situa√ß√£o que o ISP quer que voc√™ evite passar, pois ambas as op√ß√µes anteriores s√£o ruins e configuram quebra de contrato.\nNesse caso anterior, temos uma interface n√£o muito coesa, com dois comportamentos distintos (isso se d√° pois um imposto nem sempre gera nota), nesse caso, o mais adequado seria dividi-la em duas interfaces distintas, como por exemplo:\ninterface Tributavel{ double imposto(double valorCheio); } interface GeradorNF{ NotaFiscal geraNota(); } Com isso, podemos fazer com que nossas classes sejam constru√≠das por composi√ß√£o de interfaces que √†s sirvam perfeitamente, como:\nclass ImpostoGeraNota implements Tributavel, GeradorNF{ // os dois m√©todos aqui } class Imposto implements Tributavel{ // implementa imposto(double valorCheio) } Many client specific interfaces are better than one general purpose interface\nUncle Bob\nAl√©m disso, muitas vezes queremos apenas parte dos atributos ou comportamentos de uma classe, e\nSe voc√™ tiver uma classe que tenha v√°rios clientes, em vez de carregar a classe com todos os m√©todos de que os clientes precisam, crie interfaces espec√≠ficas para cada cliente e implemente-as na classe.\nDesign Principles and Design Patterns¬†(MARTIN, 2000)\nCita√ß√£o retirada da Refer√™ncia da Caelum\nPor que? Mas Kau√™, por qu√™ √© uma boa pr√°tica criarmos interfaces magras? Como disse anteriormente, a palavra chave √© coes√£o, a coes√£o √© o elemento chave que garante a estabilidade de nossas interfaces, e se essa interface realmente precisar ser mudada, apenas os membros que implementam ela ter√£o sua implementa√ß√£o alterada. No final das contas, o ISP √© sobre avaliarmos a coes√£o das nossas interfaces,\nLembre-se tamb√©m que devemos sempre nos acoplar a membros os mais est√°veis poss√≠veis! Nesse caso, tanto Tributavel quanto GeradorNF s√£o mais interfaces coesas e est√°veis.\n‚ÄúClasses que dependem de interfaces leves sofrem menos com mudan√ßas em outros pontos do sistema. Novamente, elas s√£o pequenas, portanto, t√™m poucas raz√µes para mudar.‚Äù - Aniche, M. OOP E SOLID para Ninjas.\nDependency Inversion Principle Depend upon Abstractions. Do not depend upon concretions. - Design Principles and Design Patterns, Bob Martin.\nAqui, vamos come√ßar com conceitos bem fundamentados dentro da computa√ß√£o\n‚ÄúDepender de abstra√ß√µes e n√£o de implementa√ß√µes‚Äù - Bob Martin ‚ÄùPrograme voltado √† interface, n√£o √† implementa√ß√£o‚Äù - Design Patterns, GoF\nMas o que isso significa? A ideia aqui √© que abstra√ß√µes e interfaces definem contratos est√°veis para nossos sistemas, classes e comportamentos base do sistema, ou seja, n√£o-vol√°teis, n√£o devem ser impactados por implementa√ß√£o de m√≥dulos as quais elas dependem.\nSua classe que cuida do registro do usu√°rio n√£o deve depender da implementa√ß√£o que o envio de email possui, voc√™ n√£o deve ter imports de uma biblioteca espec√≠fica dentro de uma classe que cuida de regras de neg√≥cio. Nesse caso, voc√™ dever√° usar abstra√ß√£o, por exemplo, EnviadorEmail e usar√° algum m√©todo dela que encapsule detalhes de implementa√ß√£o\nVamos ver um exemplo bom:\npublic interface EnviadorEmail { void enviarEmail(String destinatario, String mensagem); } // em seu pr√≥prio arquivo: public class RegistrarUsuario { private final EnviadorEmail enviadorEmail; public RegistrarUsuario (EnviadorEmail enviadorEmail) { this.enviadorEmail = enviadorEmail; } public void registrarUsuario(String nome, String email) { // L√≥gica para registrar o usu√°rio // Envio de e-mail de boas-vindas String mensagem = \u0026#34;Bem-vindo, \u0026#34; + nome + \u0026#34;!\u0026#34;; enviadorEmail.enviarEmail(email, mensagem); } } No c√≥digo acima, podemos mudar a implementa√ß√£o do provedor de email e n√£o precisaremos mexer na classe RegistrarUsu√°rio, perfeito!\nUm pouco mais concreto: Vamos dar algumas defini√ß√µes que podem ajudar a voc√™ seguir como guideline para garantir que seu c√≥digo est√° desacoplado\nM√≥dulos de Alto N√≠vel: S√£o m√≥dulos que implementam regras de neg√≥cio, devem ser reutiliz√°veis, est√°veis e inafetados por mudan√ßas em m√≥dulos de baixo n√≠vel.\nM√≥dulos de Baixo N√≠vel: S√£o m√≥dulos que dizem respeito √† detalhes de implementa√ß√£o, muitas vezes, agem como utilit√°rios para m√≥dulos de alto n√≠vel, mas devem ser utilizados atrav√©s de uma barreira de abstra√ß√£o sempre que fizer sentido\nPortanto, nossa ‚Äú‚Äùregra‚Äù‚Äù √©:\nM√≥dulos de Alto n√≠vel n√£o devem depender explicitamente de m√≥dulos de baixo n√≠vel, e sim de abstra√ß√µes.\nE de onde vem o nome de ‚ÄúInvers√£o de Depend√™ncia‚Äù? No exemplo acima √© claro, RegistrarUsu√°rio, uma classe de alto n√≠vel, depende do Enviador de Email, que utiliza a depend√™ncia do AWS SES, no final das contas, RegistrarUsu√°rio tamb√©m est√° acoplado ao SES.\nNesse caso, note que as depend√™ncias foram invertidas.\nNem toda interface √© de alto n√≠vel A linguagem Java est√° cheia de interfaces e abstra√ß√µes, mas muitas vezes essas abstra√ß√µes atuam diretamente sobre detalhes de implementa√ß√£o, como java.sql.Connection do JDBC, elas s√£o interfaces para mecanismos de entrega, detalhes t√©cnicos e uma classe que depende delas, n√£o necessariamente segue o dip, mas isso n√£o √© um problema, pois essas interfaces s√£o est√°veis\nDicas gerais N√£o precisamos implementar e criar uma depend√™ncia diretamente com a classe EnviadorEmailX ou EnviadorEmailY, nesse caso, podemos usar o design pattern Factory e abstrair essa depend√™ncia, podemos fazer isso dentro da pr√≥pria interface com java. public interface EnviadorEmail { void enviarEmail(String destinatario, String mensagem); static EnviadorEmail criarEnviadorEmailPadrao() { return new EnviadorEmailPadrao(); } static EnviadorEmail criarEnviadorEmailAlternativo() { return new EnviadorEmailAlternativo(); } } // Em outra classe public class Main { public static void main(String[] args) { EnviadorEmail enviadorPadrao = EnviadorEmail.criarEnviadorEmailPadrao(); EnviadorEmail enviadorAlternativo = EnviadorEmail.criarEnviadorEmailAlternativo(); // Use as inst√¢ncias de EnviadorEmail conforme necess√°rio enviadorPadrao.enviarEmail(\u0026#34;destinatario@example.com\u0026#34;, \u0026#34;Mensagem de teste\u0026#34;); enviadorAlternativo.enviarEmail(\u0026#34;outrodestinatario@example.com\u0026#34;, \u0026#34;Outra mensagem de teste\u0026#34;); } } Em java, se definirmos interfaces comuns para diversos provedores de notifica√ß√£o como enviadorMensagem, que ser para tanto enviadorEmail quanto enviadorSMS, podemos fazer com que o spring nos entregue uma lista com todos os Beans anotados com @Component que satisfa√ßa essa interface (Podemos usar o applicationContext para isso), simplificando o c√≥digo iterando pela lista e usando o seu m√©todo de enviar. @Component public class EnviadorEmail implements EnviadorMensagem { @Override public void enviarMensagem(String destinatario, String mensagem) { // abstraido :p } } @Component public class EnviadorSMS implements EnviadorMensagem { // voc√™ j√° sabe } Importante!! Obrigado pela leitura, espero que tenha sido √∫til, de verdade, tentei trazer exemplos de c√≥digo e bastante cita√ß√µes, mas a maioria desse tipo de conte√∫do √© fonte dos livros da casa do c√≥digo e caelum, mas de maneira mais enxuta e com minhas palavras, recomendo fortemente a compra dos dois livros abaixo.\nSe encontrar erros ortogr√°ficos ou algo estranho, me envie uma mensagem ou comente aqui, arrumarei assim que poss√≠vel. N√£o farei uma rigorosa verifica√ß√£o antes de postar aqui.\nRefer√™ncias https://www.amazon.com.br/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8\nhttps://en.wikipedia.org/wiki/Composition_over_inheritance\nhttps://www.casadocodigo.com.br/products/livro-oo-solid\nhttps://www.casadocodigo.com.br/products/livro-desbravando-solid\nhttps://github.com/caelum/apostila-oo-avancado-em-java/blob/master/09-interface-segregation-principle.md\nhttps://en.wikipedia.org/wiki/Strategy_pattern\nhttps://refactoring.guru/design-patterns/command\n","permalink":"https://kaue.cat/posts/solid/","summary":"Leitura no Notion: SOLID\nSei que existem 1 milh√£o de posts sobre SOLID, considero esse \u0026ldquo;guia\u0026rdquo; um pouco fora do comum pelo seu aprofundamento, tentei esclarecer todas as d√∫vidas que tinha ou poderia ter e sempre trazer exemplos, al√©m de usar boas refer√™ncias. Espero que esse post seja o seu guia definitivo de SOLID, assim como √© para mim!\nO que √© SOLID? SOLID √© um Acr√¥nimo para 5 boas pr√°ticas e/ou princ√≠pios que envolvem o desenvolvimento de um bom c√≥digo orientado √† objetos, n√£o quero me estender na origem, vamos para os princ√≠pios!","title":"SOLID! Um Post Aprofundado"},{"content":"Texto necessita outra revis√£o.\nAprofundando Nota: Nesse momento, entraremos um pouco mais em detalhes sobre como o protocolo AMQP funciona, escrevi um ‚Äúguia‚Äù bem b√°sico sobre propriedades do protocolo, se quiser conferir, pode ver aqui :)\nmensageria.pdf\nOu nesse link\nContexto O Spring AMQP consiste em dois m√≥dulos principais: spring-amqp e spring-rabbit. O ‚Äòspring-amqp‚Äô cont√©m o pacote org.springframework.amqp.core, que trata das principais abstra√ß√µes definidas no protocolo AMQP (RabbitMQ √© um broker, que implementa esse protocolo), esse pacote n√£o se baseia em nenhuma biblioteca de clientes nem implementa√ß√£o de broker.\nEssas abstra√ß√µes ent√£o s√£o implementadas pelos m√≥dulos espec√≠ficos dos brokers (spring-rabbit). Teoricamente, como o AMQP √© opera em n√≠vel de protocolo, voc√™ poderia utilizar o cliente do rabbit com outro broker, mas isso n√£o √© oficialmente suportado.\nA mensagem A mensagem ****definida no protocolo amqp √© um conjunto de bytes e propriedades, passados separadamente. Para tornar o uso mais f√°cil, dentro do java juntamos isso em uma abstra√ß√£o chamada Message\npublic class Message { private final MessageProperties messageProperties; private final byte[] body; public Message(byte[] body, MessageProperties messageProperties) { this.body = body; this.messageProperties = messageProperties; } public byte[] getBody() { return this.body; } public MessageProperties getMessageProperties() { return this.messageProperties; } } A exchange A exchange √© uma outra abstra√ß√£o simples, √© basicamente o centro de distribui√ß√£o de mensagens, que envia as mensagens de acordo com suas diretrizes:\npublic interface Exchange { String getName(); String getExchangeType(); boolean isDurable(); boolean isAutoDelete(); Map\u0026lt;String, Object\u0026gt; getArguments(); } Os tipos b√°sicos de exchange s√£o: direct, topic, fanout e headers. Voc√™ pode encontrar implementa√ß√µes para cada um dos tipos no pacote core.\nA¬†Topic¬†exchange supports bindings with routing patterns that may include the \u0026lsquo;*\u0026rsquo; and \u0026lsquo;#\u0026rsquo; wildcards for \u0026rsquo;exactly-one\u0026rsquo; and \u0026lsquo;zero-or-more\u0026rsquo;, respectively. The¬†Fanout¬†exchange publishes to all queues that are bound to it without taking any routing key into consideration.\nQueues A classe Queue¬†tamb√©m representa uma abstra√ß√£o desse tipo no protocolo:\npublic class Queue { private final String name; private volatile boolean durable; private volatile boolean exclusive; private volatile boolean autoDelete; private volatile Map\u0026lt;String, Object\u0026gt; arguments; /** * The queue is durable, non-exclusive and non auto-delete. * * @param name the name of the queue. */ public Queue(String name) { this(name, true, false, false); } // Getters e Setters omitidos } Bindings Bindings s√£o a rela√ß√£o entre filas e exchanges!\nnew Binding(someQueue, someDirectExchange, \u0026#34;foo.bar\u0026#34;); // direct exchange, routing keys fixas new Binding(someQueue, someTopicExchange, \u0026#34;foo.*\u0026#34;); // topic exchange, usando wildcard new Binding(someQueue, someFanoutExchange); // fanout Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with(\u0026#34;foo.*\u0026#34;); // BindingBuilder √© a maneira bonitinha, eu gosto, mas importa est√°tico! Definindo Exchanges e Bindings customizadas J√° vimos nos exemplos anteriores como as exchanges, bindings e queues s√£o criadas, a partir de agora, s√≥ criar!\nNossas configura√ß√µes, ao inv√©s de s√≥ possuir bean de Queue, agora incluir√£o Exchangese Bindings\n@Configuration @Slf4j @RequiredArgsConstructor public class RabbitMqConfiguration { private final TicketQueueProperties ticketQueueProperties; @Bean public Queue queue(){ log.info(\u0026#34;Looking for queue: {}\u0026#34;, ticketQueueProperties.getName()); return new Queue(ticketQueueProperties.getName(), true); } @Bean Exchange ticketDirectExchange(){ final String EXCHANGE_NAME = \u0026#34;ticket\u0026#34;; log.info(\u0026#34;Creating exchange: ticket-exchange\u0026#34;); return new DirectExchange(EXCHANGE_NAME); } @Bean Binding ticketBinding(){ log.info(\u0026#34;Create ticket binding\u0026#34;); return BindingBuilder.bind(queue()).to(ticketDirectExchange()).with(ticketQueueProperties.getName()).noargs(); } } Perfeito, j√° vimos nossa exchange funcionando bonito! Tudo pronto!\nS√≥ que n√£o! Lembre-se que o nosso publisher est√° enviando mensagens com a routing key correta, mas para a exchange errada, vamos mudar o c√≥digo para o seguinte:\nrabbitTemplate.convertAndSend(\u0026#34;direct.ticket\u0026#34;,ticketQueueProperties.getName(),event.name()); Aqui dever√≠amos puxar esse nome da nossa ideal TicketQueueProperties :) para evitar esse spaghetti Passando Objetos - Message Converters O AmqpTemplate tamb√©m define v√°rios m√©todos para enviar e receber mensagens que, no fim das contas, delegam tarefas para um MessageConverter. O MessageConverter fornece um m√©todo √∫nico para cada dire√ß√£o: um para converter para um Message e outro para converter a partir de um Message.\nDefini√ß√£o da interface MessageConverter:\npublic interface MessageConverter { Message toMessage(Object object, MessageProperties messageProperties) throws MessageConversionException; Object fromMessage(Message message) throws MessageConversionException; } SimpleMessageConverter A implementa√ß√£o padr√£o do strategy MessageConverter √© chamada de SimpleMessageConverter. Este √© o conversor usado por uma inst√¢ncia de RabbitTemplate se voc√™ n√£o configurar explicitamente uma alternativa.\nConverts a String to a¬†[TextMessage](https://jakarta.ee/specifications/platform/9/apidocs/jakarta/jms/TextMessage.html), a byte array to a¬†[BytesMessage](https://jakarta.ee/specifications/platform/9/apidocs/jakarta/jms/BytesMessage.html), a Map to a¬†[MapMessage](https://jakarta.ee/specifications/platform/9/apidocs/jakarta/jms/MapMessage.html), and a Serializable object to a¬†[ObjectMessage](https://jakarta.ee/specifications/platform/9/apidocs/jakarta/jms/ObjectMessage.html)¬†(or vice versa).\nTrocando o Conversor Para trabalhar com objetos serializados e desserializados para JSON, vamos usar o Jackson2JsonMessageConverter.\n@Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } Colocaremos isso tanto no consumer quanto no producer :)\nDeclarables, Defini√ß√£o Din√¢mica e Declarativa de Filas Falamos anteriormente do nossoTicketQueueProperties , que poder√≠amos melhor√°-lo, √© o que vamos fazer, na realidade, vamos substitu√≠-lo.\nPrimeiro de tudo, vamos definir um formato declarativo para filas, exchanges e bindings que nos agrade, para mim:\nbroker: queues: ticket: name: default.ticket exchanges: ticket: name: direct.ticket type: direct bindings: ticket: exchange: direct.ticket queue: default.ticket routingKey: default.ticket Criando um ConfigurationProperties adequado A partir disso, vamos mapear essas propriedades em classes de uma maneira adequada. Chamarei a classe de BrokerConfigurationProperties:\npackage com.kaue.ticketservice.infrastructure.properties; import jakarta.validation.constraints.NotEmpty; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import java.util.Map; import lombok.Data; @Configuration @ConfigurationProperties(prefix = \u0026#34;broker\u0026#34;) @Data public class BrokerConfigurationProperties { private Map\u0026lt;String, QueueProperties\u0026gt; queues; private Map\u0026lt;String, ExchangeProperties\u0026gt; exchanges; private Map\u0026lt;String, BindingProperties\u0026gt; bindings; @Data public static class QueueProperties { @NotEmpty private String name; } @Data public static class ExchangeProperties { @NotEmpty private String name; private String type; } @Data public static class BindingProperties { @NotEmpty private String exchange; @NotEmpty private String queue; @NotEmpty private String routingKey; } } Possu√≠mos 3 maps, estruturas que linkam uma chave √† sua correspondente configura√ß√£o, Queue, Exchange ou Binding Properties. Fazemos o mapeamento padr√£o, usando : @ConfigurationProperties(prefix = \u0026quot;broker\u0026quot;), at√© aqui, sem segredos üôÇ Transformando as propriedades em objetos! A partir de agora, o terceiro passo pode parecer simples, devemos criar beans a partir das propriedades, isso n√£o √© um problema, pelo menos n√£o se quisermos definir os Beans da maneira que fizemos antes, apesar disso, se quisermos definir uma lista de Queues, Exchanges e Bindings, devemos usar a classe Declarables, e prover um bean para ela.\nDeclarables: ‚Äú‚Ä¶Used to declare multiple objects on the broker using a single bean declaration for the collection.‚Äù\n@Bean public Declarables es() { return new Declarables( new DirectExchange(\u0026#34;e2\u0026#34;, false, true), new DirectExchange(\u0026#34;e3\u0026#34;, false, true)); } @Bean public Declarables qs() { return new Declarables( new Queue(\u0026#34;q2\u0026#34;, false, false, true), new Queue(\u0026#34;q3\u0026#34;, false, false, true)); } @Bean public Declarables bs() { return new Declarables( new Binding(\u0026#34;q2\u0026#34;, DestinationType.QUEUE, \u0026#34;e2\u0026#34;, \u0026#34;k2\u0026#34;, null), new Binding(\u0026#34;q3\u0026#34;, DestinationType.QUEUE, \u0026#34;e3\u0026#34;, \u0026#34;k3\u0026#34;, null)); } O exemplo acima, da documenta√ß√£o de refer√™ncia do spring, √© uma boa forma de exemplificar o uso mais simples de Declarables, vamos ver minha implementa√ß√£o em particular, que adiciona declarables de acordo com a BrokerConfigurationProperties\npackage com.kaue.ticketservice.infrastructure.configuration; // ... ommitted /** * This classes creates all queues, exchanges and bindings based on application.yaml when they\u0026#39;re needed (called by a consumer or posted a message into). */ @Configuration @Slf4j @RequiredArgsConstructor public class RabbitMqConfiguration { private final BrokerConfigurationProperties brokerConfig; private final List\u0026lt;Queue\u0026gt; definedQueues = new ArrayList\u0026lt;\u0026gt;(); private final List\u0026lt;Exchange\u0026gt; definedExchanges = new ArrayList\u0026lt;\u0026gt;(); @Bean public Declarables queues() { if (brokerConfig == null || brokerConfig.getQueues() == null) { return new Declarables(); // Return an empty list if no queues are configured } var queueList = brokerConfig.getQueues().values().stream() .filter(Objects::nonNull) .map(queueProperties -\u0026gt; new Queue(queueProperties.getName(), true)) .toList(); definedQueues.addAll(queueList); log.info(\u0026#34;Declared queues\u0026#34;); return new Declarables(queueList); } @Bean public Declarables exchanges() { if (brokerConfig == null || brokerConfig.getExchanges() == null) { return new Declarables(); // Return an empty list if no exchanges are configured } var exchangesList = brokerConfig.getExchanges().values().stream() .filter(Objects::nonNull) .map(exchangeProperties -\u0026gt; new DirectExchange(exchangeProperties.getName())) // todo use correct exchange type .toList(); definedExchanges.addAll(exchangesList); log.info(\u0026#34;Declared exchanges\u0026#34;); return new Declarables(exchangesList); } @Bean public Declarables bindings() { if (brokerConfig == null || brokerConfig.getBindings() == null) { return new Declarables(); } var bindingsList = brokerConfig.getBindings().values().stream() .map(bindingProperties -\u0026gt; { log.info(\u0026#34;Creating binding between exchange {} and queue {} with routing key {}\u0026#34;, bindingProperties.getExchange(), bindingProperties.getQueue(), bindingProperties.getRoutingKey()); Queue queue = findQueueByName(bindingProperties.getQueue()); Exchange exchange = findExchangeByName(bindingProperties.getExchange()); return BindingBuilder.bind(queue) .to(exchange) .with(bindingProperties.getRoutingKey()) .noargs(); }) .toList(); return new Declarables(bindingsList); } private Queue findQueueByName (String queueName){ return definedQueues.stream() .filter(queue -\u0026gt; queueName.equals(queue.getName())) .findFirst() .orElse(null); } private Exchange findExchangeByName (String exchangeName){ return definedExchanges.stream() .filter(exchange -\u0026gt; exchangeName.equals(exchange.getName())) .findFirst() .orElse(null); } } Embora grande, a implementa√ß√£o √© relativamente simples, usamos streams para transformar as propriedades em classes reais e retornamos o Declarable como um Bean, um objeto gerenciado pelo spring.\nPoderes de RabbitListener No Spring, quando um m√©todo anotado como listener joga uma exception, as mensagens podem ser inseridas novamente na fila e reprocessadas, descartadas ou colocadas em uma Dead Letter Queue. Nada √© devolvido ao emissor da mensagem.\nError Handling Na vers√£o 2.0 do Spring AMQP em diante, @RabbitLisetener tem 2 atributos: errorHandler¬†ereturnExceptions, mas eles n√£o s√£o configurados por padr√£o.\nVoc√™ pode usar o errorHandler¬†para prover um Bean de RabbitListenerErrorHandler. Essa interface funcional tem um m√©todo:\n@FunctionalInterface public interface RabbitListenerErrorHandler { Object handleError(Message amqpMessage, org.springframework.messaging.Message\u0026lt;?\u0026gt; message, ListenerExecutionFailedException exception) throws Exception; } Aqui, por exemplo, poder√≠amos dizer que exce√ß√µes de servi√ßo ou fatais jogam exce√ß√µes AmqpRejectAndDontRequeueException, para evitar requeue.\nAs you can see, you have access to the raw message received from the container, the spring-messaging¬†Message\u0026lt;?\u0026gt;¬†object produced by the message converter, and the exception that was thrown by the listener (wrapped in a¬†ListenerExecutionFailedException). The error handler can either return some result (which is sent as the reply) or throw the original or a new exception (which is thrown to the container or returned to the sender, depending on the¬†returnExceptions¬†setting).\nA cita√ß√£o acima comenta uma maneira de enviar exceptions de volta ao sender, se te interessar, pode ver aqui\nRetries! Podemos customizar e modificar configura√ß√µes de retry indicadas dentro do nosso projeto, para isso usaremos o projeto spring-retry, vamos ver uma configura√ß√£o simples no Bean do RabbitTemplate:\n@Bean public RabbitTemplate rabbitTemplate() { RabbitTemplate template = new RabbitTemplate(connectionFactory()); RetryTemplate retryTemplate = RetryTemplate.builder() .maxAttempts(3) .fixedBackoff(1000) .retryOn(RemoteAccessException.class) .build(); retryTemplate.execute(ctx -\u0026gt; { // ... do something }); template.setRetryTemplate(retryTemplate); return template; } Para mais informa√ß√µes, veja o [spring-retry](https://github.com/spring-projects/spring-retry#using-retrytemplate)\nDead Letters When a listener throws an exception, it is wrapped in a¬†ListenerExecutionFailedException. Normally the message is rejected and requeued by the broker. Setting¬†defaultRequeueRejected¬†to¬†false¬†causes messages to be discarded (or routed to a dead letter exchange).\nVamos tentar seguir o que o coment√°rio acima da documenta√ß√£o do spring diz:\nspring: rabbitmq : ... adresses e outras configs listener: simple: default-requeue-rejected: false Depois dessa configura√ß√£o, as mensagens quando possuem um erro s√£o DELETADAS, desabilitando os retries. Isso provavelmente n√£o √© o que queremos, por isso, vamos estudar as DLQ‚Äôs.\nDead Letter Queues (DLQ) s√£o filas que possuem mensagens que tiveram sua execu√ß√£o falhada em algum momento, o comportamento das DLQ‚Äôs pode ser configurado no pr√≥prio broker.\nDead Letter Queues s√£o √∫teis em sistemas mais cr√≠ticos, onde necessitamos que um job rode de qualquer forma, onde podemos jogar mensagens de DLQ‚Äôs na exchange padr√£o novamente, ou pelo menos entendermos o porqu√™ daquilo n√£o ter sido executado, essas filas possuem diversas fun√ß√µes.\nA maneira de definir dead letters √© algo explicado dentro do protocolo AMQP, podemos apenas seguir essa configura√ß√£o:\n@Bean Queue messagesQueue() { return QueueBuilder.durable(\u0026#34;queue-name\u0026#34;) .withArgument(\u0026#34;x-dead-letter-exchange\u0026#34;, \u0026#34;nome-exchange.dlx\u0026#34;) .withArgument(\u0026#34;x-dead-letter-routing-key\u0026#34;, \u0026#34;queue-name.dlq\u0026#34;) // nao precisa ser o nome da queue, mas √© comum para direct .build(); } @Bean Queue deadLetterQueue() { return QueueBuilder.durable(\u0026#34;queue-name.dlq\u0026#34;).build(); } No fim das contas, uma dead letter queue √© uma queue normal, e uma dead letter exchange tamb√©m, portanto, se uma mensagem chegar na DLX (Dead Letter Exchange) e n√£o tiver uma routing key correta, ela n√£o chegar√° na fila, tudo normal por aqui.\nObserva√ß√µes Existem diversas maneiras de trabalhar com rabbitMQ, e uma infinidade de propriedades e configura√ß√µes n√£o mostradas aqui, como por exemplo: Feedback s√≠ncrono de exchanges e filas, Consumers Ass√≠ncronos, Containers Diferentes, propriedades de requeue, monitoramento de consumers, etc. Se algo fizer sentido para seu contexto, pode buscar no material de refer√™ncia do Spring üôÇ\nMais sobre DLQ: https://www.youtube.com/watch?v=GgIJWxk_-jM\nMais sobre exception handling: https://www.baeldung.com/spring-amqp-error-handling\nRefer√™ncias https://docs.spring.io/spring-amqp/reference/html/#template-retry\nhttps://github.com/spring-projects/spring-retry\nhttps://www.baeldung.com/spring-amqp-error-handling\n","permalink":"https://kaue.cat/posts/java_rabbitmq_parte2/","summary":"Texto necessita outra revis√£o.\nAprofundando Nota: Nesse momento, entraremos um pouco mais em detalhes sobre como o protocolo AMQP funciona, escrevi um ‚Äúguia‚Äù bem b√°sico sobre propriedades do protocolo, se quiser conferir, pode ver aqui :)\nmensageria.pdf\nOu nesse link\nContexto O Spring AMQP consiste em dois m√≥dulos principais: spring-amqp e spring-rabbit. O ‚Äòspring-amqp‚Äô cont√©m o pacote org.springframework.amqp.core, que trata das principais abstra√ß√µes definidas no protocolo AMQP (RabbitMQ √© um broker, que implementa esse protocolo), esse pacote n√£o se baseia em nenhuma biblioteca de clientes nem implementa√ß√£o de broker.","title":"RabbitMQ com Java e Spring : Entendendo de verdade e com um toque de eleg√¢ncia (parte 2)"},{"content":"Bem vindo(a)! ao meu post de RabbitMQ com JAVA. Esse post n√£o tem como objetivo te ensinar RabbitMQ em detalhes ou at√© o protocolo AMQP. Na realidade, possuo um outro artigo onde comento sobre algumas peculiaridades do protocolo AMQP nesse link. De qualquer forma, na parte dois vou explicar por cima o que s√£o filas, exchanges, bindings e seus tipos.\nA ideia hoje √© fazermos algo realmente simples e m√£o na massa:\nConfigurarmos nosso rabbitMQ no docker com docker-compose Configurarmos um publisher, que envia mensagens de texto para as filas do RabbitMQ Configurarmos um consumer, que recebe essas mensagens e as trata. Configura√ß√£o B√°sica Antes de tudo, precisamos subir um servidor do Rabbit em nossa m√°quina local, a melhor maneira, na minha vis√£o, de fazer isso, √© usando docker, curto mais usar compose pra essas tarefas, ent√£o:\nversion: \u0026#39;3.1\u0026#39; services: rabbitmq: image: rabbitmq:management container_name: \u0026#39;rabbitmq\u0026#39; ports: - \u0026#34;5672:5672\u0026#34; - \u0026#34;15672:15672\u0026#34; Depois disso, voc√™ pode rodar docker-compose up e ser feliz. (Voc√™ vai precisar ter docker \u0026amp; docker compose instalados).] Verifique sua instala√ß√£o em localhost:15672\nDefinindo propriedades para a fila Gosto de organizar propriedades em um ConfigurationProperty (principalmente quando elas podem crescer, o que √© o caso), que busca informa√ß√µes do application.properties ou application.yaml\nNesse caso em espec√≠fico, vou fazer algo bem simples.\npackage com.kaue.ticketservice.infrastructure.properties; import lombok.Getter; import lombok.Setter; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @ConfigurationProperties(\u0026#34;broker.queue.ticket\u0026#34;) @Component @Getter @Setter public class TicketQueueProperties { private String name; } broker: queue: ticket: name: default.ticket Poder√≠amos ter m√∫ltiplas entries, e cada queue poderia ter outras propriedades al√©m de name (faremos isso na parte 2 üòà):\nbroker: queues: ticket: name: default.ticket durable: true autoDelete: false exclusive: false otherQueue: name: other.queue durable: false autoDelete: true exclusive: true Se quiser adicionar mais filas, definiria uma classe com as configura√ß√µes para cada fila e definiria o ConfigurationProperties mais ou menos assim:\n@Component @ConfigurationProperties(prefix = \u0026#34;broker.queues\u0026#34;) public class QueueProperties { private Map\u0026lt;String, QueueConfig\u0026gt; queue; ... } Mas a princ√≠pio, vamos atuar s√≥ com ticket e name, do jeito que passei anteriormente.\nDefinindo a conex√£o com o Rabbit No seu application yaml ou properties, adicione:\nspring: rabbitmq: addresses: ${amqpURL:amqp://guest:guest@localhost} Nesse caso, se a vari√°vel de ambiente amqpURL existir, ela ser√° utilizada, caso contr√°rio, ser√° utilizado o padr√£o guest:guest, que funcionar√° perfeitamente com o docker compose apresentado anteriormente, ent√£o n√£o precisa mexer se n√£o for usar rabbit cloud ou tiver configurados as credenciais :)\nAdicionando a depend√™ncia Spring-Amqp O RabbitMQ √© uma ferramenta que implementa regras do protocolo AMQP, portanto, usaremos o Spring AMQP como depend√™ncia para configurar o nosso Rabbit!\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.amqp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-rabbit-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Criando uma Configura√ß√£o B√°sica para Beans do Rabbit O Spring boot trabalha com beans, que s√£o basicamente objetos os quais ele instancia e gera, nesse caso, vamos prover configura√ß√µes de beans do rabbit para o SPRING tomar conta, ou seja, criando um bean do tipo Queue, uma fila ser√° criada automaticamente\n@Configuration @Slf4j @RequiredArgsConstructor public class RabbitMqConfiguration { private final TicketQueueProperties ticketQueueProperties; @Bean public Queue queue(){ log.info(\u0026#34;Looking for queue: {}\u0026#34;, ticketQueueProperties.getName()); return new Queue(ticketQueueProperties.getName(), true); } } ‚ö†Ô∏è Para evitar confus√£o:\nEstou usando RequiredArgsConstructor com um campo final: TicketQueueProperties, RequiredArgsConstructor faz com que exista um construtor que contenha todos os campos final nele, portanto, como √© o √∫nico construtor, o Spring Boot o usar√° e automaticamente ir√° inserir a depend√™ncia TicketQueueProperties correta, o resultado √© o mesmo que o @Autowired, mas a inje√ß√£o via construtor √© mais recomendada que o uso de Autowired ‚òùÔ∏èü§ì! Aqui, podemos definir diversos beans, configura√ß√µes de outras filas e exchanges, et cetera, um m√©todo para cada Bean;\nDefinindo o primeiro Publisher Aqui vamos usar a composi√ß√£o e injetar na nossa classe uma inst√¢ncia de RabbitTemplate, depois, usar o m√©todo publish. Nesse caso, vamos utilizar a exchange padr√£o, e o nome da fila ser√° o primeiro par√¢metro, sendo o segundo a mensagem em si.\n// ommitted import lombok.AllArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.core.RabbitTemplate; @Slf4j @RequiredArgsConstructor public class RabbitTicketPublisher implements MessagePublisher { private final TicketQueueProperties ticketQueueProperties; private final RabbitTemplate rabbitTemplate; @Override public void publish(Text text) { log.info(\u0026#34;Notifying queue: {} of text{}\u0026#34;, ticketQueueProperties.getName(), text); rabbitTemplate.convertAndSend(ticketQueueProperties.getName(),text); } } MessagePublisher√© uma interface pr√≥pria que defini em meu dom√≠nio, para desacoplar a camada de infraestrutura, deixei apenas um m√©todo publish, onde enviamos os eventos e/ ou mensagens para algum lugar, as implenta√ß√µes sabem que lugar √© esse.\nDefinindo a inje√ß√£o de depend√™ncias. De maneira similar ao que j√° vi em C#, optei por cuidar da DI mais manualmente:\n// ommitted @Configuration @AllArgsConstructor public class DIConfiguration { private TicketRepository ticketRepository; private TicketQueueProperties ticketQueueProperties; private RabbitTemplate rabbitTemplate; @Bean public TicketService ticketService() { return new TicketService(ticketRepository, ticketsMessagePublisher()); } @Bean public MessagePublisher ticketsMessagePublisher(){ return new RabbitTicketPublisher(ticketQueueProperties, rabbitTemplate); } } Poder√≠amos tamb√©m criar uma interface para cada publisher, mas n√£o sei o quanto gostaria dessa abordagem, talvez haja algo melhor, mas para mim, cuidar da desambigua√ß√£o de Beans dessa forma n√£o est√° sendo um problema (por hora)\nO Primeiro Consumer: Aqui, vamos definir que estamos ouvindo a fila de nome X pela annotation @RabbitListener.\n@Slf4j @Component public class TicketConsumer { @RabbitListener(queues = \u0026#34;${broker.queue.ticket.name}\u0026#34;) public void listenEmailQueue(@Payload String text){ log.info(\u0026#34;Received: {}\u0026#34;, text); } } Aqui estou usando o @Value ao inv√©s do configuration properties para exemplificar, sei que diversas pessoas preferem essa abordagem!\nResultado Parte 2 : O que veremos O que s√£o filas, exchanges e bindings Defini√ß√£o autom√°tica elegante de filas, exchanges e bindings via application yaml usando declarables Enviando objetos! Outros super poderes do protocolo (introdu√ß√£o) : Retries, DLQ, DLXZ Refer√™ncias https://docs.spring.io/spring-amqp/reference/html/#template-retry\n","permalink":"https://kaue.cat/posts/java_rabbitmq_parte1/","summary":"Bem vindo(a)! ao meu post de RabbitMQ com JAVA. Esse post n√£o tem como objetivo te ensinar RabbitMQ em detalhes ou at√© o protocolo AMQP. Na realidade, possuo um outro artigo onde comento sobre algumas peculiaridades do protocolo AMQP nesse link. De qualquer forma, na parte dois vou explicar por cima o que s√£o filas, exchanges, bindings e seus tipos.\nA ideia hoje √© fazermos algo realmente simples e m√£o na massa:","title":"RabbitMQ com Java e Spring : Come√ßando (pt. 1)"},{"content":"Map, Filter, Reduce Vamos come√ßar com um exemplo?\n* Given a list of people * We need to compute the average of the age of those people * For the people older than 20 Nesse caso, √© meio claro, come√ßamos com um objeto pessoa, mas trabalharemos / transformaremos o dado de uma maneira que consigamos a idade (map). O map pega um objeto, e mapeia para outro, geralmente de tipo diferente Com isso, vamos filtrar o dado age, para que ele s√≥ compute a m√©dia de maiores de 20 anos. Isso √© um filter. O filter literalmente filtra os dados, n√£o os transforma (diferente de map) e decide se deve manter ou n√£o o dado. 2.1. Filters em c√≥digo recebem uma predicate como par√¢metro, ela representa uma fun√ß√£o que recebe um argumento e retorna um valor booleano. Por fim, vamos calcular a m√©dia desse dado, j√° transformado de pessoas e filtado para que a idade seja \u0026gt;20. Essa opera√ß√£o avg √© o reduce, nesse caso, vamos pensar nela a princ√≠pio como uma agrega√ß√£o (tipo min,max,count, etc). Opera√ß√£o Comportamento Map Transforma o dado, mudando seu tipo. N√£o muda o n√∫mero de elementos. Filter N√£o transforma o dado, reduz (ou mant√©m igual) o n√∫mero de elementos Reduce Combina os elementos em um resultado √∫nico. √â uma opera√ß√£o terminal que produz um √∫nico valor com base em uma opera√ß√£o de redu√ß√£o, como soma, m√©dia ou m√°ximo. Por que usar Streams? List\u0026lt;Person\u0026gt; people = ...; int sum = 0; int count = 0; for (Person person: people) { if (person.getAge() \u0026gt; 20) { count++; sum += person.getAge(); } } double average = 0d; if(count \u0026gt; 0) { average = sum / count; } No exemplo acima, temos um c√≥digo que descreve com detalhes o que deve ser feito para chegarmos em um resultado (o resultado do exemplo apresentado), e se mudarmos o algoritmo, precisamos mudar o c√≥digo, mesmo que o algoritmo seja o mesmo. N√£o necessariamente precisa ser assim, em SQL, por exemplo, escrever√≠amos:\nSelect AVG(age) from People Where People.age\u0026gt;20 Note que no exemplo acima, descrevemos ao c√≥digo o que queremos que seja feito, as premissas, descrevemos o resultado, e n√£o como o resultado deve ser computado.\nCollection X Streams Tudo certo, se o c√≥digo faz parte de uma lista ou qualquer cole√ß√£o, podemos tentar implementar assim:\nList\u0026lt;Person\u0026gt; people = ...; double average = people.map(person -\u0026gt; person.getAge()) .filter(age ‚Äî \u0026gt; age \u0026gt; 20) .average(); ERRADO! A API de collections n√£o prov√™ esse tipo de opera√ß√µes, o c√≥digo acima n√£o compila üòÑ!\nMas por que a API de Collections e Streams s√£o separadas? Imagine que essas opera√ß√µes s√£o feitas em uma lista de 1.000.000 de pessoas! Portanto, ap√≥s o primeiro map, voc√™ teria uma Lista com 1.000.000 de inteiros de idade (porque o map n√£o reduziria o tamanho em si), acho que j√° deu para perceber que duplicar a collection vai ser altamente custoso para o processador e para a mem√≥ria\nMas como isso funciona? Quando usamos pessoas.stream(), retornamos uma Stream\u0026lt;Pessoa\u0026gt;. Por defini√ß√£o, um objeto de stream n√£o carrega dados, √© gr√°tis cria-lo.\nA collection is an in-memory data structure to hold values and before we start using collection, all the values should have been populated. Whereas a java Stream is a data structure that is computed on-demand. Java Stream doesn‚Äôt store data, it operates on the source data structure (collection and array) and produce pipelined data that we can use and perform specific operations.\nhttps://www.digitalocean.com/community/tutorials/java-8-stream\nOpera√ß√µes Intermedi√°rias X Finais Streams atuam sobre cole√ß√µes para realizar map / filter / reduce, opera√ß√µes intermedi√°rias s√£o opera√ß√µes sobre streams que retornam streams ( Stream\u0026lt;T\u0026gt; map() ‚Üí M√©todo de stream, retorna stream).\nOpera√ß√µes finais s√£o opera√ß√µes que retornam a cole√ß√£o de novo, depois do processamento / pipelining acabar toList() √© um exemplo\nE como ficaria o c√≥digo Aqui est√° um exemplo de como ficaria o c√≥digo.\nList\u0026lt;Pessoa\u0026gt; pessoas = new ArrayList\u0026lt;\u0026gt;(); pessoas.stream() .map(...) .filter(...) .average(); Stream\u0026lt;String\u0026gt; personNames = personStream.map(Person::getName); Stream\u0026lt;String\u0026gt; emptyNames = personNames.filter( name -\u0026gt; name.isEmpty()) Stream\u0026lt;String\u0026gt; notEmptyNames = personNames.filter( name -\u0026gt; !name.isEmpty()) Esse c√≥digo quebrar√°, tendo em vista que estamos processando a mesma stream personNames duas vezes!\nStream\u0026lt;String\u0026gt; personNames = personStream.map(Person::getName); Stream\u0026lt;Integer\u0026gt; personAges = personStream.map(Person::getAge); Nesse caso, estamos aplicando o map para criar duas streams diferentes, n√£o quebrar√° o c√≥digo.\nStream\u0026lt;String\u0026gt; emptyNames = personStream.map(Person::getName).filter(name -\u0026gt; name.isEmpty()); Stream\u0026lt;String\u0026gt; notEmptyNames = personStream.map(Person::getName).filter(name -\u0026gt; !name.isEmpty()); Esse c√≥digo, processando duas streams diferentes tamb√©m funcionar√°\nPor favor, n√£o crie vari√°veis para trabalhar com streams, fiz por did√°tica\nFlatMapping Flatmapping funciona para lidar com rela√ß√µes 1:N\nExemplo: Cidades, onde temos v√°rias pessoas por cidade.\nSuponha que queremos pegar todas as pessoas, independente de suas cidades. Nesse caso, nos preocupamos com a entidade relacionada, n√£o com as cidades em si**. O flatmap faz isso, pega uma entidade Cidade e retorna para n√≥s uma Stream\u0026lt;Pessoas\u0026gt;.**\nList\u0026lt;City\u0026gt; cities = ...; Function\u0026lt;City, Stream\u0026lt;Person\u0026gt;\u0026gt; flatMapper = city -\u0026gt; city.getPeople().stream(); long count = cities.stream() .flatMap(flatMapper) /*poder√≠amos colocar city -\u0026gt; city.getPeople().stream() direto*/ .count() List\u0026lt;String\u0026gt; words \u0026#34;Gomu\u0026#34;,\u0026#34;Gomu\u0026#34;, \u0026#34;No\u0026#34;, \u0026#34;Mi\u0026#34;); Stream\u0026lt;String\u0026gt; streamStream = words.stream() .map(w -\u0026gt; w.split(\u0026#34;\u0026#34;)) // Stream\u0026lt;String[]\u0026gt; .flatMap(Arrays::stream) ; // Stream\u0026lt;String\u0026gt; O flatmap funciona nesse caso, pois ao aplicar flatMap(Arrays::stream), voc√™ est√° dizendo ao Java para pegar cada array de caracteres da Stream\u0026lt;String[]\u0026gt; e transform√°-lo em uma stream de strings (Stream\u0026lt;String\u0026gt;) usando o m√©todo est√°tico Arrays.stream().\nStreams a partir de RegEx String sentence = \u0026#34;the quick brown fox jumps over the lazy dog\u0026#34;; String[] words = sentence. split( Stream\u0026lt;String\u0026gt; wordsStream = Arrays.stream(words); Ion count = wordsStream.count() Ao fazermos dessa forma, criamos um array intermedi√°rio, perdemos o prop√≥sito de streams.\nPodemos fazer:\nPattern pattern = Pattern.compile(\u0026#34; \u0026#34;); long count = pattern.sp1itAsStream(sentence) . count(); Streams de outro tipo Em java, existem interfaces de stream feitas para manipular certos primitivos mais adequadamente, um exemplo disso √© a IntStream\nIntStream IntStream tende a ser mais eficiente em termos de espa√ßo e desempenho quando voc√™ est√° trabalhando com valores inteiros primitivos, uma vez que evita a cria√ß√£o de objetos Integer.\nA IntStream oferece opera√ß√µes especializadas para trabalhar com valores inteiros, como sum(), average(), range(), rangeClosed(), etc. Uma Stream\u0026lt;Integer\u0026gt; fornece opera√ß√µes de stream gen√©ricas aplic√°veis a objetos, mas √© menos eficiente quando se trata de c√°lculos com tipos primitivos.\nRefactoring ‚Üí Exemplo com m√∫ltiplas tarefas ao mesmo tempo Streams n√£o s√£o uma boa para realizarem m√∫ltiplas tarefas simultaneamente, portanto se temos um for loop que agrega valores √† 3 vari√°veis diferentes, precisamos dividir em 3 for‚Äôs (repetidos) e trocar cada um deles por uma stream. Claro, isso diminui muito a performance, mas em um for com poucos elementos a serem iterados, ser√° basicamente impercept√≠vel.\npublic String statement() { double totalAmount = rentals.stream() .mapToDoub1e(this::computeRenta1Amount) .sum(); int frequentRenterPoints = rentals.stream() .mapToInt (this::getFrequentRenterPoints) .sum(); String statement = composeHeader(); statement += rentals.stream() .map(this::computeStatementLine) .collect(Collectors.joining()); } Redu√ß√µes Antes, ouvimos que redu√ß√£o era algo similar a uma agrega√ß√£o do SQL, vamos continuar com isso em mente, mas como isso funciona?\nVamos ter como exemplo a soma, a soma √© uma uma implementa√ß√£o de BinaryOperator\u0026lt;Integer\u0026gt;, que pega dois elementos e os soma ( sum = (i1,i2) -\u0026gt; i1+i2;). Isso acontece com dois elementos por vez, associando os valores e depois somando com o outro.\nRedu√ß√µes de uma stream vazia Mas e qual a redu√ß√£o de uma Stream vazia? A redu√ß√£o de uma Stream vazia √© o seu elemento identidade (identity), um elemento identidade √© um valor pr√©-definido que atua como ponto de partida em uma opera√ß√£o de redu√ß√£o. Em contextos de programa√ß√£o funcional, quando n√£o h√° elementos para combinar na Stream, a opera√ß√£o de redu√ß√£o retorna o elemento identidade como resultado, garantindo que a opera√ß√£o seja definida e n√£o cause exce√ß√µes em casos de Stream vazia. Isso √© especialmente √∫til para lidar com casos em que n√£o h√° dados dispon√≠veis para a opera√ß√£o espec√≠fica, permitindo que o c√≥digo se comporte de maneira previs√≠vel e segura.\nPor exemplo, o identity de uma soma √© 0, tendo em vista que o 0 n√£o impactar√° no valor final, para m√∫ltiplica√ß√£o, um.\nMax, Min, Avg? O \u0026ldquo;identity element\u0026rdquo; ou valor inicial para as opera√ß√µes de max, min e average em Streams do Java √© um pouco diferente porque essas opera√ß√µes retornam um Optional, que pode ser vazio (caso a Stream esteja vazia) ou conter um valor, portanto, essas opera√ß√µes n√£o tem valores identity.\nPortanto, para acessar max, min e avg, voc√™ deve fazer algo do tipo:\nOptional\u0026lt;Integer\u0026gt; max = numbers.stream().max(Integer::compareTo); Optional\u0026lt;Integer\u0026gt; min = numbers.stream().min(Integer::compareTo); OptionalDouble average = numbers.stream().mapToDouble(Integer::doubleValue).average(); System.out.println(\u0026#34;Max: \u0026#34; + max.orElse(null)); System.out.println(\u0026#34;Min: \u0026#34; + min.orElse(null)); System.out.println(\u0026#34;Average: \u0026#34; + average.orElse(Double.NaN)); Como podemos escrever nossas reductions? Talvez voc√™ esteja se perguntando o porqu√™ de entendermos tamb√©m a fundamenta√ß√£o de identity elements, se ainda n√£o ficou claro, vai ficar agora:\nA opera√ß√£o reduce em Streams do Java tem dois par√¢metros principais:\nO valor inicial (identity element): J√° foi explicado Uma fun√ß√£o de acumula√ß√£o (accumulator function): Esta fun√ß√£o √© usada para combinar os elementos da Stream em um √∫nico resultado. A fun√ß√£o deve ser uma express√£o lambda ou um m√©todo de refer√™ncia que aceite dois argumentos e retorne um resultado. Em soma, seria (a, b) -\u0026gt; a + b Se sua stream n√£o possuir um identity, voc√™ pode usar uma outra sobrecarga do m√©todo que n√£o recebe o identity, mas retorna um Optional. Use-o somente se n√£o possuir o identity‚Ä¶\nRedu√ß√µes em um container mut√°vel Redu√ß√µes em um container mut√°vel referem-se √† aplica√ß√£o de opera√ß√µes de redu√ß√£o, como soma, multiplica√ß√£o, m√©dia, entre outras, a elementos armazenados em um cont√™iner que pode ser alterado durante o processo de redu√ß√£o. Um \u0026ldquo;container\u0026rdquo; neste contexto pode ser definido como uma estrutura de dados flex√≠vel que permite armazenar e modificar elementos de forma din√¢mica (Lists, Maps, etc.). Portanto, podemos simplificar redu√ß√µes em containers mut√°veis como redu√ß√µes em cole√ß√µes.\nAo chamar .stream() em uma lista, voc√™ est√° criando uma Stream dos elementos contidos na lista. A Stream √© uma sequ√™ncia de elementos que pode ser processada de maneira funcional, mas n√£o modifica a lista original. Quando voc√™ chama .max(), por exemplo, est√° solicitando o elemento m√°ximo com base em algum crit√©rio da lista, mas a lista em si permanece a mesma.\nColetores! List\u0026lt;Person\u0026gt; pessoasDaBaixada = new ArrayList() ; pessoasDaBaixada.stream() .filter(p -\u0026gt; p.getDDD().equals(\u0026#34;013\u0026#34;)) .forEach(p -\u0026gt; pessoasDaBaixada.add(p)); Mas esse exemplo acima n√£o √© muito diferente do que j√° vimos, por que estamos focando nesse tipo de redu√ß√£o?\nPara filtrar e coletar elementos em uma nova lista usando a API de Streams do Java, voc√™ deve usar um coletor adequado, como Collectors.toList()\nOs coletores permitem que voc√™ capture os resultados das opera√ß√µes de redu√ß√£o em cole√ß√µes ou outros tipos de dados concretos. Em outras palavras, eles transformam os elementos processados em uma Stream em uma cole√ß√£o real que pode ser usada e manipulada posteriormente.\nList\u0026lt;Person\u0026gt; pessoasDaBaixada = new ArrayList\u0026lt;\u0026gt;(); // Supondo que o n√∫mero de DDD seja uma String List\u0026lt;Person\u0026gt; pessoasComDDD13 = pessoasDaBaixada.stream() .filter(p -\u0026gt; \u0026#34;13\u0026#34;.equals(p.getDDD())) .collect(Collectors.toList()); //.toList() retornar√° uma lista imut√°vel! ‚ÄùO novo m√©todo Stream.toList() n√£o produz nem uma lista n√£o modific√°vel nem √© um atalho para collect(toUnmodifiableList()), porque toUnmodifiableList() n√£o aceita valores nulos. A implementa√ß√£o de Stream.toList() n√£o √© limitada pela interface Collector; portanto, Stream.toList() aloca menos mem√≥ria. Isso a torna ideal para uso quando o tamanho da stream √© conhecida antecipadamente.‚Äù Link para coment√°rio no stackoverflow\nExemplos de Outros Coletores Collectors.toSet(): Cria um conjunto a partir dos elementos da Stream, removendo duplicatas. Collectors.toMap(keyMapper, valueMapper): Cria um map a partir dos elementos da Stream, usando fun√ß√µes de mapeamento para extrair chaves e valores. Collectors.groupingBy(classifier): Agrupa elementos da Stream com base em um crit√©rio definido pela fun√ß√£o de classifica√ß√£o. Collectors.joining(delimiter): Concatena os elementos da Stream em uma √∫nica String usando um delimitador. Collectors.summingInt() ou Collectors.summingLong(): Calcula a soma dos valores inteiros ou longos de elementos da Stream. Exemplos de uso: Map\u0026lt;Integer, List\u0026lt;Person\u0026gt;\u0026gt; pessoasPorIdade = pessoas.stream() .collect(Collectors.groupingBy(Person::getIdade)); List\u0026lt;Person\u0026gt; pessoas = Arrays.asList( new Person(\u0026#34;Jorge\u0026#34;, 25), new Person(\u0026#34;Ben\u0026#34;, 30), new Person(\u0026#34;Jor\u0026#34;, 35) ); Map\u0026lt;String, Integer\u0026gt; mapNomeIdade = pessoas.stream() .collect(Collectors.toMap(Person::getNome, Person::getIdade)); // ex1 Map\u0026lt;Integer, List\u0026lt;Person\u0026gt;\u0026gt; pessoasPorIdade = new HashMap\u0026lt;\u0026gt;(); pessoas.forEach(person -\u0026gt; { Integer idade = person.getIdade(); List\u0026lt;Person\u0026gt; pessoasComIdade = pessoasPorIdade.get(idade); if (pessoasComIdade == null) { pessoasComIdade = new ArrayList\u0026lt;\u0026gt;(); pessoasPorIdade.put(idade, pessoasComIdade); } pessoasComIdade.add(person); }); // ex2 Map\u0026lt;String, Integer\u0026gt; mapNomeIdade = new HashMap\u0026lt;\u0026gt;(); pessoas.stream().forEach(person -\u0026gt; mapNomeIdade.put(person.getNome(), person.getIdade())); Pincelando: Streams Paralelas √Ä medida que exploramos as reductions e opera√ß√µes terminais, √© crucial considerar o potencial das streams paralelas em Java, mas o que s√£o? ü§î\nStreams paralelas oferecem a capacidade de executar opera√ß√µes em paralelo, aproveitando m√∫ltiplos n√∫cleos da CPU, o que melhora muito o desempenho da stream.\nApesar disso, vale dizer que opera√ß√µes em paralelo nem sempre podem ser consideradas em uma stream, suponha que voc√™ esteja calculando uma m√©dia com uma reduction, para calcularmos a m√©dia, precisamos primeiro somar os elementos, e ent√£o dividirmos, se somarmos e depois dividirmos partes distintas, isso trar√° um resultado incorreto, isso significa que a m√©dia √© uma opera√ß√£o n√£o associativa!\nOpera√ß√µes Associativas S√£o opera√ß√µes em que a ordem em que os elementos s√£o combinados n√£o afeta o resultado. Exemplos comuns de opera√ß√µes associativas incluem soma e multiplica√ß√£o.\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // C√°lculo da soma em uma stream paralela int sum = numbers.parallelStream().reduce(0, Integer::sum); Esse par√°grafo tem como objetivo apenas introduzir e notificar a exist√™ncia de streams paralelas, procure saber mais sobre elas! Opera√ß√µes N√£o-Associativas S√£o o oposto!\nConclus√£o e Agradecimento Obrigado pela leitura, espero que tenha sido produtiva e que voc√™ tenha todo o conhecimento necess√°rio para conseguir dar seus pr√≥prios passos e construir streams funcionais e avan√ßadas, caso necess√°rio.\nRefer√™ncias https://app.pluralsight.com/library/courses/692a1310-42db-4f3c-a33b-208a55b7bd84/table-of-contents\nhttps://www.digitalocean.com/community/tutorials/java-8-stream\nMaratona Java Virado no Jiraya\nhttps://acervolima.com/coletores-java/\n","permalink":"https://kaue.cat/posts/streams/","summary":"Map, Filter, Reduce Vamos come√ßar com um exemplo?\n* Given a list of people * We need to compute the average of the age of those people * For the people older than 20 Nesse caso, √© meio claro, come√ßamos com um objeto pessoa, mas trabalharemos / transformaremos o dado de uma maneira que consigamos a idade (map). O map pega um objeto, e mapeia para outro, geralmente de tipo diferente Com isso, vamos filtrar o dado age, para que ele s√≥ compute a m√©dia de maiores de 20 anos.","title":"Streams em JAVA: Tudo que voc√™ precisa saber"},{"content":"Aviso: Esse post ainda passar√° por uma revis√£o!\nTestando Reposit√≥rios (De verdade!) Podemos testar reposit√≥rios de alguns jeitos, uma das maneiras √© utilizar um banco em mem√≥ria. Para SQL, h2 √© f√°cil e r√°pido, podemos fazer as configs no banco usando um application-properties para os testes e validar tudo bonitinho normalmente üôÇ. Outra alternativa seria utilizar TestContainers Conseguindo testar e subir reposit√≥rios e message brokers reais, conseguimos fazer testes de integra√ß√£o! TestContainers \u0026ldquo;Testcontainers √© um framework de c√≥digo aberto para fornecer inst√¢ncias descart√°veis e leves de bancos de dados, message brokers, browsers ou praticamente qualquer coisa que possa ser executada em um container Docker.‚Äù\nAdicionando depend√™ncias: \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mongodb\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;testcontainers\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; A primeira depend√™ncia ir√° variar de acordo com suas necessidades, dependendo do que precisar subir, no meu caso, s√≥ o MongoDB, se precisasse de RabbitMQ, tamb√©m o adicionaria, por exemplo.\nNo c√≥digo, √© simples, depois de termos as depend√™ncias configuradas corretamente, podemos adicionar e instanciar os containers passando a tag da imagem docker como par√¢metro, para o mongodb, mongo:latest.\nAdicionar o Container: private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026quot;mongo:latest\u0026quot;); Adicionar @Container √† vari√°vel do container Se estiver usando Spring 3.1+, adicionar a anota√ß√£o @ServiceConnection tamb√©m. Essa configura√ß√£o pega os dados do container criado e automaticamente sobrescreve com essas informa√ß√µes o container que seria usado originalmente Caso contr√°rio, precisamos fazer isso na m√£o: crie um m√©todo que recebe como par√¢metro DynamicPropertyRegistry Anote esse m√©todo com @DynamicPropertySource Altere as propriedades que estavam configuradas anteriormente usando registry.add(\u0026quot;propriedade\u0026quot;, valor) @Container private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026#34;mongo:latest\u0026#34;); @Container private static final RabbitMQContainer RABBIT_MQ_CONTAINER = new RabbitMQContainer(\u0026#34;rabbitmq:management\u0026#34;); @DynamicPropertySource static void mongoDbProperties(DynamicPropertyRegistry registry) { MONGO_DB_CONTAINER.start(); registry.add(\u0026#34;spring.data.mongodb.uri\u0026#34;, MONGO_DB_CONTAINER::getReplicaSetUrl); registry.add(\u0026#34;spring.rabbitmq.addresses\u0026#34;,() -\u0026gt; \u0026#34;amqp://guest:guest@localhost:\u0026#34;+RABBIT_MQ_CONTAINER.getAmqpPort()); } A partir da√≠, siga sua vida com seu Rabbit, Mongo ou qualquer outra inst√¢ncia descart√°vel.\n@Testcontainers @SpringBootTest public class TicketRepositoryJPATest { @Autowired private TicketRepositoryJPA ticketRepository; @Autowired private TicketFactory ticketFactory; @Container // @ServiceConnection spring 3.1+ - makes DynamicPropertySource unnecessary private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026#34;mongo:latest\u0026#34;); @DynamicPropertySource static void mongoDbProperties(DynamicPropertyRegistry registry) { MONGO_DB_CONTAINER.start(); registry.add(\u0026#34;spring.data.mongodb.uri\u0026#34;, MONGO_DB_CONTAINER::getReplicaSetUrl); } @Test @Order(0) void InsertTicket_Success(){ Ticket t = ticketFactory.createTicket(\u0026#34;validemail@gmail.com\u0026#34;, \u0026#34;I have a problem\u0026#34;, \u0026#34;hellp\u0026#34;); ticketRepository.insert(t); } @Test @Order(1) void FindAll_findsOne(){ var tickets = ticketRepository.findAll(); assertEquals(tickets.size(), 1); } } No caso acima fa√ßo um teste simples de reposit√≥rio onde garanto que alguns m√©todos est√£o sendo executados corretamente, mas poderia por exemplo, fazer um teste de integra√ß√£o que garante service + reposit√≥rio, ou at√© mesmo um teste de integra√ß√£o completo com TestRestTemplate.\nImportanto classes de declara√ß√£o de Testcontainer Um padr√£o comum ao usar o Testcontainers √© declarar inst√¢ncias de **Container**como campos est√°ticos. Frequentemente, esses campos s√£o definidos diretamente na classe de teste. Eles tamb√©m podem ser declarados em uma classe pai ou em uma interface que o teste implementa:\npublic interface MyContainers { @Container MongoDBContainer mongoContainer = new MongoDBContainer(\u0026#34;mongo:5.0\u0026#34;); @Container Neo4jContainer\u0026lt;?\u0026gt; neo4jContainer = new Neo4jContainer\u0026lt;\u0026gt;(\u0026#34;neo4j:5\u0026#34;); } Para mais discuss√µes, n√£o focando s√≥ no setup, mas em configura√ß√µes diferentes, pr√≥s e contras, recomendo esse post: https://maciejwalkowiak.com/blog/testcontainers-spring-boot-setup/\nOutra ideia interessante √© que podemos configurar TestContainers para aplica√ß√µes rodando em desenvolvimento, vai servir como um docker compose que n√£o precisamos rodar. √â legal, mas n√£o gosto muito da abordagem pois usar docker-compose se tornou parte comum dia a dia de muitos devs e possu√≠ f√°cil leitura e troubleshooting. Se te animar, para explorar esse ponto: https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.testcontainers.at-development-time\nRefer√™ncias: https://spring.io/blog/2023/06/23/improved-testcontainers-support-in-spring-boot-3-1\nhttps://howtodoinjava.com/spring-boot/testcontainers-with-junit-and-spring-boot/\nhttps://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.testcontainers\n","permalink":"https://kaue.cat/posts/integracao_testcontainers/","summary":"Aviso: Esse post ainda passar√° por uma revis√£o!\nTestando Reposit√≥rios (De verdade!) Podemos testar reposit√≥rios de alguns jeitos, uma das maneiras √© utilizar um banco em mem√≥ria. Para SQL, h2 √© f√°cil e r√°pido, podemos fazer as configs no banco usando um application-properties para os testes e validar tudo bonitinho normalmente üôÇ. Outra alternativa seria utilizar TestContainers Conseguindo testar e subir reposit√≥rios e message brokers reais, conseguimos fazer testes de integra√ß√£o!","title":"TestContainers em Java: Testes de integra√ß√£o, reposit√≥rios e outras coisas!"},{"content":"Mudan√ßas em Cascata, Menos pontos de contato Encapsulamento √© um princ√≠pio fundamental da programa√ß√£o orientada a objetos (POO) que ajuda a controlar o acesso e a modifica√ß√£o de dados dentro de uma classe. Ele se refere √† pr√°tica de esconder os detalhes de implementa√ß√£o de uma classe de c√≥digos externos e expor apenas uma interface p√∫blica para interagir com a classe. Isso pode ajudar a evitar mudan√ßas em cascata em um sistema de software limitando o n√∫mero de pontos de contato entre diferentes partes do c√≥digo.\nUma maneira de alcan√ßar o encapsulamento (pelo menos em uma linguagem OO) √© usando modificadores de acesso como \u0026ldquo;private\u0026rdquo; ou \u0026ldquo;protected\u0026rdquo; em campos e m√©todos de classe. Isso pode evitar que c√≥digos externos acessem ou modifiquem diretamente o estado interno da classe e for√ßar o uso de m√©todos ou propriedades p√∫blicas que fornecem uma forma controlada de interagir com a classe.\nEssa n√£o √© a √∫nica maneira e nem todos os atributos de uma classe devem ter cegamente getters e setters, faz sentido uma pessoa depois de sua cria√ß√£o ter seu id alterado? Esse setter tem que existir, realmente? Outra ocasi√£o importante que indica falta de encapsulamento √© comentada no ponto 1 do cap√≠tulo de 3. Refatora√ß√£o ‚Üí Casos Usuais.\nclass MyClass { private int data; public int getData() { return data; } public void setData(int newData) { data = newData; } } O encapsulamento tamb√©m pode ser usado para evitar mudan√ßas em cascata mantendo o n√∫mero de pontos de contato entre diferentes partes do c√≥digo o m√≠nimo poss√≠vel. Ou seja, ao inv√©s de termos em 5 lugares diferentes o c√≥digo Float.parseFloat(getData()) poder√≠amos encapsular isso dentro de um m√©todo na classe Data se isso for uma regra de Data ou um comportamento relacionado √† ela (mesmo que n√£o seja, provavelmente √© um comportamento de alguma outra classe). Depois dessa refatora√ß√£o, ao mexermos nesse m√©todo, cuidaremos dos 5 pontos que o utilizam, ao inv√©s de ficar buscando por ai a linha de Float.parseFloat(getData()) e quebrarmos o c√≥digo pois n√£o encontramos uma ocorr√™ncia.\nDevo abstrair um determinado par√¢metro/retorno? J√° dissemos muito sobre abstra√ß√µes e encapsulamento, mas quando voc√™ deve abstrair um certo par√¢metro ou retorno? Aquele atributo String CPF na sua classe √© realmente prejudicial? Se sim, vale a pena criar uma classe para defini-lo?\nSuponha que voc√™ precise criar um objeto Usu√°rio, que tem como par√¢metro do construtor um nome e senha.\nclass Usuario{ ... public Usuario (String nome, String senha){} } Usuario user1 = new Usuario(\u0026#34;kaue\u0026#34;, \u0026#34;123456\u0026#34;); Nesse caso, como voc√™ pode garantir que usu√°rio deve receber sua senha como plain text, e n√£o depois de passar por um hash? Ou que a senha deve ter ao menos 6 caracteres, isso foge da l√≥gica e sem√¢ntica estabelecida pela tipo String, apesar disso, n√£o √© uma valida√ß√£o que d√° muito trabalho, um simples length j√° resolveria o problema do tamanho, nesse caso, n√£o acho que valeria criar uma classe somente para isso, mas quanto ao problema do hash, como validar√≠amos que o cliente usou corretamente o construtor e passou uma senha como plain text?\n√â simples, somente ver a implementa√ß√£o da classe Usu√°rio, mas se isso n√£o est√° claro, temos ai um code smell, uma esp√©cie de acoplamento mental. Se voc√™ n√£o tivesse acesso √† Usu√°rio, n√£o teria como adivinhar. Nesse caso em espec√≠fico, mudar o nome da vari√°vel para plainText seria uma solu√ß√£o caso.\nContudo, se a solu√ß√£o n√£o for t√£o simples, acredito que normalmente passa a valer a pena criar uma classe de dom√≠nio para o par√¢metro (ou retorno). Uma classe Senha com um construtor privado e m√©todos factory seria uma alternativa.\nTrazendo isso para um exemplo real, durante o handling de metadatas as guard√°vamos como Map\u0026lt;String,Object\u0026gt; , repetidos em diversos lugares, apesar disso, us√°vamos o Map em seu exato contexto, sem a necessidade de m√©todos a mais al√©m dos pr√≥prios do Map e o seu contexto e significado era exatamente o que um map representava, nesse caso, n√£o sentimos necessidade de abstrair o tipo.\nProtegendo Fronteiras As fronteiras s√£o a parte do seu software que agem como portas ao mundo externo. No caso de uma API, os seus clientes e pessoas que chamam a API tamb√©m s√£o externos, nenhum dado externo deve ser confiado.\nProteger as fronteiras de um software refere-se a garantir que as interfaces externas e entradas do software sejam validadas e sanitizadas adequadamente para evitar ataques maliciosos ou entradas inesperadas. Isso √© uma parte importante da seguran√ßa de software e pode ajudar a prevenir problemas como SQL Injection, cross-site scripting (XSS) e outros tipos de ataques de inje√ß√£o.\nUma das principais partes de proteger as fronteiras de software √© a valida√ß√£o de entrada (input validation). Isso envolve verificar todos os dados de entrada para garantir que eles atendam a certos crit√©rios antes de serem processados. Por exemplo, uma entrada de formul√°rio pode ser necess√°ria para ter um certo comprimento ou estar em um formato espec√≠fico. Isso pode ajudar a prevenir erros e comportamentos inesperados, al√©m de proteger contra entradas maliciosas.\nOutra parte importante de proteger as fronteiras de software √© a sanitiza√ß√£o. Isso envolve remover ou modificar qualquer elemento potencialmente prejudicial de dados de entrada. Por exemplo, uma aplica√ß√£o web pode sanitizar a entrada de usu√°rios para remover qualquer c√≥digo JavaScript ou HTML que possa ser usado para realizar um ataque cibern√©tico.\nO DDD (Domain Driven Design) tamb√©m desempenha um papel importante na prote√ß√£o das fronteiras de software. O DDD √© uma abordagem de design de software que se concentra no dom√≠nio empresarial e enfatiza a import√¢ncia de criar uma separa√ß√£o clara entre a l√≥gica do dom√≠nio e os detalhes t√©cnicos da implementa√ß√£o. Isso pode ajudar a garantir que as interfaces externas do software sejam bem definidas e f√°ceis de entender, o que pode tornar mais f√°cil validar e sanitizar entradas.\nSerializar classes de dom√≠nio ‚Üí n√£o fazer Ao expor os objetos do dom√≠nio atrav√©s de uma API, serializ√°-los e envi√°-los diretamente para o cliente como uma resposta, pode levar a uma s√©rie de problemas:\nO cliente pode potencialmente modificar o estado do objeto do dom√≠nio e violar as regras do dom√≠nio. O objeto do dom√≠nio pode conter informa√ß√µes sens√≠veis que n√£o devem ser expostas ao cliente. O objeto do dom√≠nio pode conter informa√ß√µes que n√£o s√£o relevantes para o cliente e podem levar √† coleta excessiva de dados. Para evitar esses problemas, √© recomendado criar um DTO (Objeto de Transfer√™ncia de Dados) separado que √© especificamente projetado para a API, ele deve conter apenas as informa√ß√µes que o cliente precisa e n√£o deve conter nenhum comportamento ou m√©todos que possam mudar o estado do objeto do dom√≠nio. Isso ajudar√° a proteger a integridade do modelo de dom√≠nio e manter o cliente desacoplado dos detalhes de implementa√ß√£o interna dos objetos do dom√≠nio.\nPrinc√≠pio: Favorecemos coes√£o atrav√©s do encapsulamento\nO B√°sico O Encapsulamento √© basicamente o ato de juntar comportamentos e estados que fazem sentido no mesmo lugar, garantindo maior coes√£o ao c√≥digo, √© um conceito b√°sico que precisa ser dominado. Veja esse c√≥digo em um reposit√≥rio de um framework da Apache\nfor (Address address : vcard.getAddresses()) { boolean workAddress = false; for (AddressType addressType : address.getTypes()) { if (AddressType.PREF.equals(addressType) || AddressType.WORK.equals(addressType)) { workAddress = true; break; } } if (!workAddress) continue; Sem entender muito do c√≥digo e de seu contexto, j√° somos capaz de refatorar isso de uma maneira melhor, poder√≠amos simplesmente usar:\nif(!adress.hasWorkAdress()) continue; Com isso, o c√≥digo escrito na classe ficaria mais leg√≠vel e a fun√ß√£o de descobrir se h√° endere√ßo de trabalho ou n√£o, passa a ser da classe Adress e pode ser replicado sem problemas atrav√©s de toda a aplica√ß√£o. Se decidirmos mudar a regra de neg√≥cio no estado atual, ter√≠amos que verificar por esse imenso c√≥digo esparramado por todo o programa, o que n√£o acontece no c√≥digo refatorado.\nApenas com essa altera√ß√£o:\nO service fica mais leg√≠vel O service fica mais test√°vel O c√≥digo √© reaproveitado e muda junto com apenas um ponto de contato (dentro da classe Adres) O service tem maior complexidade A complexidade n√£o surge, ela √© distribu√≠da, a regra j√° existe. Como podemos detectar isso? Um forte indicativo que algo est√° estranho √© estarmos usando um estado interno e aplicando l√≥gica em cima desse estado interno fora de sua classe.\nM√©todos privados tamb√©m podem indicar esse tipo de comportamento, talvez at√© mesmo a necessidade do nascimento de novas entidades.\nprivate Person createUserAccount(String username, Collection\u0026lt;GrantedAuthority\u0026gt; authorities,PersonAttributesLookup personAttributesLookup) { Person person = null; if (hasAccountCreationPermission(authorities)) { person = new Person(); person.setEnabled(true); person.setUsername(username); try { // Get the Person Attributes to create the person final PersonAttributesResult attr = personAttributesLookup.lookupPersonAttributes(username); person.setSchoolId(attr.getSchoolId()); person.setFirstName(attr.getFirstName()); person.setLastName(attr.getLastName()); person.setPrimaryEmailAddress(attr.getPrimaryEmailAddress()); ensureRequiredFieldsForDirectoryPerson(person); person = create(person); externalPersonService.updatePersonFromExternalPerson(person, false); LOGGER.info(\u0026#34;Successfully Created Account for {}\u0026#34;, username); } catch (final ObjectNotFoundException onfe) { ... } Refatorando:\nperson.setSchoolId(attr.getSchoolId()); person.setFirstName(attr.getFirstName()); person.setLastName(attr.getLastName()); person.setPrimaryEmailAddress(attr.getPrimaryEmailAddress()); // passa a se tornar public Class Person{ ... Person setAttributesBasedOnAttributesResult(PersonAttributesResult attr){ this.person.setSchoolId(attr.getSchoolId()); this.person.setFirstName(attr.getFirstName()); this.person.setLastName(attr.getLastName()); this.person.setPrimaryEmailAddress(attr.getPrimaryEmailAddress()); } } // seria usado: person.setAttributesBasedOnAttributesResult(attr); Somente nessa altera√ß√£o, j√° travamos setters que podem n√£o ser interessantes para o neg√≥cio (como alterar o schoolId sem alterar o emailAdress, se isso for uma regra existente), ou seja, o c√≥digo antigo estava desprotegido e acoplado mentalmente √† alguma regra externa, precisamos sempre que atualizarmos o primeiro nome atualizar tamb√©m o segundo? n√£o sei. Se sim, podemos fazer com que o encapsulamento garanta isso.\nOutro ponto de refatoramento em Person √© essa parte:\nperson = new Person(); person.setEnabled(true); person.setUsername(username); Talvez os m√©todos de setEnabled e setUsername sejam necess√°rios, ou seja, n√£o faz sentido criarmos um usu√°rio sem Username e desabilitado, por que isso n√£o faz parte do construtor? Esses setters provavelmente nem deveriam existir, com os atributos setados no pr√≥prio construtor. Tratamos isso no cap√≠tulo de refatora√ß√£o\nO c√≥digo final poderia ficar:\nprivate Person createUserAccount(String username, Collection\u0026lt;GrantedAuthority\u0026gt; authorities,PersonAttributesLookup personAttributesLookup) { Person person = null; if (hasAccountCreationPermission(authorities)) { person = new Person(); try { // Get the Person Attributes to create the person final PersonAttributesResult attr = personAttributesLookup.lookupPersonAttributes(username); person.setAttributesBasedOnAttributesResult(attr); ensureRequiredFieldsForDirectoryPerson(person); person = create(person); externalPersonService.updatePersonFromExternalPerson(person, false); LOGGER.info(\u0026#34;Successfully Created Account for {}\u0026#34;, username); } catch (final ObjectNotFoundException onfe) { ... } } Disclaimer! N√£o leve tudo que leu aqui como verdades absolutas ou regras a serem seguida em 100% dos casos, n√£o existe martelo de ouro nem bala de prata. Se houver algum questionamento ou sugest√£o, pode deixar aqui!\nRefer√™ncias: Encapsulamento para ganhar mais coes√£o: O feij√£o com arroz que precisa estar dominado\nOOP E Solid para ninjas - Casa do c√≥digo - Aniche\nDesbravando SOLID - Casa do C√≥digo - Aquiles\n","permalink":"https://kaue.cat/posts/encapsulamento/","summary":"Mudan√ßas em Cascata, Menos pontos de contato Encapsulamento √© um princ√≠pio fundamental da programa√ß√£o orientada a objetos (POO) que ajuda a controlar o acesso e a modifica√ß√£o de dados dentro de uma classe. Ele se refere √† pr√°tica de esconder os detalhes de implementa√ß√£o de uma classe de c√≥digos externos e expor apenas uma interface p√∫blica para interagir com a classe. Isso pode ajudar a evitar mudan√ßas em cascata em um sistema de software limitando o n√∫mero de pontos de contato entre diferentes partes do c√≥digo.","title":"Encapsulamento: O B√°sico que todo jr. precisa saber!"},{"content":"Contexto Quando trabalhando em sistemas reais, temos que nos preocupar com a seguran√ßa de nosso c√≥digo, pontos espec√≠ficos de nosso c√≥digo podem ser mais suscet√≠veis a falhas, mudan√ßas de uma camada de baixo n√≠vel (infraestrutura) podem acarretar em problemas caso haja grandes altera√ß√µes ou at√© mesmo uma mudan√ßa de vendor. Nesse breve artigo irei discutir duas atividades bem frequentes na minha rotina no Bees/AmBev\n1. Features Toggle Em diversos momentos, faz sentido que uma feature seja facilmente desligada ou n√£o usando um toggle, fazendo com que essa altera√ß√£o n√£o precise de um deploy, dando mais agilidade e seguran√ßa √† sua altera√ß√£o. Para isso temos algumas op√ß√µes, podemos usar vari√°veis de ambientes ou at√© mesmo guardar o valor no banco de dados. Uma maneira f√°cil de implementar em Spring √© simplesmente puxar os dados de seu application.properties ou application.yaml\nNo Spring Op√ß√£o 1: @Value Essa op√ß√£o √© particularmente √∫til para configura√ß√µes mais simples, que possuem apenas um campo (ex: Enabled) e n√£o s√£o usadas em diversos lugares. Yaml:\nfeatures: algumaFeature: enabled: true outraFeature: enabled: true Spring:\n@Value(\u0026#34;${features.algumaFeature.enabled}\u0026#34;) private Boolean valueFromFile; Op√ß√£o 2: @ConfigurationProperties Melhor para cen√°rios mais complexos, ou quando a propriedade √© usada em diversos lugares. Yaml:\nbroker: queues: ticket: name: default.ticket exchanges: ticket: name: direct.ticket type: direct bindings: ticket: exchange: direct.ticket queue: default.ticket routingKey: default.ticke Spring:\n@Configuration @ConfigurationProperties(prefix = \u0026#34;broker\u0026#34;) @Data public class BrokerConfigurationProperties { private Map\u0026lt;String, QueueProperties\u0026gt; queues; private Map\u0026lt;String, ExchangeProperties\u0026gt; exchanges; private Map\u0026lt;String, BindingProperties\u0026gt; bindings; @Data public static class QueueProperties { @NotEmpty private String name; } @Data public static class ExchangeProperties { @NotEmpty private String name; private String type; } @Data public static class BindingProperties { @NotEmpty private String exchange; @NotEmpty private String queue; @NotEmpty private String routingKey; } } Aqui basta voc√™ fazer o mapeamento das classes de acordo com suas propriedades. Se houver dificuldade, √© uma tarefa em que alguma AI provavelmente vai lidar com facilidade.\n2. Diferentes Beans de Infraestrutura! Permita um rollback f√°cil Em um c√≥digo ideal, a sua camada de dom√≠nio provavelmente estar√° desacoplada de sua camada de infraestrutura por meio de interfaces. Se isso n√£o faz sentido para voc√™, recomendo meu post de SOLID :) Continuando, com um c√≥digo com m√≥dulos de alto e baixo n√≠vel desacoplados, conseguimos mudar a infraestrutura sem mexer no dom√≠nio. Isso nos d√° a liberdade de gerenciar os beans que sua classe de dom√≠nio ir√° usar com mais facilidade, pois todas as implementa√ß√µes de infraestrutura ir√£o respeitar a interface.\n@AllArgsConstructor public class TicketService { private final TicketRepository repository; private final Notifier messagePublisher; public List\u0026lt;Ticket\u0026gt; findAll(){ return repository.findAll(); } public Ticket findById(String Id){ return repository.findById(Id).orElseThrow( () -\u0026gt; new TicketNotFoundException(\u0026#34;Ticket not found\u0026#34;) ); } public Ticket save(Ticket ticket){ messagePublisher.Notify(TicketEventsEnum.TICKET_CREATED); return repository.save(ticket); } } Temos aqui um Simples Service, tendo suas depend√™ncias injetadas via construtor pelo SPRING. Note que nosso servi√ßo conhece regras de neg√≥cio, dentre elas, quando um ticket √© criado, ele tem que notificar algo, e tem que guardar em algum lugar (repository pode cuidar de mongoDB, MySQL, et cetera.) Note que se tivermos um reposit√≥rio com c√≥digo espec√≠fico do MySQL e quisermos migrar para um c√≥digo com Spring Data JPA, teremos que mudar a camada de infraestrutura (resumidamente, vamos escrever mais c√≥digo de Reposit√≥rio), mas nossa regra de neg√≥cio √© a mesma. Imagine agora que essa camada √© um ponto cr√≠tico da sua aplica√ß√£o, caso a implementa√ß√£o que voc√™ fez com tanta boa vontade d√™ errado, voc√™ ter√° que fazer um rollback.\nDefinindo os Beans Manualmente Ao inv√©s de definir os reposit√≥rios com @Component, como teremos dois reposit√≥rios, o Spring n√£o saber√° com qual Bean lidar. Temos diversas maneiras de fazer a desambigua√ß√£o de Beans, dentre elas, prioridades, primary, qualifier, aqui vou para uma abordagem simples, apenas para exemplificar a feature. No meu yaml, irei definir uma propriedade:\nrepository: type: ${DEFINED_REPOSITORY:mysql} Caso exista uma vari√°vel de ambiente chamada DEFINED_REPOSITORY, ela ser√° o padr√£o para o tipo do meu reposit√≥rio, caso contr√°rio, ser√° mysql, como um fallback. (No caso, escolhi deixar o MySQL como fallback pois teoricamente ele √© o reposit√≥rio testado e j√° em produ√ß√£o). Perfeito, agora vamos definir qual bean utilizar:\n@Configuration public class RepositoryConfiguration{ @Value(\u0026#34;${repository.type}\u0026#34;) private String repositoryType; @Bean public TicketRepository ticketRepository (){ if(\u0026#34;mysql\u0026#34;.equalsIgnoreCase(repositoryType)){ return new MySQLTicketRepository(); } if(\u0026#34;spring\u0026#34;.equalsIgnoreCase(repositoryType)){ return new JpaTicketRepository(); } return new MySQLTicketRepository(); // fallback } } Outra maneira de fazer esse tipo de configura√ß√£o √© usar profiles do Spring.\nObrigado! Obrigado, espero que o breve artigo tenha sido √∫til. Escrevi em 20 minutos e n√£o o revisei, ent√£o se houver algum problema, pode me avisar :)\n","permalink":"https://kaue.cat/posts/refactors_seguros/","summary":"Contexto Quando trabalhando em sistemas reais, temos que nos preocupar com a seguran√ßa de nosso c√≥digo, pontos espec√≠ficos de nosso c√≥digo podem ser mais suscet√≠veis a falhas, mudan√ßas de uma camada de baixo n√≠vel (infraestrutura) podem acarretar em problemas caso haja grandes altera√ß√µes ou at√© mesmo uma mudan√ßa de vendor. Nesse breve artigo irei discutir duas atividades bem frequentes na minha rotina no Bees/AmBev\n1. Features Toggle Em diversos momentos, faz sentido que uma feature seja facilmente desligada ou n√£o usando um toggle, fazendo com que essa altera√ß√£o n√£o precise de um deploy, dando mais agilidade e seguran√ßa √† sua altera√ß√£o.","title":"Features e Refactors Seguros com Java e SPRING: 2 dicas simples!"},{"content":"Contexto Escrevo conte√∫dos h√° um tempo para mim mesmo em ferramentas como notion ou tamb√©m para outros, em sites como dev.to. Apesar disso, sempre senti a vontade de ter um dom√≠nio pr√≥prio. Olhando o famoso http.cat percebi que existe o dom√≠nio do catal√£o .cat, meu sobrenome sendo gatto e j√° tendo ouvido \u0026ldquo;kaue cat\u0026rdquo; por ai, s√≥ comprei o dom√≠nio. N√£o queria gastar mais do que os 20 reais do dom√≠nio, ent√£o decidi hospedar no github, ai que come√ßa a jornada de um site est√°tico.\nSSG\u0026rsquo;s Sites est√°ticos s√£o compostos por conte√∫dos e arquivos que possuem uma estrutura espec√≠fica definida nele e sempre ir√£o produzir o mesmo resultado, independente de um servidor backend, banco de dados, etc. O github permite a hospedagem de sites est√°ticos gratuitamente, portanto, esse era o caminho a ser seguido!\nSSG\u0026rsquo;s s√£o geradores literalmente Static Sites Generators e permitiriam que eu alcancasse meu objetivo, procurei por uns projetos open-source e acabei com o hugo, vi alguns temas que achei interessante, o setup parecia relativamente simples, ent√£o s√≥ fui adiante.\nHugo O hugo √© um dos SSG\u0026rsquo;s open source mais conhecidos, ele possue temas focados em portfolios, sites empresariais e principalmente blogs. √â relativamente f√°cil de usar e permite a constru√ß√£o de configura√ß√£o de um site dentro de um tema j√° existente bem r√°pido. A maior parte das configura√ß√µes acontece atrav√©s do arquivo config.yaml ou toml, dependendo do formato escolhido, podemos tamb√©m criar arqu√©tipos de posts e outros tipos de conte√∫dos, para facilitar a nossa vida.\nA maior parte dos temas do hugo s√£o responsivos, documentados r√°pidos e bem implementados, estou usando papermod no caso, caso tenha interesse, pode conferir o rodap√© da p√°gina\nInstalando o tema Papermod para o Hugo Aqui a tarefa foi simples, conhecendo um pouco como o hugo funciona, segui o passo a passo das docs, peguei a pipeline de actions desse v√≠deo e as coisas aconteceram, para o deployment ocorrer, voc√™ deve criar uma branch chamada gh-pages, para onde ser√° enviado o build da aplica√ß√£o hugo.\nDNS Depois disso, apenas configurar o DNS n√£o foi muito dif√≠cil, entrei na hostinger e setei os 4 ip\u0026rsquo;s apontados pelo github como a names, al√©m do cname. Obriguei o uso de https e aparentemente est√° tudo certo :)\n","permalink":"https://kaue.cat/posts/ola_mundo/","summary":"Contexto Escrevo conte√∫dos h√° um tempo para mim mesmo em ferramentas como notion ou tamb√©m para outros, em sites como dev.to. Apesar disso, sempre senti a vontade de ter um dom√≠nio pr√≥prio. Olhando o famoso http.cat percebi que existe o dom√≠nio do catal√£o .cat, meu sobrenome sendo gatto e j√° tendo ouvido \u0026ldquo;kaue cat\u0026rdquo; por ai, s√≥ comprei o dom√≠nio. N√£o queria gastar mais do que os 20 reais do dom√≠nio, ent√£o decidi hospedar no github, ai que come√ßa a jornada de um site est√°tico.","title":"Como eu fiz meu blog!"}]