[{"content":"Arquitetura √† nivel de Software: Refere-se √† organiza√ß√£o e defini√ß√£o de regras a serem seguidas no seu projeto em si, seja ele um microservi√ßo, monolito ou qualquer outra parte de uma solu√ß√£o maior, nossa √™nfase est√° no n√≠vel do seu servi√ßo, um servi√ßo seu pode seguir √† risca SOLID, arquitetura hexagonal e uma PoC pode seguir o famoso: faz r√°pido e funcionando.\nDe outro lado, cuidando e decidindo se temos SOA, Microservi√ßos, Monolitos ou qual protocolo de comunica√ß√£o usamos, temos a arquitetura de solu√ß√µes, o que n√£o √© o foco do artigo\nModelo Baseado em Camadas √â bem comum dividirmos nosso software em camadas, √© o que fazemos na maior parte das arquiteturas de software modernas, essa divis√£o tem como objetivo separar partes do c√≥digo que n√£o devem interagir muito entre si exceto por alguns pontos de contato (que podem ser outras camadas), e tamb√©m garantir que exista um ‚Äúmeio de campo‚Äù entre certas camadas, ou seja, a interface n√£o vai falar diretamente com o banco de dados, existe um caminho para isso.\nUm dos pontos negativos desses modelos √© que eles n√£o costumam definir a obriga√ß√£o ou sugest√£o de interfaces para comunica√ß√£o com servi√ßos externos, normalmente services s√£o totalmente acoplados √† infraestrutura, em alguns casos, at√© mesmo temos DAO‚Äôs que implementam regras de persist√™ncia na camada de modelo. O problema disso √© claro, nossas regras de neg√≥cio muitas vezes acabam acopladas √† meras ferramentas, trocar o banco de dados exige que voc√™ mexa em um peda√ßo que deveria representar sua regra de neg√≥cio, o que n√£o acontece em outros modelos como arquitetura hexagonal (a menos que voc√™ adapte seu padr√£o em camadas para ter abstra√ß√µes significativas, o que √© totalmente v√°lido üôÇ).\nMVC O MVC (Model-View-Controller) √© um pattern arquitetural usado como um molde pra distribui√ß√£o de responsabilidades em trechos de c√≥digo que tratam de interfaces com o usu√°rio (UI). H√° tr√™s responsabilidades pre-estabelecidas:\nView: cont√©m a l√≥gica que monta a UI (telas ou equivalente) e que trata a entrada de dados, recebendo eventos do usu√°rio (clique, digita√ß√£o etc.). As do usu√°rio s√£o repassadas para o Controller. A View pode buscar dados diretamente do Model para exibi√ß√£o na UL Controller. o \u0026ldquo;meio de campo\u0026rdquo;, recebe intera√ß√µes do usu√°rio da View e colabora com o Model para enviar e obter dados, que s√£o repassados para a View. Model: o resto do c√≥digo, que n√£o tem a ver com UI. Realiza c√°lculos, regras de neg√≥cio, persist√™ncia, integra√ß√µes com outros sistemas etc. H√° diversas varia√ß√µes como MVP, MVVM, entre outros. Outros exemplos ‚Üí MVVM The main thrust of the Model/View/ViewModel architecture seems to be that on top of the data (‚Äùthe Model‚Äù), there‚Äôs another layer of non-visual components (‚Äùthe ViewModel‚Äù) that map the concepts of the data more closely to the concepts of the view of the data (‚Äùthe View‚Äù). It‚Äôs the ViewModel that the View binds to, not the Model directly.\nArquitetura Hexagonal - Ports And Adapters A arquitetura hexagonal √© uma proposta de arquitetura de software que segue l√≥gicas de desenvolvimento de software que pensam em acoplamento e coes√£o, basicamente, m√≥dulos de alto n√≠vel (que possuem regras de neg√≥cio) n√£o devem depender de implementa√ß√µes de m√≥dulos de baixo n√≠vel (frameworks, bibliotecas de terceiros, et cetera.). Tudo que acessa o cora√ß√£o / dom√≠nio / regra de neg√≥cio da sua aplica√ß√£o deve passar por portas, que s√£o basicamente interfaces que representam o que aquela biblioteca far√° para voc√™, chamamos a implementa√ß√£o dessas interfaces de adaptadores.\nOu seja, em um sistema de login, podemos disparar um evento em uma fila de mensagens RabbitMQ que ser√° consumido por um outro servi√ßo de notifica√ß√£o, pensando em um n√≠vel um pouco mais abstrato, esquecendo bibliotecas ou ferramentas, podemos criar uma interface de publicador de eventos e dizer que vamos usar ela, ou seja, nossa l√≥gica de neg√≥cio precisa enviar uma notifica√ß√£o de cadastro e um payload, independente se rabbitMQ, kafka ou outra porta est√° sendo usada:\nprivate final Notifier messagePublisher; public class TicketService { public Ticket create(Ticket ticket){ messagePublisher.Notify(TicketEventsEnum.TICKET_CREATED); return repository.save(ticket); } } No service, a regra de neg√≥cio de cria√ß√£o de um ticket √© exatamente essa, note que n√£o estou usando uma regra de rabbitMQ necessariamente, nem mesmo o seu vocabul√°rio (normalmente usar√≠amos publish) o importante para a regra de cria√ß√£o, √© enviar uma notifica√ß√£o!\nA depend√™ncia Notifier √© na realidade uma interface pr√≥pria, que representa o que necessitamos, o envio de uma notifica√ß√£o, √© uma porta.\npublic interface Notifier { void Notify(Object message); } O Adaptador, que √© basicamente uma das op√ß√µes de notificadores que vc tem √© a implementa√ß√£o real, voc√™ poderia trocar os adaptadores e ainda assim n√£o ter problemas no seu dom√≠nio, tendo em vista que todo adaptadores respeita a mesma interface (porta).\nImagine que voc√™ est√° indo viajar, o n√∫cleo da aplica√ß√£o √© o conte√∫do essencial da sua mala - os itens vitais que voc√™ n√£o pode deixar para tr√°s. Os adaptadores s√£o os diversos compartimentos e bolsos especializados na mala, cada um projetado para acomodar diferentes necessidades, voc√™ tem um plugue para tomadas da europa, outros para os estados unidos e outra que suporta o padr√£o adotado na √°sia (n√£o sei nem se √© diferente). Da mesma forma, os adaptadores na arquitetura hexagonal conectam o n√∫cleo da aplica√ß√£o a interfaces externas variadas, como bancos de dados, interfaces de usu√°rio e servi√ßos externos, esses adaptadores permitem que a aplica√ß√£o funcione em ambientes diversos.\nClean Architecture N√£o entrarei em detalhes pela sua complexidade e individualidades, mas saiba que tanto a clean architecture quanto a onion se baseiam no mesmo fundamento, de proteger a camada de dom√≠nio, com os mesmos princ√≠pios de abstra√ß√£o por interfaces, e adaptadores implementando-as\nDDD - Isso n√£o √© sobre DDD O Deisgn orientado √† Dom√≠nio (Domain Driven Design / DDD) √© um conceito extenso e vai al√©m de um sugest√µes sobre como dividir seu c√≥digo em camadas (esse nem √© o foco), comentando a maneira com que o software √© escrito, a linguagem utilizada no processo de fabrica√ß√£o, o que s√£o as fronteiras entre suas entidades e regras de neg√≥cio e como elas devem ser implementadas, realmente fazendo com que a preocupa√ß√£o de dom√≠nio seja a central na constru√ß√£o de software.\nEncare o DDD como uma prescri√ß√£o de metodologia e processo para o desenvolvimento de sistemas complexos cujo foco √© mapear atividades, tarefas, eventos e dados dentro de um dom√≠nio de problema nos artefatos de tecnologia de um dom√≠nio de solu√ß√£o.\nApesar disso, Evans em seu livro deu diversas sugest√µes arquiteturais, como por exemplo, os services, muitas vezes, mal utilizados ou interpretados. Veremos agora algumas sugest√µes e pontos do autor.\nDDD - Sugest√µes Arquiteturais ‚Üí e de design de c√≥digo Antes de tudo, acho importante definir o que √© o dom√≠nio de uma aplica√ß√£o:\nDom√≠nio: No contexto de Engenharia de Software √© o ‚Äúconhecimento‚Äù¬†utilizado em uma determinada √°rea de aplica√ß√£o, um campo espec√≠fico para qual o sistema foi desenvolvido, ou seja, os problemas, regras e solu√ß√µes que envolvem uma parte da aplica√ß√£o, apesar disso, muitas vezes nos referimos ao dom√≠nio de neg√≥cio (n√∫cleo de regras e conhecimentos que envolvem o neg√≥cio) somente como dom√≠nio, leve isso em considera√ß√£o, por√©m tenha em mente que uma aplica√ß√£o tem diversos dom√≠nios.\nQuando o c√≥digo relacionado ao dom√≠nio √© distribu√≠do por uma por√ß√£o t√£o grande de outros c√≥digos (espalhado), torna-se extremamente dif√≠cil distingui-los e raciocinar. Altera√ß√µes superficiais na interface do usu√°rio podem realmente alterar a l√≥gica de neg√≥cios (altera√ß√µes vazam para onde n√£o devem).\nAssim sendo:\nIsole o modelo do dom√≠nio e a l√≥gica de neg√≥cios e elimine qualquer depend√™ncia que eles possam ter na infraestrutura, na interface do usu√°rio ou mesmo na l√≥gica do aplicativo que n√£o seja l√≥gica de neg√≥cios. Particione um programa complexo em camadas. Desenvolva um design dentro de cada camada que seja coeso e que dependa apenas das camadas abaixo. Concentre todo o c√≥digo relacionado ao modelo do dom√≠nio em uma camada e isole-o do c√≥digo da interface do usu√°rio, do aplicativo e da infraestrutura. Os objetos de dom√≠nio, livres da responsabilidade de se exibir, de se armazenar, de gerenciar tarefas do aplicativo, e assim por diante, podem se concentrar em expressar o modelo do dom√≠nio. Isso permite que um modelo evolua para se tornar rico e limpo o suficiente para capturar o conhecimento essencial do neg√≥cio e coloc√°-lo para funcionar, sempre que uma regra de neg√≥cio surgir, o modelo de dom√≠nio deve ser o necess√°rio por implement√°-la, quem deve se adaptar √†s regras de neg√≥cio √© a implementa√ß√£o, e nunca o contr√°rio.\nDito isso, colocar as responsabilidades certas no dom√≠nio n√£o significa que o modelo deve ser an√™mico, o modelo pode (e deve) manter regras e formas para que seu escopo seja v√°lido. Ou seja, fazemos o poss√≠vel para que uma entidade de dom√≠nio nas√ßa e continue sempre de acordo com suas regras de neg√≥cio.\nModelos An√™micos - Um problema Conceito muito difundido no artigo Anemic Domain Model, de Martin Fowler.\nQuando falamos de modelos de dom√≠nio an√™micos dizemos de modelos onde as regras de neg√≥cio associadas √† uma entidade √© externa √† pr√≥pria entidade. Temos uma classe pedido mas o m√©todo para verificar se o pedido cont√©m itens ou n√£o est√° em um ‚Äúservice‚Äù, que acaba sendo uma classe que possui regras que poderiam existir dentro de uma pr√≥pria entidade (se contiver somente o seu comportamento).\nClasses que possuem somente atributos s√£o classes de dom√≠nio an√™micas, idealmente, uma classe deve conter comportamento e atributos.\nPodemos chamar classes JAVA ou C# que s√£o totalmente desacoplada de outras bibliotecas ou framewrks de POCO (no C#) ou POJO (no JAVA). Por serem c√≥digos puros escritos em java ou c#, que n√£o deviram de uma classe base e nem retornam ou utilizam de tipos especiais, ou seja, s√£o classes simples que sabem apenas de seu dom√≠nio, devemos sempre seguir os princ√≠pios da ignor√¢ncia da infraestrutura e ignor√¢ncia da persist√™ncia para essas classes.\nPortanto, as entidades n√£o devem ser associadas aos modos de exibi√ß√£o do cliente pois, no n√≠vel da interface do usu√°rio, alguns dados podem ainda n√£o ter sido validados. √â por esse motivo que o ViewModel existe. O ViewModel √© um modelo de dados exclusivamente para necessidades de camada de apresenta√ß√£o. As entidades de dom√≠nio n√£o pertencem diretamente ao ViewModel. Em vez disso, voc√™ precisa converter entre entidades de dom√≠nio e ViewModels e vice-versa. - Projetar um microsservi√ßo orientado a DDD, Microsoft\nRefatorando um Dom√≠nio an√™mico Atributos distantes do comportamento Para come√ßar, recomendo ler o caso 1 de 3. Refatora√ß√£o ‚Üí Casos Usuais, depois volte aqui. De maneira geral, classes devem guardar dentro de si atributos e comportamentos, se voc√™ possui comportamentos que agem sobre os atributos de uma classe espec√≠fica, costuma fazer sentido encapsul√°-los dentro da classe.\nExemplo:\nClass ComprarIngressoService{ void comprar(Pessoa pessoa, Evento evento){ ... if(pessoa.idade\u0026lt;18){ // menor de idade } if(pessoa.getCadastro()==\u0026#34;ativo\u0026#34;){ // } } } Esse tipo de valida√ß√£o √© aparentemente inofensiva, contudo, fr√°gil, pode causar diversas repeti√ß√µes no c√≥digo e aumentar pontos de contato para uma poss√≠vel altera√ß√£o, em alguns casos, esse tipo de erro piora muito a leitura. Faz sentido que a classe Pessoa cuide de propriedades das pessoas, logo, a refatora√ß√£o a seguir √© poss√≠vel:\nClass ComprarIngressoService{ void comprar(Pessoa pessoa, Evento evento){ ... if(pessoa.maiorDeIdade()){ // menor de idade } if(pessoa.estaAtiva()){ // } } } Construtores, Builders e falta de amor aos erros de compila√ß√£o Um grande motivo para escrevermos c√≥digos que s√£o fortemente tipados √© a possibilidade de perceber erros em tempo de compila√ß√£o, erros que impedem que fa√ßamos coisas que n√£o fazem sentido dado o contexto do que estamos tentando fazer, a sem√¢ntica de string, por exemplo, entendida como cadeia de caracteres, n√£o permite a soma de n√∫meros a ela (Some um √† kaue).\nDito isto, grande parte das classes de dom√≠nio n√£o validam seu estado, muitas vezes nem em sua cria√ß√£o. √â comum ver por ai classes com construtores vazios e c√≥digos setters p√∫blicos (pois getters e setters teoricamente protegem o encapsulamento) isso por si s√≥ n√£o garante que uma classe ir√° ser usada como esperada, veja o exemplo a seguir.\nclass Pessoa{ Pessoa(){ // construtor vazio, no java √© opcional\t} @Getter @Setter // simulando o lombok, mas pode imaginar que s√£o m√©todos getter e setters p√∫blicos private Long id; @Getter @Setter private String nome; @Getter @Setter private Int peso; } // em algum outro lugar: Pessoa kaue = new Pessoa(); kaue.setId(1); kaue.setNome(\u0026#34;kaue\u0026#34;); kaue.setPeso(65); // teoricamente kaue est√° tranquilo levando em conta que todos os campos foram preenchidos, mas e o seguinte? Pessoa douglas = new Pessoa(); douglas.setPeso(70); N√£o existe erro de compila√ß√£o e nem de execu√ß√£o (POR ENQUANTO) aqui.\n√â √≥bvio que os setters deveriam validar se os campos foram preenchidos de seguindo um certo padr√£o e que faltam m√©todos para lidar com o objeto pessoa como indicado no ponto anterior, o modelo est√° an√™mico, mas esse n√£o √© o foco, criamos um objeto de uma Pessoa chamado douglas, que possui apenas seu peso definido, o que provavelmente n√£o faz sentido quando pensamos na cria√ß√£o de uma pessoa em um sistema, dever√≠amos (dependendo do neg√≥cio) ao menos for√ßar o preenchimento de id e nome.\nclass Pessoa{ Pessoa(String id, String nome){ // √∫nico construtor recebendo os campos opcionais. this.id=id; this.nome=nome; } @Getter // setter n√£o existe mais private Long id; @Getter // setter pode at√© existir, mas nesse caso n√£o vou criar. private String nome; @Getter @Setter private Int peso; } // em algum outro lugar: Pessoa kaue = new Pessoa(1,\u0026#34;kaue\u0026#34;); kaue.setPeso(65); Pessoa douglas = new Pessoa(); // erro douglas.setPeso(70); Mas e classes builders? Tamb√©m n√£o √© incomum ver builders que esquecem de implementar os campos obrigat√≥rios, para nossa felicidade, √© algo simples de ser resolvido.\nPessoaBuilder pessoaBuilder = new PessoaBuilder(1,\u0026#34;kaue\u0026#34;); // construtor do BUILDER tem em si os par√¢metros necess√°rios para criar a classe que constr√≥i // se o m√©todo para pegar o builder for um m√©todo est√°tico, s√≥ passar em seu par√¢metro Pessoa kaue = pessoaBuilder .withPeso(70) .build(); Usando o lombok @Builder, podemos fazer:\nimport lombok.Builder; @Builder(builderMethodName = \u0026#34;hiddenBuilder\u0026#34;) public class Person { @NotNull private String name; private String surname; public static PersonBuilder builder(String name) { return hiddenBuilder().name(name); // o nome desse builder interno √© arbitr√°rio } } // Person p = Person.builder(\u0026#34;Kaue\u0026#34;).surname(\u0026#34;Surname\u0026#34;).build(); Essa t√°tica, usando o lombok ou n√£o, tem alguns problemas e normalmente n√£o faz sentido em classes que tem muitos par√¢metros obrigat√≥rios e at√© mesmo em algumas classes simples, pois depreca, mesmo que um pouco, uma das grandes vantagens que a classe builder tem, a visibilidade, imagine isso:\nEndereco e = Endereco.builder(\u0026#34;Osvaldo Albherto\u0026#34;, \u0026#34;Parque Bitaru\u0026#34;, \u0026#34;42\u0026#34;, \u0026#34;Abilio\u0026#34;) .complemento(\u0026#34;Ap 1\u0026#34;) .maisInformacoes(\u0026#34;Pode entregar pro vizinho\u0026#34;) .build(); Somente lendo esse c√≥digo, voc√™ s√≥ consegue ter certeza do complemento e maisInformacoes, os outros campos n√£o s√£o t√£o vis√≠veis, ainda assim, como opini√£o pessoal, prefiro por ter esse c√≥digo, que se torna um pouco menos vis√≠vel mas garante o uso correto da classe, mostrando erros de compila√ß√£o na pr√≥pria IDE caso os atributos obrigat√≥rios n√£o estejam preenchidos.\nModelos Ricos: como lidar com depend√™ncias excessivas Se sua classe POJO de dom√≠nio necessitar de bibliotecas ou outras depend√™ncias (fa√ßa-as serem interfaces üôè), instanci√°-la ficar√° extremamente inconveniente, para isso existe o Design Pattern: Factory\nDesign Pattern: Factory Factories s√£o m√©todos (ou classes) que possuem como retorno a cria√ß√£o de um outro objeto, em casos mais simples, podem ser m√©todos est√°ticos dentro da pr√≥pria classe, em casos mais complexos, onde teremos diferentes depend√™ncias a serem injetadas nas classes de dom√≠nio atr√°ves de um framework ou container de inje√ß√£o de depend√™ncia, como o Spring faz, podemos usar classes.\nImagine a exist√™ncia de uma classe usu√°rio, que necessita que seu pr√≥prio email seja validado, e para isso, voc√™ quer usar uma biblioteca x ou y, voc√™, respeitando princ√≠pios b√°sicos, criar√° uma interface a qual Usu√°rio depender√°, e far√° com que a inje√ß√£o de depend√™ncia passe a voc√™ uma inst√¢ncia do validador em algum momento, isso ir√° se tornar extremamente inconveniente muito r√°pido, portanto, podemos fazer:\npublic class Usuario { private String email; private EmailValidator emailValidator; public Usuario(String email, EmailValidator emailValidator) { this.email = email; this.emailValidator = emailValidator; } public boolean isEmailValid() { return emailValidator.isValid(email); } // Outros m√©todos da classe Usuario } public class UsuarioFactory { private final EmailValidator emailValidator; // Construtor com inje√ß√£o de depend√™ncia! public UsuarioFactory(EmailValidator emailValidator) { this.emailValidator = emailValidator; } // M√©todo para criar inst√¢ncia de Usuario usando o validador de e-mail fornecido pelo Spring (ou pelo seu framework de DI) public Usuario createUsuario(String email) { return new Usuario(email, emailValidator); } } E os Services? Evans Descreve em seu livro tr√™s tipos de services:\nApplication Service:\nFornece para o usu√°rio opera√ß√µes que o seu software pode executar, e controla a execu√ß√£o dessas opera√ß√µes atrav√©s de chamadas a m√©todos de objetos das outras camadas (dom√≠nio, infraestrutura, etc.). √â importante dizer que a Application Service¬†n√£o cont√©m regras de neg√≥cios ou conhecimento do dom√≠nio, sendo assim, ela apenas coordena as chamadas a m√©todos de outras camadas e mant√©m o estado que reflete o progresso de uma opera√ß√£o para o usu√°rio. Application Layer: Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems. The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems. This layer is kept thin. It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down. It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program. - Evans DDD\nDomain Services:\nFornece para a¬†Application Service¬†m√©todos que permitam a execu√ß√£o de opera√ß√µes sobre os objetos de Dom√≠nio (camada mais interna). Embora seja comum representar grande parte dos conceitos e regras principais do neg√≥cio aqui, o ideal √© que esses detalhes sejam representados diretamente nos Domain Models. Sendo assim, o Domain Service deve chamar e controlar a execu√ß√£o de m√©todos dos objetos do Domain Model¬†quando n√£o √© trivial ou l√≥gico declarar um m√©todo diretamente no modelo de dom√≠nio As vezes, a situa√ß√£o simplesmente n√£o se trata de uma coisa.\nAlguns conceitos do dom√≠nio n√£o s√£o naturais para serem modelados na forma de objetos.\nFor√ßar a funcionalidade do dom√≠nio necess√°ria para que ela seja a responsabilidade de uma Entidade ou Objeto de Valor distorce a defini√ß√£o de um objeto baseado em modelos ou adiciona objetos artificiais sem sentido.\nAssim sendo:\nQuando um processo ou transforma√ß√£o significativa no dom√≠nio n√£o √© uma responsabilidade natural de uma Entidade ou Objeto de Valor, adicione uma opera√ß√£o no modelo como uma interface aut√¥noma declarada como Servi√ßo. Defina um contrato de servi√ßo, um conjunto de asser√ß√µes sobre intera√ß√µes com o Servi√ßo. (Veja ‚Äúasser√ß√µes‚Äù) Torne essas asser√ß√µes participantes da Linguagem Onipresente de um Contexto Delimitado espec√≠fico. D√™ um nome ao Servi√ßo, que tamb√©m se torne parte da Linguagem Onipresente. Evans - DDD\nInfrastructure Services:\nFornece m√©todos que permitem a execu√ß√£o de opera√ß√µes sobre a infraestrutura na qual o software est√° sendo executado. Isso significa que esses servi√ßos tem conhecimento sobre detalhes das implementa√ß√µes concretas da infraestrutura tais como: acesso a bancos de dados, acesso a rede, controle de opera√ß√µes de IO, acesso a hardware etc. Geralmente esse service √© utilizado pelos Application Services para complementar e auxiliar suas opera√ß√µes, por exemplo, fornecer um m√©todo que permita a cria√ß√£o e controle de um buffer para realizar download de arquivos. Contrapontos: Design a microservice domain model - Microsoft\nSome people say that the anemic domain model is an anti-pattern. It really depends on what you are implementing. If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern. However, if you need to tackle the complexity of a microservice‚Äôs domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context. In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.\nMicrosoft resource Aqui entendemos uma coisa que deve ser clara, n√£o existe bala de prata na computa√ß√£o, faz sentido abstra√≠rmos o SPRING, Controllers, Services e outras funcionalidades ou entedemos que nossa aplica√ß√£o nasce acoplada ao SPRING e morre com ele?\nAqui, tudo cabe √† voc√™ entender pontos, contrapontos e o seu contexto, no seu caso. Se sua aplica√ß√£o s√≥ existe junto √† infraestrutura de uma biblioteca, talvez n√£o haja motivo para desacopl√°-la, se voc√™ n√£o v√™ perspectivas para deixar de usar lombok, n√£o necessariamente precisa fazer seu modelo de dom√≠nio POJOS realmente puras use seu lombok, e seja feliz. Um projeto simples ou que necessita ser entregue muito rapidamente n√£o usar de conceitos como Arquitetura Hexagonal, DDD, CQRS ou qualquer outro pattern n√£o se traduz emprojeto simples ou que significa c√≥digo ruim.\nRefer√™ncias: The Software Architecture Chronicles\nEsse blog, essa cr√¥nica em espec√≠fico - √© maravilhosa!! Se estiver off, procure no wayback machine.\nDomain Driven Design, Eric Evans\nAnemic Domain Model, Martin Fowler (Cosigned by Evans)\nSum√°rio de Padr√µes e Defini√ß√µes do DDD - Traduzido por Ricardo Pereira Dias\nProjetando um microsservi√ßo orientado a DDD\nhttps://www.youtube.com/watch?v=1Lcr2c3MVF4\nPersistence Ignorance | DevIQ\nInfrastructure Ignorance\nHexagonal Architecture, DDD, and Spring | Baeldung\n","permalink":"https://kaue.cat/posts/software-architecture-basics/","summary":"Arquitetura √† nivel de Software: Refere-se √† organiza√ß√£o e defini√ß√£o de regras a serem seguidas no seu projeto em si, seja ele um microservi√ßo, monolito ou qualquer outra parte de uma solu√ß√£o maior, nossa √™nfase est√° no n√≠vel do seu servi√ßo, um servi√ßo seu pode seguir √† risca SOLID, arquitetura hexagonal e uma PoC pode seguir o famoso: faz r√°pido e funcionando.\nDe outro lado, cuidando e decidindo se temos SOA, Microservi√ßos, Monolitos ou qual protocolo de comunica√ß√£o usamos, temos a arquitetura de solu√ß√µes, o que n√£o √© o foco do artigo","title":"Arquitetura de Software para devs: MVC, Hexagonal, DDD"},{"content":"Leitura no Notion: SOLID\nSei que existem 1 milh√£o de posts sobre SOLID, considero esse \u0026ldquo;guia\u0026rdquo; um pouco fora do comum pelo seu aprofundamento, tentei esclarecer todas as d√∫vidas que tinha ou poderia ter e sempre trazer exemplos, al√©m de usar boas refer√™ncias. Espero que esse post seja o seu guia definitivo de SOLID, assim como √© para mim!\nO que √© SOLID? SOLID √© um Acr√¥nimo para 5 boas pr√°ticas e/ou princ√≠pios que envolvem o desenvolvimento de um bom c√≥digo orientado √† objetos, n√£o quero me estender na origem, vamos para os princ√≠pios!\nSingle Responsability Principle O nome, embora auto-explicativo e que muitas vezes levava esse princ√≠pio a ser explicado como ‚ÄúUma classe deve ter uma, e apenas uma responsabilidade‚Äù n√£o √© necessariamente o que voc√™ deve pensar na hora de implement√°-lo. Entenda esse padr√£o como : ‚ÄúUma classe deve ter um, e apenas um motivo para mudar‚Äù. Ou seja, n√£o crie uma classe com a fun√ß√£o de Emitir Nota Fiscal, crie uma classe NotaFiscal, e garanta que apenas coisas que envolvem o dom√≠nio de Nota Fiscal ir√£o altera-l√°, a mudan√ßa da emiss√£o n√£o muda o seu dom√≠nio de Nota Fiscal. Se uma altera√ß√£o na impressora fizer a classe Nota Fiscal ser alterada, algo est√° incorreto.\nA quest√£o principal do SRP √© o motivo para uma classe ser modificada. E esse motivo para mudan√ßa, em geral, est√° relacionado a um grupo de usu√°rios ou stakeholders, que Uncle Bob chama de atores. - Desbravando Solid\nLevando em conta o que dizemos acima, tamb√©m podemos dizer que o SRP pode ser definido por: ‚ÄúUm m√≥dulo deve ser respons√°vel por um , e apenas um ator‚Äù. O ator que se importa com a fun√ß√£o da emiss√£o nota fiscal √© o setor de vendas, o ator que se importa com suas horas extras, o rh, o ator que se importa com salvar no banco por id √© a implementa√ß√£o de persist√™ncia.\nCada \u0026ldquo;interessado\u0026rdquo;, de neg√≥cio ou t√©cnico, faz com que a classe tenha uma responsabilidade diferente.\nIdentificar classes que mudam por diversos motivos (ou atores) √© simples, a coes√£o pode ser uma das m√©tricas utilizadas:\nClasses coesas t√™m uma caracter√≠stica semelhante: os conceitos que essas classes representam estariam relacionados e separ√°-los seria pouco natural. O SRP, no fim das contas, √© uma outra maneira de falar sobre a necessidade de c√≥digo coeso. - Desbravando Solid\nAniche (OOP E SOLID para ninjas) sugere que, para encontrar classes pouco coesas, devemos procurar classes que:\nPossuem muitos m√©todos diferentes. S√£o modificadas com frequ√™ncia. N√£o param nunca de crescer. Outro fator importante √© perceber a duplica√ß√£o (ou pior, repeti√ß√£o) de c√≥digo. Se seu c√≥digo possui partes repetidas diversas vezes, tenha isso como um forte indicativo que essa responsabilidade provavelmente deveria estar encapsulada em algum lugar (e muito provavelmente em uma classe).\nPortanto, se seu sistema pega os dados, busca coisas no banco, salva como ePUB ou PDF, tudo em uma classe s√≥, ele provavelmente n√£o √© coeso e muito menos segue o SRP. Um exemplo disso √© que toda vez que a maneira que um pdf for gerado houver de mudar, voc√™ ter√° que mexer nessa classe principal, e se voc√™ tiver que repetir essa altera√ß√£o em diversos pontos onde o c√≥digo est√° repetido (o que j√° n√£o √© um bom indicador), voc√™ provavelmente ter√° problemas em algum momento (e mesmo que n√£o tenha, sua manuten√ß√£o definitivamente n√£o est√° facilitada).\nCaso real Recentemente ajudei um amigo em um projeto pessoal, onde ele enviava emails para a confirma√ß√£o de cadastro de usu√°rios, todas essas responsabilidades ficavam dentro da mesma classe Usu√°rio (Gerar token, enviar email, registrar usu√°rio). A partir da√≠, trabalhamos para termos um c√≥digo mais coeso, no momento em que um usu√°rio √© registrado, ele envia um evento de registro de usu√°rio (o que √© s√≥ um aviso falando: cadastrei um usu√°rio). Com isso, uma classe chamada enviarEmailListener se prontificava a ouvir eventos de registro e altera√ß√£o de senha de usu√°rio e ela era a respons√°vel por enviar emails. Portanto, com o refactor, a classe de Usu√°rio n√£o se preocupa com o que acontece ap√≥s o registro do usu√°rio, ela apenas notifica que isso aconteceu. Outro ponto de melhoria nisso foi a possibilidade de tornar o envio do email ass√≠ncrono, ent√£o para cadastrar um usu√°rio, n√£o precisavamos esperar o servi√ßo de email fazer sua a√ß√£o, ela √© independente (nesse caso, n√£o fazia sentido ser uma transa√ß√£o, o cadastro de um usu√°rio n√£o depende do email, se um erro ocorrer nessa etapa, ele pode s√≥ pedir outro email)\nNote que se tivermos mais ocasi√µes onde devemos enviar emails de usu√°rio (al√©m de cadastro e altera√ß√£o de emails) podemos apenas adicionar um novo evento a ser ouvido pelo listener e se precisarmos mudar a forma de enviar email, mudamos apenas em um √∫nico m√©todo (o que aumenta MUITO a capacidade de manter o c√≥digo), essa √© a fun√ß√£o do SRP.\nOpen-Closed Principle Software entities \u0026hellip; should be open for extension, but closed for modification.\nA module will be said to be open if it is still available for extension. For example, it should be possible to add fields to the data structures it contains, or new elements to the set of functions it performs.\nEssas cita√ß√µes trazem uma no√ß√£o base do que o OCP quer dizer, nosso c√≥digo deve estar sempre pronto para evoluir. e de maneira natural, n√£o devemos sentir a necessidade de modificar muitos arquivos diferentes, ou mesmo procurar (usando o CTRL+F, por exemplo) os lugares que devem ser alterados.\nA segunda parte diz sobre ser fechada para modifica√ß√£o. nesse aspecto, podemos entender que elas n√£o devem ter seu comportamento alterado a todo momento.\nUm exemplo public class CalculadoraDePrecos { public double calcula(Compra produto) { Frete correios = new Frete(); double desconto = 0.0; // Inicialize desconto com um valor padr√£o if (REGRA 1) { // faz algo } if (REGRA 2) { // faz algo } return produto.getValor() * (1 - desconto) + frete; } } Note que sempre que adicionarmos regras de frete, nosso c√≥digo precisar√° alterar a classe calculadora de pre√ßos, incluindo um novo IF, ou seja, a classe que implementar a regra de frete est√° acoplada √† Calculadora de Pre√ßos\nUma segunda implementa√ß√£o comum √© colocar os ifs dentro das classes espec√≠ficas. Por exemplo, a classe Frete passaria a ter as diferentes regras de neg√≥cio (os mesmos if-else). Apesar de ficar melhor, continua claro que n√£o √© a melhor abordagem.\nMelhorando Se temos diferentes regras de desconto e de frete, basta criarmos interfaces que as representam:\npublic interface TabelaDePreco { double descontoPara(double valor); } public class TabelaDePreco1 implements TabelaDePreco { } public class TabelaDePreco2 implements TabelaDePreco { } public class TabelaDePreco3 implements TabelaDePreco { } public interface ServicoDeEntrega { double para(String cidade); } public class Frete1 implements ServicoDeEntrega {} public class Frete2 implements ServicoDeEntrega {} public class Frete3 implements ServicoDeEntrega {} \u0026ldquo;Veja que essa simples mudan√ßa altera toda a maneira de se lidar com a classe. Com ela \u0026lsquo;aberta\u0026rsquo;, ou seja, recebendo as depend√™ncias pelo construtor, podemos passar a implementa√ß√£o concreta que quisermos para ela. Se passarmos a implementa√ß√£o TabelaDePreco1, e invocarmos o m√©todo calcula(), o resultado ser√° um; se passarmos a implementa√ß√£o TabelaDePreco2 e invocarmos o mesmo m√©todo, o resultado ser√° outro.\u0026rdquo; (ANICHE, 2015).\npublic class CalculadoraDePrecos { private TabelaDePreco tabela; private ServicoDeEntrega entrega; public CalculadoraDePrecos(TabelaDePreco tabela, ServicoDeEntrega entrega) { this.tabela = tabela; this.entrega = entrega; } public double calcula(Compra produto) { double desconto = tabela.descontoPara(produto.getValor()); double frete = entrega.para(produto.getCidade()); return produto.getValor() * (1 - desconto) + frete; } } Note que aqui trabalhamos tamb√©m com a invers√£o de depend√™ncias (DIP), o ‚ÄúD‚Äù, do SOLID.\n\u0026ldquo;Se o OCP declara\to objetivo de\tuma\tarquitetura OO, o DIP declara o seu mecanismo\tfundamental.\u0026rdquo;\nSe voc√™ ainda n√£o leu sobre o DIP, continue lendo o post, mais tarde revisite esse ponto, vai fazer sentido üòÉ\nAbstra√ß√µes e Capacidade de Extens√£o \u0026ldquo;O que discutimos aqui, de certa forma, mistura-se com a discuss√£o do cap√≠tulo anterior sobre estabilidade e invers√£o de depend√™ncias. As interfaces (abstra√ß√µes) TabelaDePreco e ServicoDeEntrega tendem a ser est√°veis. A CalculadoraDePrecos √© uma implementa√ß√£o mais inst√°vel e que s√≥ depende de abstra√ß√µes est√°veis. Pensar em abstra√ß√µes nos ajuda a resolver o problema do acoplamento e, de quebra, ainda nos ajuda a ter c√≥digos facilmente extens√≠veis. Isso √© programar orientado a objetos. √â lidar com acoplamento, coes√£o, pensando em abstra√ß√µes para nossos problemas. Quando se tem uma boa abstra√ß√£o, √© f√°cil evoluir o sistema. Seu sistema deve evoluir por meio de novas implementa√ß√µes dessas abstra√ß√µes, previamente pensadas, e n√£o por meio de diversos ifs espalhados por todo o c√≥digo.\u0026rdquo; (ANICHE, 2015).\nDesign Pattern: Command N√£o vou me aprofundar em patterns nesse post, mas acho legal repassar alguns exemplos que vi no material base\npublic class EmissorNotaFiscal\t{ private\tRegrasDeTributacao\ttributacao; private\tLegislacaoFiscal\tlegislacao; private\tList\u0026lt;AcaoPosEmissao\u0026gt;\tacoes; //... public\tNotaFiscal\tgera(Fatura\tfatura) { List\u0026lt;Imposto\u0026gt;\timpostos\t=\ttributacao.verifica(fatura); List\u0026lt;Isencao\u0026gt;\tisencoes\t=\tlegislacao.analisa(fatura); //\tm√©todo\tauxiliar NotaFiscal\tnota\t=\taplica(impostos,\tisencoes); //\tmodificado for\t(AcaoPosEmissao\tacao:\tacoes)\t{ acao.faz(nota); } return\tnota; } Exemplo do livro Desbravando Solid (AQUILES, 2022)\nNote que √© muito f√°cil adicionar novos comportamentos depois de uma nota fiscal ser emitida, podemos simplesmente adicionar um objeto na lista de a√ß√µes, isso caracteriza o padr√£o Command.\nRecomendo a leitura mais aprofundada em: https://refactoring.guru/design-patterns/command\nDesign Pattern: Strategy Exemplo de: https://en.wikipedia.org/wiki/Strategy_pattern\n\u0026ldquo;Strategy permite que o algoritmo varie independentemente dos clientes que o utilizam. Strategy √© um dos padr√µes inclu√≠dos no influente livro \u0026ldquo;Design Patterns\u0026rdquo; de Gamma et al., que popularizou o conceito de usar padr√µes de design para descrever como projetar software orientado a objetos flex√≠vel e reutiliz√°vel. Adiar a decis√£o sobre qual algoritmo usar at√© o tempo de execu√ß√£o permite que o c√≥digo chamador seja mais flex√≠vel e reutiliz√°vel.\u0026rdquo; https://en.wikipedia.org/wiki/Strategy_pattern\npublic interface IComportamentoDeFreio { public void frear(); } public class FreioComABS implements IComportamentoDeFreio { public void frear() { System.out.println(\u0026#34;Freio com ABS aplicado\u0026#34;); } } public class FreioSimples implements IComportamentoDeFreio { public void frear() { System.out.println(\u0026#34;Freio simples aplicado\u0026#34;); } } /* Cliente que pode usar os algoritmos acima de forma intercambi√°vel */ public abstract class Carro { private IComportamentoDeFreio comportamentoDeFreio; public Carro(IComportamentoDeFreio comportamentoDeFreio) { this.comportamentoDeFreio = comportamentoDeFreio; } public void aplicarFreio() { comportamentoDeFreio.frear(); // note que usamos a interface! } public void setComportamentoDeFreio(IComportamentoDeFreio tipoDeFreio) { this.comportamentoDeFreio = tipoDeFreio; // podemos mudar livremente! } } public class SUV extends Carro { public SUV() { super(new FreioComABS()); } } public class CarExample { public static void main(final String[] arguments) { Carro suvCar = new SUV(); suvCar.frear(); // freio com abs suvCar.setBrakeBehavior( new FreioSimples() ); suvCar.frear(); // freia, mas sem abs. } } Nesse exemplo, note que definimos uma interface comum, a qual um carro se acopla, podemos trocar a implementa√ß√£o dessa interface livremente, tamb√©m ajuda no OCP.\nLiskov Substitution Principle Fun√ß√µes que utilizam ponteiros ou refer√™ncias para classes base devem ser capazes de usar objetos de classes derivadas sem saber disso\nNesse caso, vamos come√ßar com cita√ß√µes:\n\u0026ldquo;Se um gato possui ra√ßa e patas, e um cachorro possui ra√ßa, patas e tipoDoPelo, logo Cachorro extends Gato? Pode parecer engra√ßado, mas √© (\u0026hellip;) heran√ßa por pregui√ßa, por comodismo, porque vai dar uma ajudinha. A rela√ß√£o ‚Äú√© um‚Äù n√£o se encaixa aqui, e vai nos gerar problemas.\u0026rdquo; Paulo Silveira, no artigo Como n√£o aprender orienta√ß√£o a objetos: Heran√ßa (SILVEIRA, 2006)\nO Princ√≠pio da Substitui√ß√£o de Liskov (LSP) estabelece uma diretriz fundamental : Ele afirma que objetos de classes derivadas ou subclasses devem poder ser usados no lugar de objetos da classe base ou superclasse sem quebrar o comportamento esperado do programa. Em outras palavras, uma classe derivada deve estender ou especializar o comportamento da classe base sem modificar seu contrato.\n\u0026ldquo;A ideia intuitiva de um subtipo √© aquela cujos objetos fornecem todo o comportamento de objetos de outro tipo (o supertipo) mais algo extra.\u0026rdquo; Data Abstraction and Hierarchy (LISKOV, 1988)\nImagine um exemplo em que temos uma classe base chamada Animal e classes derivadas, como Cachorro e Gato. O LSP nos orienta a garantir que qualquer c√≥digo que funcione com objetos Animal tamb√©m funcione corretamente com objetos Cachorro e Gato. Isso significa que as subclasses n√£o devem introduzir comportamentos que contradigam as expectativas estabelecidas pela classe base. Ou seja, se todo animal implementa o m√©todo comer, classes derivadas desse Animal devem tamb√©m incluir o m√©todo comer, que funciona como esperado. (Se seu animal n√£o come, reveja suas abstra√ß√µes, o pr√≥ximo princ√≠pio, ISP, pode ser √∫til aqui!)\nFavore√ßa composi√ß√£o sobre Heran√ßa Essa √© uma frase amplamente falada no meio da computa√ß√£o, algo que voc√™ j√° ouviu milhares de vezes, seja em artigos, livros como o Design Patterns, do GoF ou at√© mesmo v√≠deos no youtube, mas por qu√™?\nEm vez de herdar comportamentos de uma classe base, prefira compor objetos que fornecem os comportamentos necess√°rios. O princ√≠pio de design normalmente come√ßa pela defini√ß√£o de interfaces que representam o comportamento que o sistema deve exibir, as classes recebem objetos dessas interfaces e fazem os comportamentos a partir da√≠\nBenef√≠cios Favorecer a composi√ß√£o proporciona maior flexibilidade no design. √â mais natural construir classes de dom√≠nio de neg√≥cios a partir de v√°rios componentes do que tentar encontrar pontos em comum entre eles e criar uma √°rvore de heran√ßa. Por exemplo, um pedal de acelerador e um volante t√™m poucos tra√ßos em comum, mas s√£o componentes vitais em um carro.\nAl√©m disso, a composi√ß√£o oferece um dom√≠nio de neg√≥cios mais est√°vel, pois est√° menos sujeito √†s peculiaridades dos membros da fam√≠lia. Em outras palavras, √© melhor compor o que um objeto pode fazer (tem-um) do que estender o que ele √© (√©-um).\nDrawbacks ‚ÄúComposition is good until it is not‚Äù - O uso excessivo de composi√ß√£o pode levar a classes superlotadas e complexas, mas de maneira geral, se voc√™ mantiver : A divis√£o de responsabilidades, O acoplamento controlado, Uso de Design Patterns adequados, isso provavelmente n√£o ser√° um problema.\nInterface Segregation Principle ‚Äú*Make fine grained interfaces that are client specific.‚Äù ‚ÄùClients should not be forced to depend upon interfaces that they do not use‚Äù\nUncle Bob*\nO Interface Segregation Principle (ISP) basicamente nos orienta a escrever interfaces coesas, em que seus m√©todos conversem entre si e sempre sejam implementados.\nVamos a um exemplo:\ninterface Imposto { NotaFiscal geraNota(); double imposto(double valorCheio); } Imagine que em algum momento da exist√™ncia da sua aplica√ß√£o, um imposto n√£o gere nota fiscal, nesse caso, ele ir√° jogar uma exception? retornar nulo? √â exatamente esse tipo de situa√ß√£o que o ISP quer que voc√™ evite passar, pois ambas as op√ß√µes anteriores s√£o ruins e configuram quebra de contrato.\nNesse caso anterior, temos uma interface n√£o muito coesa, com dois comportamentos distintos (isso se d√° pois um imposto nem sempre gera nota), nesse caso, o mais adequado seria dividi-la em duas interfaces distintas, como por exemplo:\ninterface Tributavel{ double imposto(double valorCheio); } interface GeradorNF{ NotaFiscal geraNota(); } Com isso, podemos fazer com que nossas classes sejam constru√≠das por composi√ß√£o de interfaces que √†s sirvam perfeitamente, como:\nclass ImpostoGeraNota implements Tributavel, GeradorNF{ // os dois m√©todos aqui } class Imposto implements Tributavel{ // implementa imposto(double valorCheio) } Many client specific interfaces are better than one general purpose interface\nUncle Bob\nAl√©m disso, muitas vezes queremos apenas parte dos atributos ou comportamentos de uma classe, e\nSe voc√™ tiver uma classe que tenha v√°rios clientes, em vez de carregar a classe com todos os m√©todos de que os clientes precisam, crie interfaces espec√≠ficas para cada cliente e implemente-as na classe.\nDesign Principles and Design Patterns¬†(MARTIN, 2000)\nCita√ß√£o retirada da Refer√™ncia da Caelum\nPor que? Mas Kau√™, por qu√™ √© uma boa pr√°tica criarmos interfaces magras? Como disse anteriormente, a palavra chave √© coes√£o, a coes√£o √© o elemento chave que garante a estabilidade de nossas interfaces, e se essa interface realmente precisar ser mudada, apenas os membros que implementam ela ter√£o sua implementa√ß√£o alterada. No final das contas, o ISP √© sobre avaliarmos a coes√£o das nossas interfaces,\nLembre-se tamb√©m que devemos sempre nos acoplar a membros os mais est√°veis poss√≠veis! Nesse caso, tanto Tributavel quanto GeradorNF s√£o mais interfaces coesas e est√°veis.\n‚ÄúClasses que dependem de interfaces leves sofrem menos com mudan√ßas em outros pontos do sistema. Novamente, elas s√£o pequenas, portanto, t√™m poucas raz√µes para mudar.‚Äù - Aniche, M. OOP E SOLID para Ninjas.\nDependency Inversion Principle Depend upon Abstractions. Do not depend upon concretions. - Design Principles and Design Patterns, Bob Martin.\nAqui, vamos come√ßar com conceitos bem fundamentados dentro da computa√ß√£o\n‚ÄúDepender de abstra√ß√µes e n√£o de implementa√ß√µes‚Äù - Bob Martin ‚ÄùPrograme voltado √† interface, n√£o √† implementa√ß√£o‚Äù - Design Patterns, GoF\nMas o que isso significa? A ideia aqui √© que abstra√ß√µes e interfaces definem contratos est√°veis para nossos sistemas, classes e comportamentos base do sistema, ou seja, n√£o-vol√°teis, n√£o devem ser impactados por implementa√ß√£o de m√≥dulos as quais elas dependem.\nSua classe que cuida do registro do usu√°rio n√£o deve depender da implementa√ß√£o que o envio de email possui, voc√™ n√£o deve ter imports de uma biblioteca espec√≠fica dentro de uma classe que cuida de regras de neg√≥cio. Nesse caso, voc√™ dever√° usar abstra√ß√£o, por exemplo, EnviadorEmail e usar√° algum m√©todo dela que encapsule detalhes de implementa√ß√£o\nVamos ver um exemplo bom:\npublic interface EnviadorEmail { void enviarEmail(String destinatario, String mensagem); } // em seu pr√≥prio arquivo: public class RegistrarUsuario { private final EnviadorEmail enviadorEmail; public RegistrarUsuario (EnviadorEmail enviadorEmail) { this.enviadorEmail = enviadorEmail; } public void registrarUsuario(String nome, String email) { // L√≥gica para registrar o usu√°rio // Envio de e-mail de boas-vindas String mensagem = \u0026#34;Bem-vindo, \u0026#34; + nome + \u0026#34;!\u0026#34;; enviadorEmail.enviarEmail(email, mensagem); } } No c√≥digo acima, podemos mudar a implementa√ß√£o do provedor de email e n√£o precisaremos mexer na classe RegistrarUsu√°rio, perfeito!\nUm pouco mais concreto: Vamos dar algumas defini√ß√µes que podem ajudar a voc√™ seguir como guideline para garantir que seu c√≥digo est√° desacoplado\nM√≥dulos de Alto N√≠vel: S√£o m√≥dulos que implementam regras de neg√≥cio, devem ser reutiliz√°veis, est√°veis e inafetados por mudan√ßas em m√≥dulos de baixo n√≠vel.\nM√≥dulos de Baixo N√≠vel: S√£o m√≥dulos que dizem respeito √† detalhes de implementa√ß√£o, muitas vezes, agem como utilit√°rios para m√≥dulos de alto n√≠vel, mas devem ser utilizados atrav√©s de uma barreira de abstra√ß√£o sempre que fizer sentido\nPortanto, nossa ‚Äú‚Äùregra‚Äù‚Äù √©:\nM√≥dulos de Alto n√≠vel n√£o devem depender explicitamente de m√≥dulos de baixo n√≠vel, e sim de abstra√ß√µes.\nE de onde vem o nome de ‚ÄúInvers√£o de Depend√™ncia‚Äù? No exemplo acima √© claro, RegistrarUsu√°rio, uma classe de alto n√≠vel, depende do Enviador de Email, que utiliza a depend√™ncia do AWS SES, no final das contas, RegistrarUsu√°rio tamb√©m est√° acoplado ao SES.\nNesse caso, note que as depend√™ncias foram invertidas.\nNem toda interface √© de alto n√≠vel A linguagem Java est√° cheia de interfaces e abstra√ß√µes, mas muitas vezes essas abstra√ß√µes atuam diretamente sobre detalhes de implementa√ß√£o, como java.sql.Connection do JDBC, elas s√£o interfaces para mecanismos de entrega, detalhes t√©cnicos e uma classe que depende delas, n√£o necessariamente segue o dip, mas isso n√£o √© um problema, pois essas interfaces s√£o est√°veis\nDicas gerais N√£o precisamos implementar e criar uma depend√™ncia diretamente com a classe EnviadorEmailX ou EnviadorEmailY, nesse caso, podemos usar o design pattern Factory e abstrair essa depend√™ncia, podemos fazer isso dentro da pr√≥pria interface com java. public interface EnviadorEmail { void enviarEmail(String destinatario, String mensagem); static EnviadorEmail criarEnviadorEmailPadrao() { return new EnviadorEmailPadrao(); } static EnviadorEmail criarEnviadorEmailAlternativo() { return new EnviadorEmailAlternativo(); } } // Em outra classe public class Main { public static void main(String[] args) { EnviadorEmail enviadorPadrao = EnviadorEmail.criarEnviadorEmailPadrao(); EnviadorEmail enviadorAlternativo = EnviadorEmail.criarEnviadorEmailAlternativo(); // Use as inst√¢ncias de EnviadorEmail conforme necess√°rio enviadorPadrao.enviarEmail(\u0026#34;destinatario@example.com\u0026#34;, \u0026#34;Mensagem de teste\u0026#34;); enviadorAlternativo.enviarEmail(\u0026#34;outrodestinatario@example.com\u0026#34;, \u0026#34;Outra mensagem de teste\u0026#34;); } } Em java, se definirmos interfaces comuns para diversos provedores de notifica√ß√£o como enviadorMensagem, que ser para tanto enviadorEmail quanto enviadorSMS, podemos fazer com que o spring nos entregue uma lista com todos os Beans anotados com @Component que satisfa√ßa essa interface (Podemos usar o applicationContext para isso), simplificando o c√≥digo iterando pela lista e usando o seu m√©todo de enviar. @Component public class EnviadorEmail implements EnviadorMensagem { @Override public void enviarMensagem(String destinatario, String mensagem) { // abstraido :p } } @Component public class EnviadorSMS implements EnviadorMensagem { // voc√™ j√° sabe } Importante!! Obrigado pela leitura, espero que tenha sido √∫til, de verdade, tentei trazer exemplos de c√≥digo e bastante cita√ß√µes, mas a maioria desse tipo de conte√∫do √© fonte dos livros da casa do c√≥digo e caelum, mas de maneira mais enxuta e com minhas palavras, recomendo fortemente a compra dos dois livros abaixo.\nSe encontrar erros ortogr√°ficos ou algo estranho, me envie uma mensagem ou comente aqui, arrumarei assim que poss√≠vel. N√£o farei uma rigorosa verifica√ß√£o antes de postar aqui.\nRefer√™ncias https://www.amazon.com.br/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8\nhttps://en.wikipedia.org/wiki/Composition_over_inheritance\nhttps://www.casadocodigo.com.br/products/livro-oo-solid\nhttps://www.casadocodigo.com.br/products/livro-desbravando-solid\nhttps://github.com/caelum/apostila-oo-avancado-em-java/blob/master/09-interface-segregation-principle.md\nhttps://en.wikipedia.org/wiki/Strategy_pattern\nhttps://refactoring.guru/design-patterns/command\n","permalink":"https://kaue.cat/posts/solid/","summary":"Leitura no Notion: SOLID\nSei que existem 1 milh√£o de posts sobre SOLID, considero esse \u0026ldquo;guia\u0026rdquo; um pouco fora do comum pelo seu aprofundamento, tentei esclarecer todas as d√∫vidas que tinha ou poderia ter e sempre trazer exemplos, al√©m de usar boas refer√™ncias. Espero que esse post seja o seu guia definitivo de SOLID, assim como √© para mim!\nO que √© SOLID? SOLID √© um Acr√¥nimo para 5 boas pr√°ticas e/ou princ√≠pios que envolvem o desenvolvimento de um bom c√≥digo orientado √† objetos, n√£o quero me estender na origem, vamos para os princ√≠pios!","title":"SOLID! Um Post Aprofundado"},{"content":"Texto necessita outra revis√£o.\nAprofundando Nota: Nesse momento, entraremos um pouco mais em detalhes sobre como o protocolo AMQP funciona, escrevi um ‚Äúguia‚Äù bem b√°sico sobre propriedades do protocolo, se quiser conferir, pode ver aqui :)\nmensageria.pdf\nOu nesse link\nContexto O Spring AMQP consiste em dois m√≥dulos principais: spring-amqp e spring-rabbit. O ‚Äòspring-amqp‚Äô cont√©m o pacote org.springframework.amqp.core, que trata das principais abstra√ß√µes definidas no protocolo AMQP (RabbitMQ √© um broker, que implementa esse protocolo), esse pacote n√£o se baseia em nenhuma biblioteca de clientes nem implementa√ß√£o de broker.\nEssas abstra√ß√µes ent√£o s√£o implementadas pelos m√≥dulos espec√≠ficos dos brokers (spring-rabbit). Teoricamente, como o AMQP √© opera em n√≠vel de protocolo, voc√™ poderia utilizar o cliente do rabbit com outro broker, mas isso n√£o √© oficialmente suportado.\nA mensagem A mensagem ****definida no protocolo amqp √© um conjunto de bytes e propriedades, passados separadamente. Para tornar o uso mais f√°cil, dentro do java juntamos isso em uma abstra√ß√£o chamada Message\npublic class Message { private final MessageProperties messageProperties; private final byte[] body; public Message(byte[] body, MessageProperties messageProperties) { this.body = body; this.messageProperties = messageProperties; } public byte[] getBody() { return this.body; } public MessageProperties getMessageProperties() { return this.messageProperties; } } A exchange A exchange √© uma outra abstra√ß√£o simples, √© basicamente o centro de distribui√ß√£o de mensagens, que envia as mensagens de acordo com suas diretrizes:\npublic interface Exchange { String getName(); String getExchangeType(); boolean isDurable(); boolean isAutoDelete(); Map\u0026lt;String, Object\u0026gt; getArguments(); } Os tipos b√°sicos de exchange s√£o: direct, topic, fanout e headers. Voc√™ pode encontrar implementa√ß√µes para cada um dos tipos no pacote core.\nA¬†Topic¬†exchange supports bindings with routing patterns that may include the \u0026lsquo;*\u0026rsquo; and \u0026lsquo;#\u0026rsquo; wildcards for \u0026rsquo;exactly-one\u0026rsquo; and \u0026lsquo;zero-or-more\u0026rsquo;, respectively. The¬†Fanout¬†exchange publishes to all queues that are bound to it without taking any routing key into consideration.\nQueues A classe Queue¬†tamb√©m representa uma abstra√ß√£o desse tipo no protocolo:\npublic class Queue { private final String name; private volatile boolean durable; private volatile boolean exclusive; private volatile boolean autoDelete; private volatile Map\u0026lt;String, Object\u0026gt; arguments; /** * The queue is durable, non-exclusive and non auto-delete. * * @param name the name of the queue. */ public Queue(String name) { this(name, true, false, false); } // Getters e Setters omitidos } Bindings Bindings s√£o a rela√ß√£o entre filas e exchanges!\nnew Binding(someQueue, someDirectExchange, \u0026#34;foo.bar\u0026#34;); // direct exchange, routing keys fixas new Binding(someQueue, someTopicExchange, \u0026#34;foo.*\u0026#34;); // topic exchange, usando wildcard new Binding(someQueue, someFanoutExchange); // fanout Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with(\u0026#34;foo.*\u0026#34;); // BindingBuilder √© a maneira bonitinha, eu gosto, mas importa est√°tico! Definindo Exchanges e Bindings customizadas J√° vimos nos exemplos anteriores como as exchanges, bindings e queues s√£o criadas, a partir de agora, s√≥ criar!\nNossas configura√ß√µes, ao inv√©s de s√≥ possuir bean de Queue, agora incluir√£o Exchangese Bindings\n@Configuration @Slf4j @RequiredArgsConstructor public class RabbitMqConfiguration { private final TicketQueueProperties ticketQueueProperties; @Bean public Queue queue(){ log.info(\u0026#34;Looking for queue: {}\u0026#34;, ticketQueueProperties.getName()); return new Queue(ticketQueueProperties.getName(), true); } @Bean Exchange ticketDirectExchange(){ final String EXCHANGE_NAME = \u0026#34;ticket\u0026#34;; log.info(\u0026#34;Creating exchange: ticket-exchange\u0026#34;); return new DirectExchange(EXCHANGE_NAME); } @Bean Binding ticketBinding(){ log.info(\u0026#34;Create ticket binding\u0026#34;); return BindingBuilder.bind(queue()).to(ticketDirectExchange()).with(ticketQueueProperties.getName()).noargs(); } } Perfeito, j√° vimos nossa exchange funcionando bonito! Tudo pronto!\nS√≥ que n√£o! Lembre-se que o nosso publisher est√° enviando mensagens com a routing key correta, mas para a exchange errada, vamos mudar o c√≥digo para o seguinte:\nrabbitTemplate.convertAndSend(\u0026#34;direct.ticket\u0026#34;,ticketQueueProperties.getName(),event.name()); Aqui dever√≠amos puxar esse nome da nossa ideal TicketQueueProperties :) para evitar esse spaghetti Passando Objetos - Message Converters O AmqpTemplate tamb√©m define v√°rios m√©todos para enviar e receber mensagens que, no fim das contas, delegam tarefas para um MessageConverter. O MessageConverter fornece um m√©todo √∫nico para cada dire√ß√£o: um para converter para um Message e outro para converter a partir de um Message.\nDefini√ß√£o da interface MessageConverter:\npublic interface MessageConverter { Message toMessage(Object object, MessageProperties messageProperties) throws MessageConversionException; Object fromMessage(Message message) throws MessageConversionException; } SimpleMessageConverter A implementa√ß√£o padr√£o do strategy MessageConverter √© chamada de SimpleMessageConverter. Este √© o conversor usado por uma inst√¢ncia de RabbitTemplate se voc√™ n√£o configurar explicitamente uma alternativa.\nConverts a String to a¬†[TextMessage](https://jakarta.ee/specifications/platform/9/apidocs/jakarta/jms/TextMessage.html), a byte array to a¬†[BytesMessage](https://jakarta.ee/specifications/platform/9/apidocs/jakarta/jms/BytesMessage.html), a Map to a¬†[MapMessage](https://jakarta.ee/specifications/platform/9/apidocs/jakarta/jms/MapMessage.html), and a Serializable object to a¬†[ObjectMessage](https://jakarta.ee/specifications/platform/9/apidocs/jakarta/jms/ObjectMessage.html)¬†(or vice versa).\nTrocando o Conversor Para trabalhar com objetos serializados e desserializados para JSON, vamos usar o Jackson2JsonMessageConverter.\n@Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } Colocaremos isso tanto no consumer quanto no producer :)\nDeclarables, Defini√ß√£o Din√¢mica e Declarativa de Filas Falamos anteriormente do nossoTicketQueueProperties , que poder√≠amos melhor√°-lo, √© o que vamos fazer, na realidade, vamos substitu√≠-lo.\nPrimeiro de tudo, vamos definir um formato declarativo para filas, exchanges e bindings que nos agrade, para mim:\nbroker: queues: ticket: name: default.ticket exchanges: ticket: name: direct.ticket type: direct bindings: ticket: exchange: direct.ticket queue: default.ticket routingKey: default.ticket Criando um ConfigurationProperties adequado A partir disso, vamos mapear essas propriedades em classes de uma maneira adequada. Chamarei a classe de BrokerConfigurationProperties:\npackage com.kaue.ticketservice.infrastructure.properties; import jakarta.validation.constraints.NotEmpty; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import java.util.Map; import lombok.Data; @Configuration @ConfigurationProperties(prefix = \u0026#34;broker\u0026#34;) @Data public class BrokerConfigurationProperties { private Map\u0026lt;String, QueueProperties\u0026gt; queues; private Map\u0026lt;String, ExchangeProperties\u0026gt; exchanges; private Map\u0026lt;String, BindingProperties\u0026gt; bindings; @Data public static class QueueProperties { @NotEmpty private String name; } @Data public static class ExchangeProperties { @NotEmpty private String name; private String type; } @Data public static class BindingProperties { @NotEmpty private String exchange; @NotEmpty private String queue; @NotEmpty private String routingKey; } } Possu√≠mos 3 maps, estruturas que linkam uma chave √† sua correspondente configura√ß√£o, Queue, Exchange ou Binding Properties. Fazemos o mapeamento padr√£o, usando : @ConfigurationProperties(prefix = \u0026quot;broker\u0026quot;), at√© aqui, sem segredos üôÇ Transformando as propriedades em objetos! A partir de agora, o terceiro passo pode parecer simples, devemos criar beans a partir das propriedades, isso n√£o √© um problema, pelo menos n√£o se quisermos definir os Beans da maneira que fizemos antes, apesar disso, se quisermos definir uma lista de Queues, Exchanges e Bindings, devemos usar a classe Declarables, e prover um bean para ela.\nDeclarables: ‚Äú‚Ä¶Used to declare multiple objects on the broker using a single bean declaration for the collection.‚Äù\n@Bean public Declarables es() { return new Declarables( new DirectExchange(\u0026#34;e2\u0026#34;, false, true), new DirectExchange(\u0026#34;e3\u0026#34;, false, true)); } @Bean public Declarables qs() { return new Declarables( new Queue(\u0026#34;q2\u0026#34;, false, false, true), new Queue(\u0026#34;q3\u0026#34;, false, false, true)); } @Bean public Declarables bs() { return new Declarables( new Binding(\u0026#34;q2\u0026#34;, DestinationType.QUEUE, \u0026#34;e2\u0026#34;, \u0026#34;k2\u0026#34;, null), new Binding(\u0026#34;q3\u0026#34;, DestinationType.QUEUE, \u0026#34;e3\u0026#34;, \u0026#34;k3\u0026#34;, null)); } O exemplo acima, da documenta√ß√£o de refer√™ncia do spring, √© uma boa forma de exemplificar o uso mais simples de Declarables, vamos ver minha implementa√ß√£o em particular, que adiciona declarables de acordo com a BrokerConfigurationProperties\npackage com.kaue.ticketservice.infrastructure.configuration; // ... ommitted /** * This classes creates all queues, exchanges and bindings based on application.yaml when they\u0026#39;re needed (called by a consumer or posted a message into). */ @Configuration @Slf4j @RequiredArgsConstructor public class RabbitMqConfiguration { private final BrokerConfigurationProperties brokerConfig; private final List\u0026lt;Queue\u0026gt; definedQueues = new ArrayList\u0026lt;\u0026gt;(); private final List\u0026lt;Exchange\u0026gt; definedExchanges = new ArrayList\u0026lt;\u0026gt;(); @Bean public Declarables queues() { if (brokerConfig == null || brokerConfig.getQueues() == null) { return new Declarables(); // Return an empty list if no queues are configured } var queueList = brokerConfig.getQueues().values().stream() .filter(Objects::nonNull) .map(queueProperties -\u0026gt; new Queue(queueProperties.getName(), true)) .toList(); definedQueues.addAll(queueList); log.info(\u0026#34;Declared queues\u0026#34;); return new Declarables(queueList); } @Bean public Declarables exchanges() { if (brokerConfig == null || brokerConfig.getExchanges() == null) { return new Declarables(); // Return an empty list if no exchanges are configured } var exchangesList = brokerConfig.getExchanges().values().stream() .filter(Objects::nonNull) .map(exchangeProperties -\u0026gt; new DirectExchange(exchangeProperties.getName())) // todo use correct exchange type .toList(); definedExchanges.addAll(exchangesList); log.info(\u0026#34;Declared exchanges\u0026#34;); return new Declarables(exchangesList); } @Bean public Declarables bindings() { if (brokerConfig == null || brokerConfig.getBindings() == null) { return new Declarables(); } var bindingsList = brokerConfig.getBindings().values().stream() .map(bindingProperties -\u0026gt; { log.info(\u0026#34;Creating binding between exchange {} and queue {} with routing key {}\u0026#34;, bindingProperties.getExchange(), bindingProperties.getQueue(), bindingProperties.getRoutingKey()); Queue queue = findQueueByName(bindingProperties.getQueue()); Exchange exchange = findExchangeByName(bindingProperties.getExchange()); return BindingBuilder.bind(queue) .to(exchange) .with(bindingProperties.getRoutingKey()) .noargs(); }) .toList(); return new Declarables(bindingsList); } private Queue findQueueByName (String queueName){ return definedQueues.stream() .filter(queue -\u0026gt; queueName.equals(queue.getName())) .findFirst() .orElse(null); } private Exchange findExchangeByName (String exchangeName){ return definedExchanges.stream() .filter(exchange -\u0026gt; exchangeName.equals(exchange.getName())) .findFirst() .orElse(null); } } Embora grande, a implementa√ß√£o √© relativamente simples, usamos streams para transformar as propriedades em classes reais e retornamos o Declarable como um Bean, um objeto gerenciado pelo spring.\nPoderes de RabbitListener No Spring, quando um m√©todo anotado como listener joga uma exception, as mensagens podem ser inseridas novamente na fila e reprocessadas, descartadas ou colocadas em uma Dead Letter Queue. Nada √© devolvido ao emissor da mensagem.\nError Handling Na vers√£o 2.0 do Spring AMQP em diante, @RabbitLisetener tem 2 atributos: errorHandler¬†ereturnExceptions, mas eles n√£o s√£o configurados por padr√£o.\nVoc√™ pode usar o errorHandler¬†para prover um Bean de RabbitListenerErrorHandler. Essa interface funcional tem um m√©todo:\n@FunctionalInterface public interface RabbitListenerErrorHandler { Object handleError(Message amqpMessage, org.springframework.messaging.Message\u0026lt;?\u0026gt; message, ListenerExecutionFailedException exception) throws Exception; } Aqui, por exemplo, poder√≠amos dizer que exce√ß√µes de servi√ßo ou fatais jogam exce√ß√µes AmqpRejectAndDontRequeueException, para evitar requeue.\nAs you can see, you have access to the raw message received from the container, the spring-messaging¬†Message\u0026lt;?\u0026gt;¬†object produced by the message converter, and the exception that was thrown by the listener (wrapped in a¬†ListenerExecutionFailedException). The error handler can either return some result (which is sent as the reply) or throw the original or a new exception (which is thrown to the container or returned to the sender, depending on the¬†returnExceptions¬†setting).\nA cita√ß√£o acima comenta uma maneira de enviar exceptions de volta ao sender, se te interessar, pode ver aqui\nRetries! Podemos customizar e modificar configura√ß√µes de retry indicadas dentro do nosso projeto, para isso usaremos o projeto spring-retry, vamos ver uma configura√ß√£o simples no Bean do RabbitTemplate:\n@Bean public RabbitTemplate rabbitTemplate() { RabbitTemplate template = new RabbitTemplate(connectionFactory()); RetryTemplate retryTemplate = RetryTemplate.builder() .maxAttempts(3) .fixedBackoff(1000) .retryOn(RemoteAccessException.class) .build(); retryTemplate.execute(ctx -\u0026gt; { // ... do something }); template.setRetryTemplate(retryTemplate); return template; } Para mais informa√ß√µes, veja o [spring-retry](https://github.com/spring-projects/spring-retry#using-retrytemplate)\nDead Letters When a listener throws an exception, it is wrapped in a¬†ListenerExecutionFailedException. Normally the message is rejected and requeued by the broker. Setting¬†defaultRequeueRejected¬†to¬†false¬†causes messages to be discarded (or routed to a dead letter exchange).\nVamos tentar seguir o que o coment√°rio acima da documenta√ß√£o do spring diz:\nspring: rabbitmq : ... adresses e outras configs listener: simple: default-requeue-rejected: false Depois dessa configura√ß√£o, as mensagens quando possuem um erro s√£o DELETADAS, desabilitando os retries. Isso provavelmente n√£o √© o que queremos, por isso, vamos estudar as DLQ‚Äôs.\nDead Letter Queues (DLQ) s√£o filas que possuem mensagens que tiveram sua execu√ß√£o falhada em algum momento, o comportamento das DLQ‚Äôs pode ser configurado no pr√≥prio broker.\nDead Letter Queues s√£o √∫teis em sistemas mais cr√≠ticos, onde necessitamos que um job rode de qualquer forma, onde podemos jogar mensagens de DLQ‚Äôs na exchange padr√£o novamente, ou pelo menos entendermos o porqu√™ daquilo n√£o ter sido executado, essas filas possuem diversas fun√ß√µes.\nA maneira de definir dead letters √© algo explicado dentro do protocolo AMQP, podemos apenas seguir essa configura√ß√£o:\n@Bean Queue messagesQueue() { return QueueBuilder.durable(\u0026#34;queue-name\u0026#34;) .withArgument(\u0026#34;x-dead-letter-exchange\u0026#34;, \u0026#34;nome-exchange.dlx\u0026#34;) .withArgument(\u0026#34;x-dead-letter-routing-key\u0026#34;, \u0026#34;queue-name.dlq\u0026#34;) // nao precisa ser o nome da queue, mas √© comum para direct .build(); } @Bean Queue deadLetterQueue() { return QueueBuilder.durable(\u0026#34;queue-name.dlq\u0026#34;).build(); } No fim das contas, uma dead letter queue √© uma queue normal, e uma dead letter exchange tamb√©m, portanto, se uma mensagem chegar na DLX (Dead Letter Exchange) e n√£o tiver uma routing key correta, ela n√£o chegar√° na fila, tudo normal por aqui.\nObserva√ß√µes Existem diversas maneiras de trabalhar com rabbitMQ, e uma infinidade de propriedades e configura√ß√µes n√£o mostradas aqui, como por exemplo: Feedback s√≠ncrono de exchanges e filas, Consumers Ass√≠ncronos, Containers Diferentes, propriedades de requeue, monitoramento de consumers, etc. Se algo fizer sentido para seu contexto, pode buscar no material de refer√™ncia do Spring üôÇ\nMais sobre DLQ: https://www.youtube.com/watch?v=GgIJWxk_-jM\nMais sobre exception handling: https://www.baeldung.com/spring-amqp-error-handling\nRefer√™ncias https://docs.spring.io/spring-amqp/reference/html/#template-retry\nhttps://github.com/spring-projects/spring-retry\nhttps://www.baeldung.com/spring-amqp-error-handling\n","permalink":"https://kaue.cat/posts/java-rabbit/java_rabbitmq_parte2/","summary":"Texto necessita outra revis√£o.\nAprofundando Nota: Nesse momento, entraremos um pouco mais em detalhes sobre como o protocolo AMQP funciona, escrevi um ‚Äúguia‚Äù bem b√°sico sobre propriedades do protocolo, se quiser conferir, pode ver aqui :)\nmensageria.pdf\nOu nesse link\nContexto O Spring AMQP consiste em dois m√≥dulos principais: spring-amqp e spring-rabbit. O ‚Äòspring-amqp‚Äô cont√©m o pacote org.springframework.amqp.core, que trata das principais abstra√ß√µes definidas no protocolo AMQP (RabbitMQ √© um broker, que implementa esse protocolo), esse pacote n√£o se baseia em nenhuma biblioteca de clientes nem implementa√ß√£o de broker.","title":"RabbitMQ com Java e Spring : Entendendo de verdade e com um toque de eleg√¢ncia (parte 2)"},{"content":"Bem vindo(a)! ao meu post de RabbitMQ com JAVA. Esse post n√£o tem como objetivo te ensinar RabbitMQ em detalhes ou at√© o protocolo AMQP. Na realidade, possuo um outro artigo onde comento sobre algumas peculiaridades do protocolo AMQP nesse link. De qualquer forma, na parte dois vou explicar por cima o que s√£o filas, exchanges, bindings e seus tipos.\nA ideia hoje √© fazermos algo realmente simples e m√£o na massa:\nConfigurarmos nosso rabbitMQ no docker com docker-compose Configurarmos um publisher, que envia mensagens de texto para as filas do RabbitMQ Configurarmos um consumer, que recebe essas mensagens e as trata. Configura√ß√£o B√°sica Antes de tudo, precisamos subir um servidor do Rabbit em nossa m√°quina local, a melhor maneira, na minha vis√£o, de fazer isso, √© usando docker, curto mais usar compose pra essas tarefas, ent√£o:\nversion: \u0026#39;3.1\u0026#39; services: rabbitmq: image: rabbitmq:management container_name: \u0026#39;rabbitmq\u0026#39; ports: - \u0026#34;5672:5672\u0026#34; - \u0026#34;15672:15672\u0026#34; Depois disso, voc√™ pode rodar docker-compose up e ser feliz. (Voc√™ vai precisar ter docker \u0026amp; docker compose instalados).] Verifique sua instala√ß√£o em localhost:15672\nDefinindo propriedades para a fila Gosto de organizar propriedades em um ConfigurationProperty (principalmente quando elas podem crescer, o que √© o caso), que busca informa√ß√µes do application.properties ou application.yaml\nNesse caso em espec√≠fico, vou fazer algo bem simples.\npackage com.kaue.ticketservice.infrastructure.properties; import lombok.Getter; import lombok.Setter; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @ConfigurationProperties(\u0026#34;broker.queue.ticket\u0026#34;) @Component @Getter @Setter public class TicketQueueProperties { private String name; } broker: queue: ticket: name: default.ticket Poder√≠amos ter m√∫ltiplas entries, e cada queue poderia ter outras propriedades al√©m de name (faremos isso na parte 2 üòà):\nbroker: queues: ticket: name: default.ticket durable: true autoDelete: false exclusive: false otherQueue: name: other.queue durable: false autoDelete: true exclusive: true Se quiser adicionar mais filas, definiria uma classe com as configura√ß√µes para cada fila e definiria o ConfigurationProperties mais ou menos assim:\n@Component @ConfigurationProperties(prefix = \u0026#34;broker.queues\u0026#34;) public class QueueProperties { private Map\u0026lt;String, QueueConfig\u0026gt; queue; ... } Mas a princ√≠pio, vamos atuar s√≥ com ticket e name, do jeito que passei anteriormente.\nDefinindo a conex√£o com o Rabbit No seu application yaml ou properties, adicione:\nspring: rabbitmq: addresses: ${amqpURL:amqp://guest:guest@localhost} Nesse caso, se a vari√°vel de ambiente amqpURL existir, ela ser√° utilizada, caso contr√°rio, ser√° utilizado o padr√£o guest:guest, que funcionar√° perfeitamente com o docker compose apresentado anteriormente, ent√£o n√£o precisa mexer se n√£o for usar rabbit cloud ou tiver configurados as credenciais :)\nAdicionando a depend√™ncia Spring-Amqp O RabbitMQ √© uma ferramenta que implementa regras do protocolo AMQP, portanto, usaremos o Spring AMQP como depend√™ncia para configurar o nosso Rabbit!\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.amqp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-rabbit-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Criando uma Configura√ß√£o B√°sica para Beans do Rabbit O Spring boot trabalha com beans, que s√£o basicamente objetos os quais ele instancia e gera, nesse caso, vamos prover configura√ß√µes de beans do rabbit para o SPRING tomar conta, ou seja, criando um bean do tipo Queue, uma fila ser√° criada automaticamente\n@Configuration @Slf4j @RequiredArgsConstructor public class RabbitMqConfiguration { private final TicketQueueProperties ticketQueueProperties; @Bean public Queue queue(){ log.info(\u0026#34;Looking for queue: {}\u0026#34;, ticketQueueProperties.getName()); return new Queue(ticketQueueProperties.getName(), true); } } ‚ö†Ô∏è Para evitar confus√£o:\nEstou usando RequiredArgsConstructor com um campo final: TicketQueueProperties, RequiredArgsConstructor faz com que exista um construtor que contenha todos os campos final nele, portanto, como √© o √∫nico construtor, o Spring Boot o usar√° e automaticamente ir√° inserir a depend√™ncia TicketQueueProperties correta, o resultado √© o mesmo que o @Autowired, mas a inje√ß√£o via construtor √© mais recomendada que o uso de Autowired ‚òùÔ∏èü§ì! Aqui, podemos definir diversos beans, configura√ß√µes de outras filas e exchanges, et cetera, um m√©todo para cada Bean;\nDefinindo o primeiro Publisher Aqui vamos usar a composi√ß√£o e injetar na nossa classe uma inst√¢ncia de RabbitTemplate, depois, usar o m√©todo publish. Nesse caso, vamos utilizar a exchange padr√£o, e o nome da fila ser√° o primeiro par√¢metro, sendo o segundo a mensagem em si.\n// ommitted import lombok.AllArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.core.RabbitTemplate; @Slf4j @RequiredArgsConstructor public class RabbitTicketPublisher implements MessagePublisher { private final TicketQueueProperties ticketQueueProperties; private final RabbitTemplate rabbitTemplate; @Override public void publish(Text text) { log.info(\u0026#34;Notifying queue: {} of text{}\u0026#34;, ticketQueueProperties.getName(), text); rabbitTemplate.convertAndSend(ticketQueueProperties.getName(),text); } } MessagePublisher√© uma interface pr√≥pria que defini em meu dom√≠nio, para desacoplar a camada de infraestrutura, deixei apenas um m√©todo publish, onde enviamos os eventos e/ ou mensagens para algum lugar, as implenta√ß√µes sabem que lugar √© esse.\nDefinindo a inje√ß√£o de depend√™ncias. De maneira similar ao que j√° vi em C#, optei por cuidar da DI mais manualmente:\n// ommitted @Configuration @AllArgsConstructor public class DIConfiguration { private TicketRepository ticketRepository; private TicketQueueProperties ticketQueueProperties; private RabbitTemplate rabbitTemplate; @Bean public TicketService ticketService() { return new TicketService(ticketRepository, ticketsMessagePublisher()); } @Bean public MessagePublisher ticketsMessagePublisher(){ return new RabbitTicketPublisher(ticketQueueProperties, rabbitTemplate); } } Poder√≠amos tamb√©m criar uma interface para cada publisher, mas n√£o sei o quanto gostaria dessa abordagem, talvez haja algo melhor, mas para mim, cuidar da desambigua√ß√£o de Beans dessa forma n√£o est√° sendo um problema (por hora)\nO Primeiro Consumer: Aqui, vamos definir que estamos ouvindo a fila de nome X pela annotation @RabbitListener.\n@Slf4j @Component public class TicketConsumer { @RabbitListener(queues = \u0026#34;${broker.queue.ticket.name}\u0026#34;) public void listenEmailQueue(@Payload String text){ log.info(\u0026#34;Received: {}\u0026#34;, text); } } Aqui estou usando o @Value ao inv√©s do configuration properties para exemplificar, sei que diversas pessoas preferem essa abordagem!\nResultado Parte 2 : O que veremos O que s√£o filas, exchanges e bindings Defini√ß√£o autom√°tica elegante de filas, exchanges e bindings via application yaml usando declarables Enviando objetos! Outros super poderes do protocolo (introdu√ß√£o) : Retries, DLQ, DLXZ Refer√™ncias https://docs.spring.io/spring-amqp/reference/html/#template-retry\n","permalink":"https://kaue.cat/posts/java-rabbit/java_rabbitmq_parte1/","summary":"Bem vindo(a)! ao meu post de RabbitMQ com JAVA. Esse post n√£o tem como objetivo te ensinar RabbitMQ em detalhes ou at√© o protocolo AMQP. Na realidade, possuo um outro artigo onde comento sobre algumas peculiaridades do protocolo AMQP nesse link. De qualquer forma, na parte dois vou explicar por cima o que s√£o filas, exchanges, bindings e seus tipos.\nA ideia hoje √© fazermos algo realmente simples e m√£o na massa:","title":"RabbitMQ com Java e Spring : Come√ßando (pt. 1)"},{"content":"Map, Filter, Reduce Vamos come√ßar com um exemplo?\n* Given a list of people * We need to compute the average of the age of those people * For the people older than 20 Nesse caso, √© meio claro, come√ßamos com um objeto pessoa, mas trabalharemos / transformaremos o dado de uma maneira que consigamos a idade (map). O map pega um objeto, e mapeia para outro, geralmente de tipo diferente Com isso, vamos filtrar o dado age, para que ele s√≥ compute a m√©dia de maiores de 20 anos. Isso √© um filter. O filter literalmente filtra os dados, n√£o os transforma (diferente de map) e decide se deve manter ou n√£o o dado. 2.1. Filters em c√≥digo recebem uma predicate como par√¢metro, ela representa uma fun√ß√£o que recebe um argumento e retorna um valor booleano. Por fim, vamos calcular a m√©dia desse dado, j√° transformado de pessoas e filtado para que a idade seja \u0026gt;20. Essa opera√ß√£o avg √© o reduce, nesse caso, vamos pensar nela a princ√≠pio como uma agrega√ß√£o (tipo min,max,count, etc). Opera√ß√£o Comportamento Map Transforma o dado, mudando seu tipo. N√£o muda o n√∫mero de elementos. Filter N√£o transforma o dado, reduz (ou mant√©m igual) o n√∫mero de elementos Reduce Combina os elementos em um resultado √∫nico. √â uma opera√ß√£o terminal que produz um √∫nico valor com base em uma opera√ß√£o de redu√ß√£o, como soma, m√©dia ou m√°ximo. Por que usar Streams? List\u0026lt;Person\u0026gt; people = ...; int sum = 0; int count = 0; for (Person person: people) { if (person.getAge() \u0026gt; 20) { count++; sum += person.getAge(); } } double average = 0d; if(count \u0026gt; 0) { average = sum / count; } No exemplo acima, temos um c√≥digo que descreve com detalhes o que deve ser feito para chegarmos em um resultado (o resultado do exemplo apresentado), e se mudarmos o algoritmo, precisamos mudar o c√≥digo, mesmo que o algoritmo seja o mesmo. N√£o necessariamente precisa ser assim, em SQL, por exemplo, escrever√≠amos:\nSelect AVG(age) from People Where People.age\u0026gt;20 Note que no exemplo acima, descrevemos ao c√≥digo o que queremos que seja feito, as premissas, descrevemos o resultado, e n√£o como o resultado deve ser computado.\nCollection X Streams Tudo certo, se o c√≥digo faz parte de uma lista ou qualquer cole√ß√£o, podemos tentar implementar assim:\nList\u0026lt;Person\u0026gt; people = ...; double average = people.map(person -\u0026gt; person.getAge()) .filter(age ‚Äî \u0026gt; age \u0026gt; 20) .average(); ERRADO! A API de collections n√£o prov√™ esse tipo de opera√ß√µes, o c√≥digo acima n√£o compila üòÑ!\nMas por que a API de Collections e Streams s√£o separadas? Imagine que essas opera√ß√µes s√£o feitas em uma lista de 1.000.000 de pessoas! Portanto, ap√≥s o primeiro map, voc√™ teria uma Lista com 1.000.000 de inteiros de idade (porque o map n√£o reduziria o tamanho em si), acho que j√° deu para perceber que duplicar a collection vai ser altamente custoso para o processador e para a mem√≥ria\nMas como isso funciona? Quando usamos pessoas.stream(), retornamos uma Stream\u0026lt;Pessoa\u0026gt;. Por defini√ß√£o, um objeto de stream n√£o carrega dados, √© gr√°tis cria-lo.\nA collection is an in-memory data structure to hold values and before we start using collection, all the values should have been populated. Whereas a java Stream is a data structure that is computed on-demand. Java Stream doesn‚Äôt store data, it operates on the source data structure (collection and array) and produce pipelined data that we can use and perform specific operations.\nhttps://www.digitalocean.com/community/tutorials/java-8-stream\nOpera√ß√µes Intermedi√°rias X Finais Streams atuam sobre cole√ß√µes para realizar map / filter / reduce, opera√ß√µes intermedi√°rias s√£o opera√ß√µes sobre streams que retornam streams ( Stream\u0026lt;T\u0026gt; map() ‚Üí M√©todo de stream, retorna stream).\nOpera√ß√µes finais s√£o opera√ß√µes que retornam a cole√ß√£o de novo, depois do processamento / pipelining acabar toList() √© um exemplo\nE como ficaria o c√≥digo Aqui est√° um exemplo de como ficaria o c√≥digo.\nList\u0026lt;Pessoa\u0026gt; pessoas = new ArrayList\u0026lt;\u0026gt;(); pessoas.stream() .map(...) .filter(...) .average(); Stream\u0026lt;String\u0026gt; personNames = personStream.map(Person::getName); Stream\u0026lt;String\u0026gt; emptyNames = personNames.filter( name -\u0026gt; name.isEmpty()) Stream\u0026lt;String\u0026gt; notEmptyNames = personNames.filter( name -\u0026gt; !name.isEmpty()) Esse c√≥digo quebrar√°, tendo em vista que estamos processando a mesma stream personNames duas vezes!\nStream\u0026lt;String\u0026gt; personNames = personStream.map(Person::getName); Stream\u0026lt;Integer\u0026gt; personAges = personStream.map(Person::getAge); Nesse caso, estamos aplicando o map para criar duas streams diferentes, n√£o quebrar√° o c√≥digo.\nStream\u0026lt;String\u0026gt; emptyNames = personStream.map(Person::getName).filter(name -\u0026gt; name.isEmpty()); Stream\u0026lt;String\u0026gt; notEmptyNames = personStream.map(Person::getName).filter(name -\u0026gt; !name.isEmpty()); Esse c√≥digo, processando duas streams diferentes tamb√©m funcionar√°\nPor favor, n√£o crie vari√°veis para trabalhar com streams, fiz por did√°tica\nFlatMapping Flatmapping funciona para lidar com rela√ß√µes 1:N\nExemplo: Cidades, onde temos v√°rias pessoas por cidade.\nSuponha que queremos pegar todas as pessoas, independente de suas cidades. Nesse caso, nos preocupamos com a entidade relacionada, n√£o com as cidades em si**. O flatmap faz isso, pega uma entidade Cidade e retorna para n√≥s uma Stream\u0026lt;Pessoas\u0026gt;.**\nList\u0026lt;City\u0026gt; cities = ...; Function\u0026lt;City, Stream\u0026lt;Person\u0026gt;\u0026gt; flatMapper = city -\u0026gt; city.getPeople().stream(); long count = cities.stream() .flatMap(flatMapper) /*poder√≠amos colocar city -\u0026gt; city.getPeople().stream() direto*/ .count() List\u0026lt;String\u0026gt; words \u0026#34;Gomu\u0026#34;,\u0026#34;Gomu\u0026#34;, \u0026#34;No\u0026#34;, \u0026#34;Mi\u0026#34;); Stream\u0026lt;String\u0026gt; streamStream = words.stream() .map(w -\u0026gt; w.split(\u0026#34;\u0026#34;)) // Stream\u0026lt;String[]\u0026gt; .flatMap(Arrays::stream) ; // Stream\u0026lt;String\u0026gt; O flatmap funciona nesse caso, pois ao aplicar flatMap(Arrays::stream), voc√™ est√° dizendo ao Java para pegar cada array de caracteres da Stream\u0026lt;String[]\u0026gt; e transform√°-lo em uma stream de strings (Stream\u0026lt;String\u0026gt;) usando o m√©todo est√°tico Arrays.stream().\nStreams a partir de RegEx String sentence = \u0026#34;the quick brown fox jumps over the lazy dog\u0026#34;; String[] words = sentence. split( Stream\u0026lt;String\u0026gt; wordsStream = Arrays.stream(words); Ion count = wordsStream.count() Ao fazermos dessa forma, criamos um array intermedi√°rio, perdemos o prop√≥sito de streams.\nPodemos fazer:\nPattern pattern = Pattern.compile(\u0026#34; \u0026#34;); long count = pattern.sp1itAsStream(sentence) . count(); Streams de outro tipo Em java, existem interfaces de stream feitas para manipular certos primitivos mais adequadamente, um exemplo disso √© a IntStream\nIntStream IntStream tende a ser mais eficiente em termos de espa√ßo e desempenho quando voc√™ est√° trabalhando com valores inteiros primitivos, uma vez que evita a cria√ß√£o de objetos Integer.\nA IntStream oferece opera√ß√µes especializadas para trabalhar com valores inteiros, como sum(), average(), range(), rangeClosed(), etc. Uma Stream\u0026lt;Integer\u0026gt; fornece opera√ß√µes de stream gen√©ricas aplic√°veis a objetos, mas √© menos eficiente quando se trata de c√°lculos com tipos primitivos.\nRefactoring ‚Üí Exemplo com m√∫ltiplas tarefas ao mesmo tempo Streams n√£o s√£o uma boa para realizarem m√∫ltiplas tarefas simultaneamente, portanto se temos um for loop que agrega valores √† 3 vari√°veis diferentes, precisamos dividir em 3 for‚Äôs (repetidos) e trocar cada um deles por uma stream. Claro, isso diminui muito a performance, mas em um for com poucos elementos a serem iterados, ser√° basicamente impercept√≠vel.\npublic String statement() { double totalAmount = rentals.stream() .mapToDoub1e(this::computeRenta1Amount) .sum(); int frequentRenterPoints = rentals.stream() .mapToInt (this::getFrequentRenterPoints) .sum(); String statement = composeHeader(); statement += rentals.stream() .map(this::computeStatementLine) .collect(Collectors.joining()); } Redu√ß√µes Antes, ouvimos que redu√ß√£o era algo similar a uma agrega√ß√£o do SQL, vamos continuar com isso em mente, mas como isso funciona?\nVamos ter como exemplo a soma, a soma √© uma uma implementa√ß√£o de BinaryOperator\u0026lt;Integer\u0026gt;, que pega dois elementos e os soma ( sum = (i1,i2) -\u0026gt; i1+i2;). Isso acontece com dois elementos por vez, associando os valores e depois somando com o outro.\nRedu√ß√µes de uma stream vazia Mas e qual a redu√ß√£o de uma Stream vazia? A redu√ß√£o de uma Stream vazia √© o seu elemento identidade (identity), um elemento identidade √© um valor pr√©-definido que atua como ponto de partida em uma opera√ß√£o de redu√ß√£o. Em contextos de programa√ß√£o funcional, quando n√£o h√° elementos para combinar na Stream, a opera√ß√£o de redu√ß√£o retorna o elemento identidade como resultado, garantindo que a opera√ß√£o seja definida e n√£o cause exce√ß√µes em casos de Stream vazia. Isso √© especialmente √∫til para lidar com casos em que n√£o h√° dados dispon√≠veis para a opera√ß√£o espec√≠fica, permitindo que o c√≥digo se comporte de maneira previs√≠vel e segura.\nPor exemplo, o identity de uma soma √© 0, tendo em vista que o 0 n√£o impactar√° no valor final, para m√∫ltiplica√ß√£o, um.\nMax, Min, Avg? O \u0026ldquo;identity element\u0026rdquo; ou valor inicial para as opera√ß√µes de max, min e average em Streams do Java √© um pouco diferente porque essas opera√ß√µes retornam um Optional, que pode ser vazio (caso a Stream esteja vazia) ou conter um valor, portanto, essas opera√ß√µes n√£o tem valores identity.\nPortanto, para acessar max, min e avg, voc√™ deve fazer algo do tipo:\nOptional\u0026lt;Integer\u0026gt; max = numbers.stream().max(Integer::compareTo); Optional\u0026lt;Integer\u0026gt; min = numbers.stream().min(Integer::compareTo); OptionalDouble average = numbers.stream().mapToDouble(Integer::doubleValue).average(); System.out.println(\u0026#34;Max: \u0026#34; + max.orElse(null)); System.out.println(\u0026#34;Min: \u0026#34; + min.orElse(null)); System.out.println(\u0026#34;Average: \u0026#34; + average.orElse(Double.NaN)); Como podemos escrever nossas reductions? Talvez voc√™ esteja se perguntando o porqu√™ de entendermos tamb√©m a fundamenta√ß√£o de identity elements, se ainda n√£o ficou claro, vai ficar agora:\nA opera√ß√£o reduce em Streams do Java tem dois par√¢metros principais:\nO valor inicial (identity element): J√° foi explicado Uma fun√ß√£o de acumula√ß√£o (accumulator function): Esta fun√ß√£o √© usada para combinar os elementos da Stream em um √∫nico resultado. A fun√ß√£o deve ser uma express√£o lambda ou um m√©todo de refer√™ncia que aceite dois argumentos e retorne um resultado. Em soma, seria (a, b) -\u0026gt; a + b Se sua stream n√£o possuir um identity, voc√™ pode usar uma outra sobrecarga do m√©todo que n√£o recebe o identity, mas retorna um Optional. Use-o somente se n√£o possuir o identity‚Ä¶\nRedu√ß√µes em um container mut√°vel Redu√ß√µes em um container mut√°vel referem-se √† aplica√ß√£o de opera√ß√µes de redu√ß√£o, como soma, multiplica√ß√£o, m√©dia, entre outras, a elementos armazenados em um cont√™iner que pode ser alterado durante o processo de redu√ß√£o. Um \u0026ldquo;container\u0026rdquo; neste contexto pode ser definido como uma estrutura de dados flex√≠vel que permite armazenar e modificar elementos de forma din√¢mica (Lists, Maps, etc.). Portanto, podemos simplificar redu√ß√µes em containers mut√°veis como redu√ß√µes em cole√ß√µes.\nAo chamar .stream() em uma lista, voc√™ est√° criando uma Stream dos elementos contidos na lista. A Stream √© uma sequ√™ncia de elementos que pode ser processada de maneira funcional, mas n√£o modifica a lista original. Quando voc√™ chama .max(), por exemplo, est√° solicitando o elemento m√°ximo com base em algum crit√©rio da lista, mas a lista em si permanece a mesma.\nColetores! List\u0026lt;Person\u0026gt; pessoasDaBaixada = new ArrayList() ; pessoasDaBaixada.stream() .filter(p -\u0026gt; p.getDDD().equals(\u0026#34;013\u0026#34;)) .forEach(p -\u0026gt; pessoasDaBaixada.add(p)); Mas esse exemplo acima n√£o √© muito diferente do que j√° vimos, por que estamos focando nesse tipo de redu√ß√£o?\nPara filtrar e coletar elementos em uma nova lista usando a API de Streams do Java, voc√™ deve usar um coletor adequado, como Collectors.toList()\nOs coletores permitem que voc√™ capture os resultados das opera√ß√µes de redu√ß√£o em cole√ß√µes ou outros tipos de dados concretos. Em outras palavras, eles transformam os elementos processados em uma Stream em uma cole√ß√£o real que pode ser usada e manipulada posteriormente.\nList\u0026lt;Person\u0026gt; pessoasDaBaixada = new ArrayList\u0026lt;\u0026gt;(); // Supondo que o n√∫mero de DDD seja uma String List\u0026lt;Person\u0026gt; pessoasComDDD13 = pessoasDaBaixada.stream() .filter(p -\u0026gt; \u0026#34;13\u0026#34;.equals(p.getDDD())) .collect(Collectors.toList()); //.toList() retornar√° uma lista imut√°vel! ‚ÄùO novo m√©todo Stream.toList() n√£o produz nem uma lista n√£o modific√°vel nem √© um atalho para collect(toUnmodifiableList()), porque toUnmodifiableList() n√£o aceita valores nulos. A implementa√ß√£o de Stream.toList() n√£o √© limitada pela interface Collector; portanto, Stream.toList() aloca menos mem√≥ria. Isso a torna ideal para uso quando o tamanho da stream √© conhecida antecipadamente.‚Äù Link para coment√°rio no stackoverflow\nExemplos de Outros Coletores Collectors.toSet(): Cria um conjunto a partir dos elementos da Stream, removendo duplicatas. Collectors.toMap(keyMapper, valueMapper): Cria um map a partir dos elementos da Stream, usando fun√ß√µes de mapeamento para extrair chaves e valores. Collectors.groupingBy(classifier): Agrupa elementos da Stream com base em um crit√©rio definido pela fun√ß√£o de classifica√ß√£o. Collectors.joining(delimiter): Concatena os elementos da Stream em uma √∫nica String usando um delimitador. Collectors.summingInt() ou Collectors.summingLong(): Calcula a soma dos valores inteiros ou longos de elementos da Stream. Exemplos de uso: Map\u0026lt;Integer, List\u0026lt;Person\u0026gt;\u0026gt; pessoasPorIdade = pessoas.stream() .collect(Collectors.groupingBy(Person::getIdade)); List\u0026lt;Person\u0026gt; pessoas = Arrays.asList( new Person(\u0026#34;Jorge\u0026#34;, 25), new Person(\u0026#34;Ben\u0026#34;, 30), new Person(\u0026#34;Jor\u0026#34;, 35) ); Map\u0026lt;String, Integer\u0026gt; mapNomeIdade = pessoas.stream() .collect(Collectors.toMap(Person::getNome, Person::getIdade)); // ex1 Map\u0026lt;Integer, List\u0026lt;Person\u0026gt;\u0026gt; pessoasPorIdade = new HashMap\u0026lt;\u0026gt;(); pessoas.forEach(person -\u0026gt; { Integer idade = person.getIdade(); List\u0026lt;Person\u0026gt; pessoasComIdade = pessoasPorIdade.get(idade); if (pessoasComIdade == null) { pessoasComIdade = new ArrayList\u0026lt;\u0026gt;(); pessoasPorIdade.put(idade, pessoasComIdade); } pessoasComIdade.add(person); }); // ex2 Map\u0026lt;String, Integer\u0026gt; mapNomeIdade = new HashMap\u0026lt;\u0026gt;(); pessoas.stream().forEach(person -\u0026gt; mapNomeIdade.put(person.getNome(), person.getIdade())); Pincelando: Streams Paralelas √Ä medida que exploramos as reductions e opera√ß√µes terminais, √© crucial considerar o potencial das streams paralelas em Java, mas o que s√£o? ü§î\nStreams paralelas oferecem a capacidade de executar opera√ß√µes em paralelo, aproveitando m√∫ltiplos n√∫cleos da CPU, o que melhora muito o desempenho da stream.\nApesar disso, vale dizer que opera√ß√µes em paralelo nem sempre podem ser consideradas em uma stream, suponha que voc√™ esteja calculando uma m√©dia com uma reduction, para calcularmos a m√©dia, precisamos primeiro somar os elementos, e ent√£o dividirmos, se somarmos e depois dividirmos partes distintas, isso trar√° um resultado incorreto, isso significa que a m√©dia √© uma opera√ß√£o n√£o associativa!\nOpera√ß√µes Associativas S√£o opera√ß√µes em que a ordem em que os elementos s√£o combinados n√£o afeta o resultado. Exemplos comuns de opera√ß√µes associativas incluem soma e multiplica√ß√£o.\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // C√°lculo da soma em uma stream paralela int sum = numbers.parallelStream().reduce(0, Integer::sum); Esse par√°grafo tem como objetivo apenas introduzir e notificar a exist√™ncia de streams paralelas, procure saber mais sobre elas! Opera√ß√µes N√£o-Associativas S√£o o oposto!\nConclus√£o e Agradecimento Obrigado pela leitura, espero que tenha sido produtiva e que voc√™ tenha todo o conhecimento necess√°rio para conseguir dar seus pr√≥prios passos e construir streams funcionais e avan√ßadas, caso necess√°rio.\nRefer√™ncias https://app.pluralsight.com/library/courses/692a1310-42db-4f3c-a33b-208a55b7bd84/table-of-contents\nhttps://www.digitalocean.com/community/tutorials/java-8-stream\nMaratona Java Virado no Jiraya\nhttps://acervolima.com/coletores-java/\n","permalink":"https://kaue.cat/posts/streams/","summary":"Map, Filter, Reduce Vamos come√ßar com um exemplo?\n* Given a list of people * We need to compute the average of the age of those people * For the people older than 20 Nesse caso, √© meio claro, come√ßamos com um objeto pessoa, mas trabalharemos / transformaremos o dado de uma maneira que consigamos a idade (map). O map pega um objeto, e mapeia para outro, geralmente de tipo diferente Com isso, vamos filtrar o dado age, para que ele s√≥ compute a m√©dia de maiores de 20 anos.","title":"Streams em JAVA: Tudo que voc√™ precisa saber"},{"content":"Aviso: Esse post ainda passar√° por uma revis√£o!\nTestando Reposit√≥rios (De verdade!) Podemos testar reposit√≥rios de alguns jeitos, uma das maneiras √© utilizar um banco em mem√≥ria. Para SQL, h2 √© f√°cil e r√°pido, podemos fazer as configs no banco usando um application-properties para os testes e validar tudo bonitinho normalmente üôÇ. Outra alternativa seria utilizar TestContainers Conseguindo testar e subir reposit√≥rios e message brokers reais, conseguimos fazer testes de integra√ß√£o! TestContainers \u0026ldquo;Testcontainers √© um framework de c√≥digo aberto para fornecer inst√¢ncias descart√°veis e leves de bancos de dados, message brokers, browsers ou praticamente qualquer coisa que possa ser executada em um container Docker.‚Äù\nAdicionando depend√™ncias: \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mongodb\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;testcontainers\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; A primeira depend√™ncia ir√° variar de acordo com suas necessidades, dependendo do que precisar subir, no meu caso, s√≥ o MongoDB, se precisasse de RabbitMQ, tamb√©m o adicionaria, por exemplo.\nNo c√≥digo, √© simples, depois de termos as depend√™ncias configuradas corretamente, podemos adicionar e instanciar os containers passando a tag da imagem docker como par√¢metro, para o mongodb, mongo:latest.\nAdicionar o Container: private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026quot;mongo:latest\u0026quot;); Adicionar @Container √† vari√°vel do container Se estiver usando Spring 3.1+, adicionar a anota√ß√£o @ServiceConnection tamb√©m. Essa configura√ß√£o pega os dados do container criado e automaticamente sobrescreve com essas informa√ß√µes o container que seria usado originalmente Caso contr√°rio, precisamos fazer isso na m√£o: crie um m√©todo que recebe como par√¢metro DynamicPropertyRegistry Anote esse m√©todo com @DynamicPropertySource Altere as propriedades que estavam configuradas anteriormente usando registry.add(\u0026quot;propriedade\u0026quot;, valor) @Container private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026#34;mongo:latest\u0026#34;); @Container private static final RabbitMQContainer RABBIT_MQ_CONTAINER = new RabbitMQContainer(\u0026#34;rabbitmq:management\u0026#34;); @DynamicPropertySource static void mongoDbProperties(DynamicPropertyRegistry registry) { MONGO_DB_CONTAINER.start(); registry.add(\u0026#34;spring.data.mongodb.uri\u0026#34;, MONGO_DB_CONTAINER::getReplicaSetUrl); registry.add(\u0026#34;spring.rabbitmq.addresses\u0026#34;,() -\u0026gt; \u0026#34;amqp://guest:guest@localhost:\u0026#34;+RABBIT_MQ_CONTAINER.getAmqpPort()); } A partir da√≠, siga sua vida com seu Rabbit, Mongo ou qualquer outra inst√¢ncia descart√°vel.\n@Testcontainers @SpringBootTest public class TicketRepositoryJPATest { @Autowired private TicketRepositoryJPA ticketRepository; @Autowired private TicketFactory ticketFactory; @Container // @ServiceConnection spring 3.1+ - makes DynamicPropertySource unnecessary private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026#34;mongo:latest\u0026#34;); @DynamicPropertySource static void mongoDbProperties(DynamicPropertyRegistry registry) { MONGO_DB_CONTAINER.start(); registry.add(\u0026#34;spring.data.mongodb.uri\u0026#34;, MONGO_DB_CONTAINER::getReplicaSetUrl); } @Test @Order(0) void InsertTicket_Success(){ Ticket t = ticketFactory.createTicket(\u0026#34;validemail@gmail.com\u0026#34;, \u0026#34;I have a problem\u0026#34;, \u0026#34;hellp\u0026#34;); ticketRepository.insert(t); } @Test @Order(1) void FindAll_findsOne(){ var tickets = ticketRepository.findAll(); assertEquals(tickets.size(), 1); } } No caso acima fa√ßo um teste simples de reposit√≥rio onde garanto que alguns m√©todos est√£o sendo executados corretamente, mas poderia por exemplo, fazer um teste de integra√ß√£o que garante service + reposit√≥rio, ou at√© mesmo um teste de integra√ß√£o completo com TestRestTemplate.\nImportanto classes de declara√ß√£o de Testcontainer Um padr√£o comum ao usar o Testcontainers √© declarar inst√¢ncias de **Container**como campos est√°ticos. Frequentemente, esses campos s√£o definidos diretamente na classe de teste. Eles tamb√©m podem ser declarados em uma classe pai ou em uma interface que o teste implementa:\npublic interface MyContainers { @Container MongoDBContainer mongoContainer = new MongoDBContainer(\u0026#34;mongo:5.0\u0026#34;); @Container Neo4jContainer\u0026lt;?\u0026gt; neo4jContainer = new Neo4jContainer\u0026lt;\u0026gt;(\u0026#34;neo4j:5\u0026#34;); } Para mais discuss√µes, n√£o focando s√≥ no setup, mas em configura√ß√µes diferentes, pr√≥s e contras, recomendo esse post: https://maciejwalkowiak.com/blog/testcontainers-spring-boot-setup/\nOutra ideia interessante √© que podemos configurar TestContainers para aplica√ß√µes rodando em desenvolvimento, vai servir como um docker compose que n√£o precisamos rodar. √â legal, mas n√£o gosto muito da abordagem pois usar docker-compose se tornou parte comum dia a dia de muitos devs e possu√≠ f√°cil leitura e troubleshooting. Se te animar, para explorar esse ponto: https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.testcontainers.at-development-time\nRefer√™ncias: https://spring.io/blog/2023/06/23/improved-testcontainers-support-in-spring-boot-3-1\nhttps://howtodoinjava.com/spring-boot/testcontainers-with-junit-and-spring-boot/\nhttps://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.testcontainers\n","permalink":"https://kaue.cat/posts/integracao_testcontainers/","summary":"Aviso: Esse post ainda passar√° por uma revis√£o!\nTestando Reposit√≥rios (De verdade!) Podemos testar reposit√≥rios de alguns jeitos, uma das maneiras √© utilizar um banco em mem√≥ria. Para SQL, h2 √© f√°cil e r√°pido, podemos fazer as configs no banco usando um application-properties para os testes e validar tudo bonitinho normalmente üôÇ. Outra alternativa seria utilizar TestContainers Conseguindo testar e subir reposit√≥rios e message brokers reais, conseguimos fazer testes de integra√ß√£o!","title":"TestContainers em Java: Testes de integra√ß√£o, reposit√≥rios e outras coisas!"},{"content":"Seja bem vindo, esse daqui √© o √∫ltimo post da infinita s√©rie sobre concorr√™ncia em Java. A s√©rie √© focada em Java, mas esse post em especial apresenta conceitos relevantes para literalmente todas as linguagens e tamb√©m n√£o √© uma leitura muito extensiva :).\nNosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida Concorr√™ncia, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures CompletableFuture Virtual Threads O Artigo Primeiro, vamos estabelecer objetivos desse artigo:\n‚úÖ Objetivos\nDar uma breve Introdu√ß√£o √† Programa√ß√£o Concorrente e Paralela Explicar o hist√≥rico da programa√ß√£o concorrente no JAVA Mostrar brevemente como o problema de throughput era resolvido no JAVA Explicar Virtual Threads Mostrar exemplos pr√°ticos do uso de Virtual Threads Mostrar concorr√™ncia estruturada\nE\u0026hellip;\n‚ùå N√£o Objetivos\nN√£o √© objetivo explicar em detalhes mecanismos de programa√ß√£o concorrente \u0026amp; paralela, para isso, recomendo fortemente esse artigo do Matheus Fidelis N√£o √© objetivo explicar em detalhes como a programa√ß√£o reativa e multithreaded √© feita em JAVA (sem ser com Virtual Threads) Entrar em detalhe sobre assuntos espec√≠ficos do pacote java.util.concurrent - Futures, Executors, Synchronizers, Cole√ß√µes Thread-Safe, etc. Para isso, recomendo ocurso gratuito de Java do DevDojo\nVirtual Threads Virtual Threads √© uma feature que est√° dispon√≠vel para uso em um LTS desde o Java 21, tamb√©m chamado de project loom, √© o projeto de integrar maneiras mais f√°ceis de escrever programas concorrentes e reativos em JAVA, a fim de misturar performance e usabilidade\nüîë Pontos Chave\nA virtual thread is a¬†Thread¬†‚Äî in code, at runtime, in the debugger and in the profiler. A virtual thread is not a wrapper around an OS thread, but a Java entity. Creating a virtual thread is cheap ‚Äî have millions, and don‚Äôt pool them! Blocking a virtual thread is cheap ‚Äî be synchronous! No language changes are needed. Pluggable schedulers offer the flexibility of asynchronous programming. ‚úÖ Objetivos\nEnable server applications written in the simple thread-per-request style to scale with near-optimal hardware utilization. Enable existing code that uses the java.lang.Thread API to adopt virtual threads with minimal change. Enable easy troubleshooting, debugging, and profiling of virtual threads with existing JDK tools. ‚ùå N√£o Objetivos\nIt is not a goal to remove the traditional implementation of threads, or to silently migrate existing applications to use virtual threads. It is not a goal to change the basic concurrency model of Java. It is not a goal to offer a new data parallelism construct in either the Java language or the Java libraries. The¬†Stream API¬†remains the preferred way to process large data sets in parallel. Conceitos De maneira geral, usamos as virtual threads por um motivo: Aumentar o throughput (vaz√£o) da nossa aplica√ß√£o (n√£o velocidade, que est√° relacionado √† lat√™ncia. Por enquanto, a maneira mais comum √© uma: Programa√ß√£o Reativa, vamos entender como a programa√ß√£o reativa era no passado, e como vamos implement√°-la com as virtual threads.\nüí° Throughput?\nThroughput diz respeito √† quantidade de elementos que voc√™ processa por uma medida de tempo (exemplo: Requests/Segundo em uma aplica√ß√£o HTTP, Mensagens Processadas por Segundo em um message broker).\nPrograma√ß√£o Ass√≠ncrona e Concorrente A maior parte do c√≥digo que escrevemos √© s√≠ncrono, isso significa que o c√≥digo vai ser executado imediatamente quando chegar naquela instru√ß√£o, o c√≥digo ass√≠ncrono √© um c√≥digo que vai ser executado, em algum momento no futuro, como uma promessa de execu√ß√£o. C√≥digos ass√≠ncronos n√£o significam a mesma coisa que concorrentes, um forEach ass√≠nrono, por exemplo, roda na thread principal de um programa, um c√≥digo concorrente significa que ele vai ser executado em outra thread!\nPodemos criar tarefas (Tasks) para rodarem em Threads, e para criarmos uma Thread, temos duas maneiras:\nCriar uma Thread a partir de seu construtor, e passar √† ela sua Task Usar uma pool (piscina) de Threads e deixar com que o executor entregue a tarefa √† uma thread dispon√≠vel (se ela existir) Essa Abordagem √© muito comum pois Threads s√£o recursos limitados que n√£o s√£o leves de criar e destruir Conex√µes de Banco de dados tamb√©m passam ficam em um \u0026ldquo;Pool\u0026rdquo; quando usamos frameworks como o Spring, a biblioteca que cuida da cria√ß√£o de um Pool de Conex√µes √© o Hikari Nesse cen√°rio, vamos criar uma task, submet√™-la ao Executor, e receberemos uma promessa de execu√ß√£o, por esse ponto de vista, essa tarefa √© ass√≠ncrona pois ser√° executada no futuro, mas tamb√©m √© concorrente, pois ser√° executada em uma thread diferente. Aqui os conceitos se encontram, mas n√£o s√£o a mesma coisa c√≥digo concorrente √© ass√≠ncrono, mas nem todo c√≥digo ass√≠ncrono √© concorrente!\nExecu√ß√£o Bloqueante Uma execu√ß√£o bloqueante significa que uma instru√ß√£o est√° sendo executada pela sua CPU (ou por um core dela) e que nenhuma outra instru√ß√£o ir√° ocorrer enquanto a anterior ainda estiver acontecendo, mesmo que sua CPU n√£o esteja sendo utilizada, normalmente em uma espera de I/O ou para entrar em um bloco de c√≥digo sincronizado. Nesse cen√°rio ir√° ocorrer uma troca de contexto, um processo relativamente \u0026ldquo;caro\u0026rdquo; para sua CPU que basicamente desaloca o processo at√© que ele exija algo novamente da CPU, por sua vez, o c√≥digo n√£o bloqueante garante que sua CPU evite trocas de contextos e esteja sempre sendo utilizada.\nO Cen√°rio Atual - Por qu√™ usar Virtual Threads? Primeiro, analise o c√≥digo JAVA que faz uma chamada HTTP padr√£o para um servidor:\nURI url = URI.create(\u0026#34;https://mydata.com/data\u0026#34;); HttpClient client = HttpClient.newBuilder().build(); HttpRequest request = HttpRequest.newBuilder(url).GET().build(); var response = client.send(request, HttpResponse.BodyHandlers.ofString()); Aqui, podemos ver que nossa CPU s√≥ √© realmente utilizada de maneira eficiente durante 200 nano segundos, e fica ociosa a maior parte do tempo, esperando a resposta da chamada.\nComo podemos arrumar isso?\n0. O Patinho lento - One Request Per Thread A primeira ideia √© irmos no aspecto concorrente, quando sua thread estiver esperando, o Task Scheduler vai remover ela do n√∫cleo que est√° rodando (Context Switching) e coloca outra thread no lugar, executar uma request em cada thread (One-Request-Per-Thread) √© a maneira convencional, que v√™m sido utilizada h√° bons anos.\nNesse cen√°rio, precisar√≠amos de 500 mil de threads - advindo da propor√ß√£o entre tempo ocioso e trabalhado. 100ms/200ns - (requests) nesse n√∫cleo para alcan√ßarmos o uso de 100% de CPU, garantindo que sua CPU n√£o fique ociosa. Isso definitivamente n√£o boa bom, n√©? As threads no JAVA encapsula uma thread do Sistema Operacional, tamb√©m chamada de Platform Thread ou Kernel Thread, o problema √© que o custo de cria√ß√£o de cria√ß√£o de uma Thread em JAVA, √© o mesmo de criar uma Thread no SO, que √© relativamente caro\nFonte\nRecursos caros como threads s√£o colocados em \u0026ldquo;Pools\u0026rdquo; para lidar com eles de maneiras mais eficientes:\n‚ùù ‚ùû\nDevelopers sometimes use thread pools to limit concurrent access to limited resources. For example, if a service cannot handle more than 20 concurrent requests then making all requests to the service via tasks submitted to a thread pool of size 20 will ensure that. This idiom has become ubiquitous because the high cost of platform threads has made thread pools ubiquitous Fonte: https://openjdk.org/jeps/444\nPerfeito, mas voltando ao exemplo anterior, precisamos de 500.000 threads, quanto isso vai nos custar?\nMem√≥ria: 500.000Mb Tempo de in√≠cio: 500 Segundos Com isso, entendemos que o modelo One Request Per Thread n√£o √© mais vi√°vel: O artigo Transformation patterns for a reactive application, de Bruno Miguel Mendon√ßa Maia pontua como caracter√≠stica desses sistemas :\nPontos Negativos ( ‚Äì ) Concurrency. Synchronous programming is not the best suited model for dealing with concurrency as the execution will start and block the current thread while waiting for the result. ( ‚Äì ) Throughput. While a thread waits for the expensive execution to return its result, the OS can exchange active threads to promote concurrency, but this has overhead costs and hinders throughput due to thread context switching and cache invalidation. ( ‚Äì ) Latency. Thread blocking on execution and the lower throughput due to the OS exchanging active threads and consequently cache invalidation leads to poorer latency.\nPontos Positivos (+) Ease of use. The synchronous sequential model and its typical imperative programming style provides a familiar thinking model that results in ease of use. (+) Maintainability. Synchronous programming and its sequential execution model provides an easy to reason with concept that in turn increase maintainability. Furthermore, error handling in sequential execution is easier to tackle.\n1. O patinho feio - Processar m√∫ltiplos requests em uma Thread Essa abordagem √© a abordagem Reativa. A abordagem reativa tem um princ√≠pio simples de dividir uma request em pequenas por√ß√µes e nenhuma por√ß√£o pode conter c√≥digo bloqueantes:\nAqui dividimos as etapas como foi acordado anteriormente (exceto pelo fato de que a step2 pode bloquear a CPU) Com isso, precisamos usar um framework reativo que permita que usemos essas lambdas (aqui o exemplo √© completableFuture, que faz a mesma coisa, mas usando a pool de threads, mas serve bem para explicar.):\nSeu framework de execu√ß√£o ter√° a responsabilidade de conectar as lambdas para que o resultado delas seja passado para a pr√≥xima fun√ß√£o corretamente, √© seu trabalho n√£o escrever c√≥digo bloqueante nesse caso. Como seu framework vai ter pouqu√≠ssimas threads (talvez s√≥ uma por n√∫cleo), e muitas requests v√£o ser processadas em uma mesma thread, escrever c√≥digo bloqueante vai impactar MUITO sua performance.\nNesse caso em espec√≠fico, a thread n√£o ser√° bloqueada pois CompletableFuture conhece o HttpRequest.send() e registra um callback, que ser√° executado quando a fun√ß√£o terminar de rodar.\nPontos Negativos C√≥digo dif√≠cil de ler C√≥digo dif√≠cil de dar manuten√ß√£o √â f√°cil de arruinar a performance com um peda√ßo de c√≥digo bloqueante. Dif√≠cil de testar 2. O Patinho que Existe - Futures e Callback Hell Aqui, usamos ainda do One Request Per Thread, mas com estrat√©gias um pouco diferentes, usamos Futures para escrever c√≥digo paraleliz√°vel e concorrente, ganhando performance.\nFonte https://blog.soaresdev.com/funcoes-callback-em-javascript/\nO post Virtual threads: Are futures a thing of the past?, na Java Magazine, retrata a hist√≥ria do c√≥digo concorrente em Java. L√°, √© retratado o uso de Futures para colocar suas Threads para rodar por√ß√µes bloqueantes em paralelo:\nvoid handleRequest(Socket socket) { var request = new Request(socket); var futureWeather = CompletableFuture.supplyAsync(() -\u0026gt; Weather.fetch(request), exec2); var futureRestaurants = CompletableFuture.supplyAsync(() -\u0026gt; Restaurants.fetch(request), exec2); var futureTheaters = CompletableFuture.supplyAsync(() -\u0026gt; Theaters.fetch(request), exec2); new Page(request) .setWeather(futureWeather.join()) .setRestaurants(futureRestaurants.join()) .setTheaters(futureTheaters.join()) .send(); } A ordem em que as tr√™s tasks esperam pelo resultado n√£o importa, a thread coloca os 3 Jobs para rodar, e depois bloqueia (espera) at√© que elas tenham terminado. Mas pera, \u0026ldquo;e depois bloqueia (espera) at√© que elas tenham terminado\u0026rdquo;\u0026hellip; Exato, ainda podemos melhorar isso bastante, bloquear Threads tem um custo:\nEsse blocking traz a possibilidade de deadlocks acontecerem. Aqui, teremos uma pool para computar recursos e para lidar com requests. Bloquear e desbloquear threads traz perda de performance. Claramente sua CPU n√£o vai ficar 2 Segundos esperando a sua resposta de I/O e vai colocar outra thread para trabalhar nesse meio termo, apesar disso, existe um custo n√£o s√≥ para fazer a troca de contexto, mas isso tamb√©m ir√° causar perda de dados em cache no processador, resultando em cache misses quando a thread estiver de volta. Podemos \u0026ldquo;resolver\u0026rdquo; isso usando callbacks!\npublic class Server { private final ServerSocket server = new ServerSocket(port); private final ExecutorService exec = Executors.newFixedThreadPool(16); public void run() { while (!server.isClosed()) { var socket = server.accept(); exec.execute(() -\u0026gt; handleRequest(socket)); } exec.close(); } void handleRequest(Socket socket) { var request = new Request(socket); var futureWeather = CompletableFuture.supplyAsync(() -\u0026gt; Weather.fetch(request), exec); var futureRestaurants = CompletableFuture.supplyAsync(() -\u0026gt; Restaurants.fetch(request), exec); var futureTheaters = CompletableFuture.supplyAsync(() -\u0026gt; Theaters.fetch(request), exec); var page = new Page(request); futureWeather.thenAccept(weather -\u0026gt; futureRestaurants.thenAccept(restaurants -\u0026gt; futureTheaters.thenAccept(theaters -\u0026gt; page.setWeather(weather) .setRestaurants(restaurants) .setTheaters(theaters) .send()))); } } Future.thenAccept recebe como argumento um consumer, que ir√° consumir o resultado dessa future, a invoca√ß√£o de thenAccept s√≥ registra o c√≥digo para uma execu√ß√£o futura, ele n√£o espera o c√≥digo ser completado, registrando um callback. Nesse cen√°rio, as threads nunca s√£o bloqueadas e uma √∫nica pool n√£o muito vasta pode ser usada. O c√≥digo tamb√©m est√° livre de deadlocks.\nCallbacks s√£o dif√≠ceis de escrever e de debugar, voc√™ pode ter percebido que nesse simples evento, j√° temos 3 n√≠veis de aninhamento de c√≥digo, podemos melhorar isso usando outras features para lidar com futures de maneira n√£o bloqueantes, como usando thenCombine:\nvoid handleRequest(Socket socket) { var request = new Request(socket); var futureWeather = CompletableFuture.supplyAsync(() -\u0026gt; Weather.fetch(request), exec); var futureRestaurants = CompletableFuture.supplyAsync(() -\u0026gt; Restaurants.fetch(request), exec); var futureTheaters = CompletableFuture.supplyAsync(() -\u0026gt; Theaters.fetch(request), exec); CompletableFuture.completedFuture(new Page(request)) .thenCombine(futureWeather, Page::setWeather) .thenCombine(futureRestaurants, Page::setRestaurants) .thenCombine(futureTheaters, Page::setTheaters) .thenAccept(Page::send); } Nesse cen√°rio, o √∫nico processamento que a thread que lida com as conex√µes performa √© a cria√ß√£o da p√°gina base, mas isso tamb√©m poderia ser ass√≠ncrono:\npublic class Server { private final ServerSocket server = new ServerSocket(port); private final ExecutorService exec = Executors.newFixedThreadPool(16); public void run() { while (!server.isClosed()) { var socket = server.accept(); handleRequest(socket); } exec.close(); } void handleRequest(Socket socket) { var futureRequest = CompletableFuture.supplyAsync(() -\u0026gt; new Request(socket), exec); var futureWeather = futureRequest.thenApplyAsync(Weather::fetch, exec); var futureRestaurants = futureRequest.thenApplyAsync(Restaurants::fetch, exec); var futureTheaters = futureRequest.thenApplyAsync(Theaters::fetch, exec); futureRequest .thenApplyAsync(Page::new, exec) .thenCombine(futureWeather, Page::setWeather) .thenCombine(futureRestaurants, Page::setRestaurants) .thenCombine(futureTheaters, Page::setTheaters) .thenAccept(Page::send); } } 3. O Patinho bonito - Construir uma thread virtual, mais leve que Platform Threads. As virtual threads s√£o exatamente isso, conseguimos performance, simplicidade e boa capacidade de manuten√ß√£o evitando c√≥digos reativos e sem ter medo de c√≥digos bloqueantes.\n‚ùù ‚ùû Implica√ß√µes\nVirtual threads are cheap and plentiful, and thus should never be pooled: A new virtual thread should be created for every application task. Most virtual threads will thus be short-lived and have shallow call stacks, performing as little as a single HTTP client call or a single JDBC query. Platform threads, by contrast, are heavyweight and expensive, and thus often must be pooled. They tend to be long-lived, have deep call stacks, and be shared among many tasks. In summary, virtual threads preserve the reliable thread-per-request style that is harmonious with the design of the Java Platform while utilizing the available hardware optimally. Using virtual threads does not require learning new concepts, though it may require unlearning habits developed to cope with today\u0026rsquo;s high cost of threads. Virtual threads will not only help application developers ‚Äî they will also help framework designers provide easy-to-use APIs that are compatible with the platform\u0026rsquo;s design without compromising on scalability.\n‚ùó Refor√ßando!\nN√£o crie pools de threads virtuais!\nEscrevendo Virtual Threads As maneiras que podemos criar virtual s√£o simples:\nVia factory Thread t3 = Thread.ofVirtual() .name(\u0026#34;Thread virtual!\u0026#34;) .start(task); t3.join(); Thread.startVirtualThread(task) Thread t4 = Thread.startVirtualThread(task); t4.join(); Usando um executorService (com o m√©todo newVirtualThreadPerTaskExecutor): public static void execute(){ var set = ConcurrentHashMap.\u0026lt;String\u0026gt;newKeySet(); Runnable task = () -\u0026gt; set.add(Thread.currentThread().toString()); int N_TASKS = 500; try (var executorService = Executors.newVirtualThreadPerTaskExecutor()) { for (int index = 0; index \u0026lt; N_TASKS; index++) { executorService.submit(task); } } System.out.println(\u0026#34;# threads used = \u0026#34; + set.size()); } Como Virtual Threads funcionam Uma virtual thread √© executada em cima de uma platform thread, que chamamos de Carrier Thread. Essas carrier threads s√£o organizadas em uma √∫nica ForkJoinPool, onde cada Platform (tamb√©m carrier) ter√° uma waitlist de virtual threads associadas √† ela.\nPara evitar Starvation das threads do Sistema Operacional, se uma waitlist de uma Platform Thread zerar, ela vai \u0026ldquo;roubar\u0026rdquo; tarefas de outras threads. Com isso, percebemos que executar um \u0026ldquo;runnable\u0026rdquo; em uma virtual thread, na realidade roda ele em uma thread real, portanto, se formos executar uma opera√ß√£o completamente n√£o bloqueante, virtual threads s√£o mais caras, √© um overhead, se for o caso, rode-as diretamente na thread comum. Virtual Threads s√£o feitas para executar c√≥digos bloqueantes!\n‚ö†Ô∏è Aviso\nVirtual Threads n√£o s√£o feitas para rodar opera√ß√µes em mem√≥ria!\nQuando opera√ß√µes bloqueantes rodam em virtual threads, elas se separam de sua Carrier Thread, usando \u0026ldquo;yield\u0026rdquo; para basicamente suspender a execu√ß√£o desse c√≥digo, liberando a thread principal para trabalhar com outras coisas, ent√£o essa virtual thread √© guardada na mem√≥ria principal (heap) e quando estiver pronta, √© colocada de novo na waitlist das threads principais, atrav√©s de um callback, mas isso tudo √© feito de maneira transparente!\nNote que Continuation.yield() respons√°vel por garantir esse processo para que a thread principal n√£o seja bloqueada, precisa ser implementado em opera√ß√µes bloqueantes (isso j√° est√° feito).\nPor exemplo, nessa linha de c√≥digo:\nresponse.send(future1.get() + future2.get()); Essas opera√ß√µes v√£o fazer com que a thread virutal monte e desmonte de sua carrier thread diversas vezes, provavelmente uma para cada call para get()e poss√≠velmente muitas outras vezes ao longo da execu√ß√£o de .send() gra√ßas √†s opera√ß√µes de I/O.\nExemplos Exemplo usando um executor que cria uma virtual thread para cada task bloqueante. void handle(Request request, Response response) { var url1 = ... var url2 = ... try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { var future1 = executor.submit(() -\u0026gt; fetchURL(url1)); var future2 = executor.submit(() -\u0026gt; fetchURL(url2)); response.send(future1.get() + future2.get()); } catch (ExecutionException | InterruptedException e) { response.fail(e); } } String fetchURL(URL url) throws IOException { try (var in = url.openStream()) { return new String(in.readAllBytes(), StandardCharsets.UTF_8); } } Mesmo procedimento usado no cap√≠tulo [[#2. O Patinho que Existe - Futures e Callback Hell]], mas usando virtual threads, que n√£o bloqueiam sua CPU! void handleRequest(Socket socket) { var request = new Request(socket); var futureWeather = new CompletableFuture\u0026lt;Weather\u0026gt;(); var futureRestaurants = new CompletableFuture\u0026lt;Restaurants\u0026gt;(); var futureTheaters = new CompletableFuture\u0026lt;Theaters\u0026gt;(); Thread.startVirtualThread(() -\u0026gt; futureWeather.complete(Weather.fetch(request))); Thread.startVirtualThread(() -\u0026gt; futureRestaurants.complete(Restaurants.fetch(request))); Thread.startVirtualThread(() -\u0026gt; futureTheaters.complete(Theaters.fetch(request))); new Page(request) .setWeather(futureWeather.join()) .setRestaurants(futureRestaurants.join()) .setTheaters(futureTheaters.join()) .send(); } Parecido com o exemplo 2, mas com um aroma mais funcional (Considerando que o executorService prov√™ virtual threads.) void handleRequest(Socket socket) { var futureRequest = CompletableFuture.supplyAsync(() -\u0026gt; new Request(socket), exec); var futureWeather = futureRequest.thenApplyAsync(Weather::fetch, exec); var futureRestaurants = futureRequest.thenApplyAsync(Restaurants::fetch, exec); var futureTheaters = futureRequest.thenApplyAsync(Theaters::fetch, exec); futureRequest .thenApplyAsync(Page::new, exec) .thenCombine(futureWeather, Page::setWeather) .thenCombine(futureRestaurants, Page::setRestaurants) .thenCombine(futureTheaters, Page::setTheaters) .thenAccept(Page::send); } } Uma maneira imperativa, sem o uso de futures void handleRequest(Socket socket) { var request = new Request(socket); var page = new Page(request); Thread t1 = Thread.startVirtualThread(() -\u0026gt; page.setWeather(Weather.fetch(request))); Thread t2 = Thread.startVirtualThread(() -\u0026gt; page.setRestaurants(Restaurants.fetch(request))); Thread t3 = Thread.startVirtualThread(() -\u0026gt; page.setTheaters(Theaters.fetch(request))); t1.join(); t2.join(); t3.join(); page.send(); } Um ponto negativo aqui √© que a Pagina deve ser thread safe e deve ser constru√≠da antes do uso dos fetches pois todos esses m√©todos podem alterar e acessar esse recurso ao mesmo tempo. Nesse caso, algum tipo de sincroniza√ß√£o ou lock ter√° de ocorrer (pinning nesse caso n√£o soa t√£o ruim pelo contexto que a cria√ß√£o/set de um objeto Page √© r√°pido)\nMais uma imagem de exemplo:\n‚ö†Ô∏è Aviso\nComo movemos coisas para a mem√≥ria e trazemos-as de volta, teremos problemas se estivermos usando ponteiros diretamente, mas voc√™ provavelmente n√£o vai fazer isso em JAVA. Apesar disso, o bloco \u0026ldquo;synchronized\u0026rdquo;, faz isso, e quando isso acontece, a task executa de maneira bloqueante na platform thread, sem ir para a heap memory como as virtual threads fazem, ou seja, o yield n√£o acontece. Chamamos isso de pinning, se voc√™ precisar usar \u0026ldquo;synchronized\u0026rdquo; em um bloco que leva uma quantidade consider√°vel de tempo (milisegundos), refatore-o para usar ReentrantLock, sen√£o voc√™ vai bloquear sua pequena quantidade de platform threads por bastante tempo :(\nAdicionalmente, voc√™ pode observar com facilidade os pinnings de platform threads: New diagnostics assist in migrating code to virtual threads and in assessing whether you should replace a particular use of¬†synchronized¬†with a¬†java.util.concurrent¬†lock:\nA JDK Flight Recorder (JFR) event is emitted when a thread blocks while pinned (see¬†JDK Flight Recorder). Habilitando no Spring Para habilitar virtual threads no SPRING, use:\nspring: threads: virtual: enabled: true ## ou spring.threads.virtual.enabled=true Essa altera√ß√£o j√° far√° com que seu servidor deixe de trabalhar com o antigo cen√°rio de uma thread por request, poss√≠velmente melhorando sua performance, mesmo sem muitas altera√ß√µes (No caso, isso provavelmente s√≥ ocorrer√° se voc√™ j√° estiver recebendo uma quantidade de chamadas o suficiente para esgotar sua pool de platform threads, que √© 200).\nConcorr√™ncia Estruturada - Feature Preview A feature de Concorr√™ncia Estruturada, tem como foco a escrita simples de c√≥digos concorentes, usando o paradigma imperativo.\nEm um passado distante, os c√≥digos que eram escritos eram recheados de \u0026ldquo;go-tos\u0026rdquo;, o que dificultava muito o custo de manuten√ß√£o pela dificuldade de entender o fluxo de execu√ß√£o do programa, estar dentro de um else n√£o significava necessariamente, que seu if falhou.\nO problema disso √© que c√≥digo concorrente, em sua forma atual √© como usar um go-to, voc√™ n√£o consegue saber quem invocou a instru√ß√£o que est√° rodando na thread.\n‚úÖ Objetivos\nPromover um estilo de programa√ß√£o concorrente que pode evitar riscos comuns associados ao uso de c√≥digos concorrentes e paralelizado Melhorar a observabilidade desse tipo de c√≥digo ‚ùå N√£o-Objetivos\nSubstituir maneiras de trabalhar com c√≥digo concorrente, como : ExecutorService¬†e¬†Future. Definir a API definitiva de Concorr√™ncia Estruturada para a plataforma java, permitindo que outras formas surjam em novas bibliotecas ou releases da JDK Definir maneiras de compartilhar streams de dados entre diferentes threads (exemplo: canais) Substituir o mecanismo de interrup√ß√£o de thread j√° existente, mas pode ser no futuro. ‚ö°‚ò†Ô∏è Structured Concurrency √© uma Feature Preview no JAVA 21\nOu seja, essa API pode sofrer altera√ß√µes ao longo do tempo, e para utiliz√°-la, precisamos explicitamente liberar seu uso.\nCom structured concurrency, criamos um escopo onde tarefas ir√£o rodar de maneira ass√≠ncrona com fork e join, e depois retornamos o resultado dessas opera√ß√µes\nPapos T√©cnicos para nerds O Fork-Join-Pool das Threads que as Virtuals usam Comentamos anteriormente como as Virtual Threads funcionavam em cima de threads reais: O scheduler de virtual threads √© um \u0026lsquo;work-stealing\u0026rsquo;¬†ForkJoinPool¬†que opera usando FIFO mode. O¬†paralelismo¬†padr√£o do scheduler √© a quantidade padr√£o de processadores (ou quantidade de threads dos seus processadores :) que sua m√°quina tem. D√° para alterar isso na prop:¬†jdk.virtualThreadScheduler.parallelism. Esse¬†ForkJoinPool¬†especificamente √© tunado de uma maneira diferente de um pool normal, que opera usando LIFO. Mais Refer√™ncias JEP 444: Virtual Threads\nState of Loom\nPerformance and scalability analysis of Java IO and NIO based server models, their implementation and comparison, Karabyn Petro. 2019\nVirtual threads: Are futures a thing of the past? - Java Magazine\nThe Ultimate Guide to Java Virtual Threads - Rock the JVM Blog/\nCompletableFuture with Virtual threads/\nJava Virtual Threads - Esse n√£o foi usado diretamente no texto, mas foi uma boa fonte de conhecimentos.\nhttps://www.youtube.com/watch?v=YQ6EpIk7KgY - Pelo engenheiro chefe respons√°vel pela concep√ß√£o da JEP das virtual threads.\n","permalink":"https://kaue.cat/posts/concorrencia-java/virtual-threads/","summary":"Seja bem vindo, esse daqui √© o √∫ltimo post da infinita s√©rie sobre concorr√™ncia em Java. A s√©rie √© focada em Java, mas esse post em especial apresenta conceitos relevantes para literalmente todas as linguagens e tamb√©m n√£o √© uma leitura muito extensiva :).\nNosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida Concorr√™ncia, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures CompletableFuture Virtual Threads O Artigo Primeiro, vamos estabelecer objetivos desse artigo:","title":"6. Virtual Threads em Java! Fazendo a sua aplica√ß√£o voar!"},{"content":"Seja bem vindo, esse daqui √© o quinto de 6 posts sobre concorr√™ncia em Java. A s√©rie √© focada em Java, mas esse post em especial apresenta conceitos relevantes para literalmente todas as linguagens e tamb√©m n√£o √© uma leitura muito extensiva :).\nNosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida Concorr√™ncia, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures 5. CompletableFuture Virtual Threads Introdu√ß√£o e \u0026ldquo;Join\u0026rdquo; Suponha esse c√≥digo:\nStoreService\npackage DCompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future; import java.util.concurrent.ThreadLocalRandom; import java.util.concurrent.TimeUnit; public class StoreService { private final ExecutorService executorService; public StoreService(ExecutorService executorService) { this.executorService = executorService; } public Double getPricesSync() throws InterruptedException { return getPrices(); } public Future\u0026lt;Double\u0026gt; getPricesAsync() { return executorService.submit(this::getPrices); } private Double getPrices() throws InterruptedException { System.out.println(\u0026#34;Getting prices...\u0026#34;); TimeUnit.SECONDS.sleep(1); return ThreadLocalRandom.current().nextDouble(20,200)*3; } } Main\npackage DCompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class Main { public static void main(String[] args) { var ex = Executors.newFixedThreadPool(2); ex.submit(Main::searchPricesAsync); ex.submit(Main::searchPricesSync); } private static void searchPricesSync(){ final ExecutorService ex = Executors.newFixedThreadPool(3); StoreService storeService = new StoreService(ex); try { System.out.println(storeService.getPricesSync()); System.out.println(storeService.getPricesSync()); System.out.println(storeService.getPricesSync()); System.out.println(storeService.getPricesSync()); System.out.println(storeService.getPricesSync()); } catch (InterruptedException e) { e.printStackTrace(); } } private static void searchPricesAsync() { final ExecutorService ex = Executors.newFixedThreadPool(5); StoreService storeService = new StoreService(ex); try { System.out.println(storeService.getPricesAsync().get()); System.out.println(storeService.getPricesAsync().get()); System.out.println(storeService.getPricesAsync().get()); System.out.println(storeService.getPricesAsync().get()); System.out.println(storeService.getPricesAsync().get()); } catch (Exception e) { e.printStackTrace(); } } } No caso, estamos executando as opera√ß√µes de busca sync e async simultaneamente (uma em cada thread) e para cada uma delas, estamos submetendo as tarefas as threads e pegando seus resultados de maneira s√≠ncrona e sem usar todas nossas threads.\nPera, mas se getPricesAsync nos retorna uma Future, como isso √© s√≠ncrono? Embora o processamento esteja sendo realizado paralelamente, nosso c√≥digo fica realmente bloqueado, esperando pela resposta do storeService.getPricesAsync(), e ele s√≥ faz o pedido de busca do pr√≥ximo c√≥digo ass√≠ncrono quando o anterior termina, portanto, n√£o estamos submetendo todas as tasks antes de esper√°-las.\n[‚ùó] Aten√ß√£o Note que aqui, o processameto s√≠ncrono √© o problema pois estamos bloqueando a thread que realiza searchPricesAsync, fazendo com que ela s√≥ pe√ßa que a pr√≥xima execu√ß√£o aconte√ßa quanto a anterior terminar. Mesmo que isso esteja sendo executado em uma thread auxiliar, estamos esperando a thread terminar seu trabalho para continuarmos o nosso.\nA solu√ß√£o seria dividir em duas partes:\nprivate static void searchPricesAsync() { final ExecutorService ex = Executors.newFixedThreadPool( 5); StoreService storeService = new StoreService(ex); Future\u0026lt;Double\u0026gt; pricesAsyncFuture1 = storeService.getPricesAsync(); Future\u0026lt;Double\u0026gt; pricesAsyncFuture2 = storeService.getPricesAsync(); Future\u0026lt;Double\u0026gt; pricesAsyncFuture3 = storeService.getPricesAsync(); Future\u0026lt;Double\u0026gt; pricesAsyncFuture4 = storeService.getPricesAsync(); Future\u0026lt;Double\u0026gt; pricesAsyncFuture5 = storeService.getPricesAsync(); try { System.out.println(pricesAsyncFuture1.get()); System.out.println(pricesAsyncFuture2.get()); System.out.println(pricesAsyncFuture3.get()); System.out.println(pricesAsyncFuture4.get()); System.out.println(pricesAsyncFuture5.get()); } catch (Exception e) { e.printStackTrace(); } } E agora sim temos essa belezinha de resultado:\nGetting prices... - pool-2-thread-4 Getting prices... - pool-2-thread-3 Getting prices... - pool-2-thread-1 Getting prices... - pool-2-thread-2 Getting prices... - pool-1-thread-2 Getting prices... - pool-2-thread-5 Apesar disso, o c√≥digo n√£o √© t√£o bonito assim, n√©? Vamos ver uma evolu√ß√£o dos Futures - CompletableFutures\npublic CompletableFuture\u0026lt;Double\u0026gt; getPricesWithCompletableFuture() { return CompletableFuture.supplyAsync(() -\u0026gt; { try { return getPrices(); } catch (InterruptedException e) { throw new RuntimeException(e); } }); } Aqui, note que s√≥ temos esse try porque getPricesRealmente pode jogar uma InterruptedException.\nPerceba tamb√©m que n√£o passamos o executor para o supplyAsync (poder√≠amos), mas ele possu√≠ um executor \u0026ldquo;nativo\u0026rdquo;: According to the¬†official documentation, if we use the async methods without explicitly providing an¬†Executor, the functions will be executed using¬†ForkJoinPool.commonPool().¬†Therefore, if we run the code snippet, we should expect to see one of the common¬†ForkJoinPool¬†workers: in my case, ‚ÄúForkJoinPool.commonPool-worker-1‚Ä≥. - https://www.baeldung.com/java-completablefuture-threadpool#async-methods\nprivate static void searchPricesAsync() { final ExecutorService ex = Executors.newFixedThreadPool( 5); StoreService storeService = new StoreService(ex); CompletableFuture\u0026lt;Double\u0026gt; pricesAsyncCompletableFuture1 = storeService.getPricesWithCompletableFuture(); CompletableFuture\u0026lt;Double\u0026gt; pricesAsyncCompletableFuture2 = storeService.getPricesWithCompletableFuture(); CompletableFuture\u0026lt;Double\u0026gt; pricesAsyncCompletableFuture3 = storeService.getPricesWithCompletableFuture(); CompletableFuture\u0026lt;Double\u0026gt; pricesAsyncCompletableFuture4 = storeService.getPricesWithCompletableFuture(); CompletableFuture\u0026lt;Double\u0026gt; pricesAsyncCompletableFuture5 = storeService.getPricesWithCompletableFuture(); System.out.println(pricesAsyncCompletableFuture1.join()); System.out.println(pricesAsyncCompletableFuture2.join()); System.out.println(pricesAsyncCompletableFuture3.join()); System.out.println(pricesAsyncCompletableFuture4.join()); System.out.println(pricesAsyncCompletableFuture5.join()); } Aqui, note que j√° n√£o precisamos usar try/catch nos joins, equivalente ao .get() do CompletableFuture\nUso com Streams! [‚ò£Ô∏è] Cuidado com Streams! Ao usarmos CompletableFuture com streams, precisamos ter um cuidado, nossas streams n√£o podem iterar a lista de CompletableFutures usando join, sen√£o, voltamos ao cen√°rio do processamento s√≠ncrono, o correto √© retornar essa stream em duas partes diferentes, uma que realiza o supply das tarefas para as threads e outra que realmente executa o join.\npublic class Main { private static final StoreServiceSync storeService = new StoreServiceSync(); private static final Set\u0026lt;String\u0026gt; STORES = Set.of(\u0026#34;BestPrice\u0026#34;, \u0026#34;LetsSaveBig\u0026#34;, \u0026#34;MyFavoriteShop\u0026#34;, \u0026#34;BuyItAll\u0026#34;); public static void main(String[] args) { searchPricesWithDiscount(); searchPricesWithDiscountAsync(); } private static void searchPricesWithDiscount(){ long start = System.currentTimeMillis(); STORES.stream() .map(store -\u0026gt; storeService.getQuote(store)) .peek(System.out::println) .map(quote -\u0026gt; storeService.applyDiscount(quote)) .forEach(System.out::println); long end = System.currentTimeMillis(); System.out.printf(\u0026#34;[SYNC] Time elapsed: %d ms\u0026#34;, end - start); } private static void searchPricesWithDiscountAsync(){ long start = System.currentTimeMillis(); List\u0026lt;CompletableFuture\u0026lt;Quote\u0026gt;\u0026gt; quotesFutures = STORES.stream() .map(store -\u0026gt; CompletableFuture.supplyAsync(() -\u0026gt; storeService.getQuote(store))) .toList(); List\u0026lt;Quote\u0026gt; quotes = quotesFutures.stream() .map(quoteCompletableFuture -\u0026gt; quoteCompletableFuture.join()) .peek(System.out::println) .toList(); List\u0026lt;CompletableFuture\u0026lt;String\u0026gt;\u0026gt; pricesFutures = quotes.stream() .map(currQuote -\u0026gt; CompletableFuture.supplyAsync(() -\u0026gt; storeService.applyDiscount(currQuote))) .toList(); List\u0026lt;String\u0026gt; prices = pricesFutures .stream() .map(priceFuture -\u0026gt; priceFuture.join()) .peek(System.out::println) .toList(); long end = System.currentTimeMillis(); System.out.printf(\u0026#34;[ASYNC] Time elapsed: %d ms\u0026#34;, end - start); } } Aqui, note que tanto as opera√ß√µes de getQuote quanto as de applyDiscount s√£o ass√≠ncronas, portanto, elas foram divididas em duas partes cada Resultados:\nQuote[store=MyFavoriteShop, price=60.0, discountCode=GOLD] MyFavoriteShop price is 54.00 Quote[store=BuyItAll, price=430.0, discountCode=DIAMOND] BuyItAll price is 344.00 Quote[store=LetsSaveBig, price=1300.0, discountCode=DIAMOND] LetsSaveBig price is 1040.00 Quote[store=BestPrice, price=150.0, discountCode=SILVER] BestPrice price is 142.50 [SYNC] Time elapsed: 16031 Quote[store=MyFavoriteShop, price=4430.0, discountCode=DIAMOND] Quote[store=BuyItAll, price=180.0, discountCode=DIAMOND] Quote[store=LetsSaveBig, price=690.0, discountCode=PLATINUM] Quote[store=BestPrice, price=1670.0, discountCode=SILVER] MyFavoriteShop price is 3544.00 BuyItAll price is 144.00 LetsSaveBig price is 586.50 BestPrice price is 1586.50 [ASYNC] Time elapsed: 4014 ms O c√≥digo funcionou bem, mas est√° bem verboso, vamos melhor√°-lo:\nEncadeando chamadas: ThenCompose O m√©todo thenCompose √© utilizado para encadear opera√ß√µes de forma que a segunda opera√ß√£o dependa do resultado da primeira, retornando um novo CompletableFuture. No exemplo a seguir, utilizamos thenCompose para aplicar o desconto ap√≥s obter a cota√ß√£o de forma ass√≠ncrona:\nprivate static void searchPricesWithDiscountAsyncNew(){ long start = System.currentTimeMillis(); List\u0026lt;CompletableFuture\u0026lt;String\u0026gt;\u0026gt; stringFutures = STORES.stream() .map(store -\u0026gt; CompletableFuture.supplyAsync(() -\u0026gt; storeService.getQuote(store))) .map(cf -\u0026gt; cf.thenCompose(quote -\u0026gt; CompletableFuture.supplyAsync(() -\u0026gt; storeService.applyDiscount(quote)))) .toList(); stringFutures.stream() .map(stringFuture -\u0026gt; stringFuture.join()) .forEach(System.out::println); long end = System.currentTimeMillis(); System.out.printf(\u0026#34;[NEW ASYNC] Time elapsed: %d ms\\n\u0026#34;, end - start); } Neste exemplo, thenCompose √© utilizado para encadear a obten√ß√£o da cota√ß√£o (getQuote) com a aplica√ß√£o do desconto (applyDiscount) de forma ass√≠ncrona, resultando em um c√≥digo mais conciso e leg√≠vel.\nThenApply O m√©todo thenApply √© utilizado quando queremos transformar o resultado de um CompletableFuture de forma independente do resultado de outras opera√ß√µes, retornando um novo CompletableFuture. Supondo que precis√°ssemos formatar a string do pre√ßo com desconto de uma forma espec√≠fica, poder√≠amos utilizar thenApply da seguinte maneira:\nprivate static void searchPricesWithDiscountAsyncNew() { long start = System.currentTimeMillis(); List\u0026lt;CompletableFuture\u0026lt;String\u0026gt;\u0026gt; stringFutures = STORES.stream() .map(store -\u0026gt; CompletableFuture.supplyAsync(() -\u0026gt; storeService.getQuote(store))) .map(cf -\u0026gt; cf.thenCompose(quote -\u0026gt; CompletableFuture.supplyAsync(() -\u0026gt; storeService.applyDiscount(quote)))) .map(cf -\u0026gt; cf.thenApply(discountedQuote -\u0026gt; String.format(\u0026#34;Discounted price: %s\u0026#34;, discountedQuote))) .toList(); stringFutures.stream() .map(stringFuture -\u0026gt; stringFuture.join()) .forEach(System.out::println); long end = System.currentTimeMillis(); System.out.printf(\u0026#34;[NEW ASYNC] Time elapsed: %d ms\\n\u0026#34;, end - start); } ThenApply vs ThenCompose Uma analogia para entendermos a diferen√ßa √© a seguinte:\nthenApply √© como Function.apply() enquanto thenCompose() √© como compor fun√ß√µes thenApply √© como um map e thenCompose √© como um flatMap: public CompletableFuture\u0026lt;UserInfo\u0026gt; getUserInfo(userId) public CompletableFuture\u0026lt;UserRating\u0026gt; getUserRating(UserInfo) CompletableFuture\u0026lt;CompletableFuture\u0026lt;UserRating\u0026gt;\u0026gt; apply = userInfo.thenApply(this::getUserRating); CompletableFuture\u0026lt;UserRating\u0026gt; compose = userInfo.thenCompose(this::getUserRating); Ou seja, no geral usamos thenApply se temos uma fun√ß√£o de mapeamento s√≠ncrona e thenCompose no caso oposto.\nYou would use¬†thenCompose¬†when you have an operation that returns a¬†CompletionStage¬†and¬†thenApply¬†when you have an operation\nThenApplyAsync, ThenComposeAsync Aqui, prefiro referenciar um conte√∫do muito bem escrito encontrado aqui:\nImagine for a moment that you have an application that allows users to register themselves and upon registration they will receive a confirmation email to confirm their account.\nYou don\u0026rsquo;t want the user to be waiting for ever if the mail server is down or if it takes a long time to compose the email or perform additional checks.\nYou would then use¬†thenApplyAsync¬†to fire off the send email logic because it is not crucial to your system. A user can always go back and say \u0026ldquo;send me another email\u0026rdquo;\nstatic CompletionStage\u0026lt;String\u0026gt; register(String username) { throw new UnsupportedOperationException(); } static void sendConfirmationEmail(String username) { throw new UnsupportedOperationException(); } public static void main(String[] args) throws InterruptedException { register(\u0026#34;user\u0026#34;).thenAcceptAsync(username -\u0026gt; sendConfirmationEmail(username)); } Here your system will respond when the registration is complete but it will not wait for the email to be sent resulting in improved responsiveness of your system.\nAllOf e AnyOf Outro ponto importante ao trabalhar com CompletableFuture √© o uso dos m√©todos est√°ticos allOf e anyOf, que s√£o muito √∫teis para lidar com m√∫ltiplos CompletableFutures de forma eficiente.\nallOf O m√©todo allOf √© usado quando voc√™ precisa esperar pela conclus√£o de todos os CompletableFutures em uma lista. Ele retorna um novo CompletableFuture que √© conclu√≠do somente quando todos os CompletableFutures na lista s√£o conclu√≠dos, independentemente de sucesso ou falha.\nPor exemplo, suponha que voc√™ tenha uma lista de CompletableFutures que representam opera√ß√µes ass√≠ncronas e deseja executar uma a√ß√£o ap√≥s a conclus√£o de todas elas:\nList\u0026lt;CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; futures = new ArrayList\u0026lt;\u0026gt;(); futures.add(CompletableFuture.runAsync(() -\u0026gt; System.out.println(\u0026#34;Task 1\u0026#34;))); futures.add(CompletableFuture.runAsync(() -\u0026gt; System.out.println(\u0026#34;Task 2\u0026#34;))); futures.add(CompletableFuture.runAsync(() -\u0026gt; System.out.println(\u0026#34;Task 3\u0026#34;))); CompletableFuture\u0026lt;Void\u0026gt; allFutures = CompletableFuture.allOf( futures.toArray(new CompletableFuture[0]) ); allFutures.thenRun(() -\u0026gt; System.out.println(\u0026#34;All tasks completed\u0026#34;));` Neste exemplo, allFutures ser√° conclu√≠do quando todas as tarefas ass√≠ncronas representadas pelos CompletableFutures na lista futures forem conclu√≠das.\nanyOf Por outro lado, o m√©todo anyOf √© usado quando voc√™ deseja esperar pela conclus√£o de apenas um dos CompletableFutures em uma lista. Ele retorna um novo CompletableFuture que √© conclu√≠do assim que um dos CompletableFutures na lista √© conclu√≠do, independentemente de sucesso ou falha.\nList\u0026lt;CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; futures = new ArrayList\u0026lt;\u0026gt;(); futures.add(CompletableFuture.runAsync(() -\u0026gt; System.out.println(\u0026#34;Task 1\u0026#34;))); futures.add(CompletableFuture.runAsync(() -\u0026gt; System.out.println(\u0026#34;Task 2\u0026#34;))); futures.add(CompletableFuture.runAsync(() -\u0026gt; System.out.println(\u0026#34;Task 3\u0026#34;))); CompletableFuture\u0026lt;Object\u0026gt; anyFuture = CompletableFuture.anyOf( futures.toArray(new CompletableFuture[0]) ); anyFuture.thenAccept(result -\u0026gt; System.out.println(\u0026#34;One task completed\u0026#34;)); Neste exemplo, anyFuture ser√° conclu√≠do assim que uma das tarefas ass√≠ncronas representadas pelos CompletableFutures na lista futures for conclu√≠da.\nRefer√™ncias https://www.baeldung.com/java-completablefuture-threadpool#async-methods https://www.youtube.com/watch?v=ZKDgjM_x4bo\u0026amp;list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW\u0026amp;index=241\u0026amp;ab_channel=DevDojo https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/CompletableFuture.html https://dzone.com/articles/understanding-lazy-evaluation-in-java-streams\n","permalink":"https://kaue.cat/posts/concorrencia-java/completablefuture/","summary":"Seja bem vindo, esse daqui √© o quinto de 6 posts sobre concorr√™ncia em Java. A s√©rie √© focada em Java, mas esse post em especial apresenta conceitos relevantes para literalmente todas as linguagens e tamb√©m n√£o √© uma leitura muito extensiva :).\nNosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida Concorr√™ncia, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures 5.","title":"5. CompletableFuture - Dominando o Ass√≠ncrono em Java!"},{"content":"Seja bem vindo, esse daqui √© o quarto de 6 posts sobre concorr√™ncia em Java. Nosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida Concorr√™ncia, agora melhor - Classes Thread Safe 4. Executors, Thread Pools e Futures CompletableFuture Virtual Threads Introdu√ß√£o Sabemos que Threads do JAVA s√£o Wrappers em torno de threads do SO, agora o importante de sabermos com essa informa√ß√£o √© termos ci√™ncia que threads do SO s√£o pesadas, portanto, cri√°-las a todo momento √© invi√°vel, mas √© isso que aprendemos at√© ent√£o no [[1. Threads! Processando em Paralelo e Ganhando Throughput]].\nNa realidade, existem duas maneiras de lidar com threads:\nControlar diretamente a cria√ß√£o e gerenciamento das Threads, instanciando uma Thread nova toda vez que a aplica√ß√£o precisar executar uma tarefa ass√≠ncrona. Abstrair o gerenciamento de Threads do resto da sua aplica√ß√£o, passando as tasks para um executor. A segunda abordagem, que vamos estudar agora, j√° soa melhor pelo poder de encapsular c√≥digo e lidar com threads de uma maneira mais abstrata, mas n√£o √© s√≥ isso. Executors O pacote¬†java.util.concurrent¬†define 3 interfaces de executors:\nExecutor, que permite come√ßar novas tasks. ExecutorService, uma subinterface de um¬†Executor, que adiciona features que ajudam a gerenciar o ciclo de vida das tasks e do executor. Quase sempre vamos usar isso aqui!! ScheduledExecutorService, Subinterface de¬†ExecutorService, que permite execu√ß√£o futura ou peri√≥dica de tasks. Executor Suponha que r √© um Runnable e e √© um executor\nNesse caso, voc√™ pode simplesmente usar:\ne.execute(r); As implementa√ß√µes de Executor S√£o menos espec√≠ficas e normalmente s√£o usados ExecutorService e ScheduledExecutorService.\nExecutorService A interface¬†ExecutorService¬†interface aceita¬†execute, mas tamb√©m adiciona¬†submit como um m√©todo um pouco mais vers√°til, que aceita objetos do tipo¬†Runnable,mas tamb√©m¬†Callable¬†, permitindo que task retorne um valor\nO¬†submitretorna uma¬†Future¬†usado para conseguir o retorno de um Callable\nScheduledExecutorService Assim como executorService, mas com algumas peculiaridades para rodar as tasks no futuro e/ou de maneira recorrente, saiba que exista e estude por fora caso seja necess√°rio!\nThread Pools A maioria das implementa√ß√µes no¬†java.util.concurrent¬†usam¬†pools de Threads, que s√£o worker threads. Esse tipo de Threads basicamente s√£o desacopladas do c√≥digo que v√£o rodar, ou seja, elas rodam algo, mas continuam vivas, elas n√£o nascem e morrem como costumamos fazer quando as instanciamos manualmente, essas threads podem ser usadas in√∫meras vezes. Usar esse tipo de Threads diminui bastante o trabalho da cria√ß√£o de objetos de Thread, que usam muita mem√≥ria, e criam bastante trabalho no processo de aloca√ß√£o e desaloca√ß√£o. Quando trabalharmos no Spring Boot, sua aplica√ß√£o j√° nasce com um ExecutorService com 200 Worker Threads (na configura√ß√£o padr√£o) que ser√£o usadas para atender os chamados ao seu servi√ßo, seguindo o padr√£o de uma thread processando um request, portanto, na realidade, s√≥ conseguimos processar 200 requests em paralelo.\n[ü§î] Pols Um pool de algum recurso computacional √© uma \u0026ldquo;piscina\u0026rdquo; cheia desse recurso espec√≠fico, a disposi√ß√£o para uso. Usamos Object Pooling quando estamos lidando com objetos caros de se instanciar e/ou destruir (ou objetos que devem ser frequentemente constru√≠dos). Um exemplo claro para desenvolvedores JAVA √© o Hikari, biblioteca que cria um pool de conex√µes de banco de dados (jdbc) e gerencia essas conex√µes, fornecendo uma conex√£o (objeto) dispon√≠vel quando pedido.\nPara criarmos um executorService que ser√° respons√°vel por atender as Tasks que passamos a ele com uma ThreadPool fixa, podemos usar:\nprivate final ExecutorService exec = Executors.newFixedThreadPool(16); Uma vantagem de usar uma pool de threads fixas, √© que garantimos que nossa aplica√ß√£o sempre processar√° uma quantidade de requests que consegue simult√¢neamente, se estiv√©ssemos criando e matando threads a todo momento, seria poss√≠vel que nossa aplica√ß√£o parasse totalmente gra√ßas ao estouro do limite de recursos dispon√≠veis.\njava.util.concurrent.Executors¬†Tamb√©m oferece outras factories sem ser newFixedThreadPool(int):\nO m√©todo¬†newCachedThreadPool. O m√©todo¬†newSingleThreadExecutor¬†. Diferentes outras factories que retornam vers√µes¬†ScheduledExecutorService¬†versions dos executores que falamos antes. Exemplo: Future e Callable package CallableFuture; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ThreadLocalRandom; class Spawner implements Callable\u0026lt;String\u0026gt; { @Override public String call() throws Exception { int random = ThreadLocalRandom.current().nextInt(100,400); Thread.sleep(random); return String.format(\u0026#34;Spawned %d creatures\u0026#34;, random); } } public class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { var spawner = new Spawner(); System.out.println(\u0026#34;Spawnando:\u0026#34;); ExecutorService executorService = Executors.newFixedThreadPool(10); Future\u0026lt;String\u0026gt; futureResponse1 = executorService.submit(spawner); Future\u0026lt;String\u0026gt; futureResponse2 = executorService.submit(spawner); // A resposta literalmente vir√° no futuro! String response1 = futureResponse1.get(); // espera at√© que o retorno venha (block the i/o) String response2 = futureResponse2.get(); } } Futures - O porqu√™ ser ass√≠ncrono: J√° comentamos anteriormente sobre os Futures e os vimos em a√ß√£o nesse √∫ltimo exemplo, vamos falar um pouco sobre esse contexto.\nDe maneira geral, escrevemos c√≥digo s√≠ncrono, onde o programa chega na linha x e executa as instru√ß√µes naquela linha, o c√≥digo ass√≠ncrono √© um pouco diferente, l√°, pedimos para algo (nesse caso, uma Thread) que execute essa instru√ß√£o, e sabemos que isso eventualmente ser√° executado, √© uma promessa de execu√ß√£o.\nImagine que em um sistema financeiro que usa uma thread para a renderiza√ß√£o da tela e a mesma para ouras opera√ß√µes, nesse caso, quando voc√™ clicar em \u0026ldquo;Gerenciar cota√ß√£o do dolar\u0026rdquo;, sua thread (ou seja, sua aplica√ß√£o) inteira ficar√° bloqueada esperando a cota√ß√£o do dolar chegar (provavelmente por alguma API).\nSe essa chamada ocorrer de maneira ass√≠ncrona, ela ir√° travar por alguns nanosegundos, apenas registrando a chamada para a API, mas n√£o necessariamente esperando seu retorno, provavelmente registrando um callback para quando esse retorno realmente acontecer.\nNesse cen√°rio, notamos que para utilizarmos o poder do processamento em paralelo, faz sentido usarmos do assincronismo, caso contr√°rio, estaremos apenas delegando uma tarefa para a outra thread e esperando pelo seu retorno, sem muitos benef√≠cios\nExemplo bobo de como um c√≥digo pode ser feito mais r√°pido com multithreading + assincronismo, lendo dois arquivos paralelamente:\nNesse cen√°rio, poder√≠amos ainda usar mais threads para a realiza√ß√£o das opera√ß√µes matem√°ticas, desde que elas possam ser feitas por m√∫ltiplas threads de verdade.\nTimeout Podemos (e devemos quase sempre) definir timeouts para tarefas ass√≠ncronas, evitando que nossas threads fiquem muito tempo (ou indefinidamente) esperando algo acontecer: future.get(2, TimeUnit.SECONDS);\nRefer√™ncia https://docs.oracle.com/javase/tutorial/essential/concurrency/exinter.html https://www.youtube.com/watch?v=y7PUfmtWIXs\u0026amp;list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW\u0026amp;index=237\u0026amp;ab_channel=DevDojo\n","permalink":"https://kaue.cat/posts/concorrencia-java/executors-e-threadpools/","summary":"Seja bem vindo, esse daqui √© o quarto de 6 posts sobre concorr√™ncia em Java. Nosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida Concorr√™ncia, agora melhor - Classes Thread Safe 4. Executors, Thread Pools e Futures CompletableFuture Virtual Threads Introdu√ß√£o Sabemos que Threads do JAVA s√£o Wrappers em torno de threads do SO, agora o importante de sabermos com essa informa√ß√£o √© termos ci√™ncia que threads do SO s√£o pesadas, portanto, cri√°-las a todo momento √© invi√°vel, mas √© isso que aprendemos at√© ent√£o no [[1.","title":"4. Executors, Thread Pools e Futures em Java"},{"content":"Seja bem vindo, esse daqui √© o terceiro de 6 posts sobre concorr√™ncia em Java. Nosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida 3. Concorr√™ncia, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures CompletableFuture Virtual Threads Disclaimer: Esse post em espec√≠fico usa como principal refer√™ncia o curso gr√°tis de JAVA Do DevDojo, chamado Java virado no jiraya, que est√° publicado no youtube!. Recomendo muito assistirem os v√≠deos e fazerem os exemplos com o grandess√≠simo William Suane.\nIntrodu√ß√£o At√© agora, est√°vamos trabalhando e vendo threads de maneira mais cru, criando threads na m√£o e trabalhando com ela em um n√≠vel bem baixo. Apesar disso, essa n√£o √© a maneira convencional de trabalhar com ƒáodigos concorrentes em Java. A linguagem adicionou um pacote, em java.util.concurrent que √© uma camada de abstra√ß√£o para trabalhar com esses recursos de maneira mais eficiente, vamos come√ßar a entender esse pacote:\nAtomicInteger Suponha que temos um jogo que trabalha de maneira que precisam ser spawnados 45 mil personagens em um mapa no in√≠cio do jogo, e para isso, vamos usar algumas threads para fazer esse spawn:\npublic class Spawner implements Runnable { private final int amountToSpawn; public Integer getAmountSpawned() { return amountSpawned; } private Integer amountSpawned = 0; public Spawner(int amountToSpawn) { this.amountToSpawn = amountToSpawn; } @Override public void run() { System.out.println(\u0026#34;Spawning...\u0026#34;); for (int i = 0; i \u0026lt; amountToSpawn; i++) { this.amountSpawned++; } } } public class Main { public static void main(String[] args) throws InterruptedException { System.out.println(\u0026#34;Spawnando:\u0026#34;); Spawner spawner = new Spawner(15000); var t1 = new Thread(spawner); var t2 = new Thread(spawner); var t3 = new Thread(spawner); t1.start();t2.start();t3.start(); t1.join();t2.join();t3.join(); System.out.println(\u0026#34;Spawned: \u0026#34; + spawner.getAmountSpawned()); } }``` Curiosamente, nosso resultado √©: `Spawned: 30718` Mas sincronizando, temos a quantidade correta: ```java public class Spawner implements Runnable { private final Integer amountToSpawn; private final Object sync = new Object(); public Integer getAmountSpawned() { return amountSpawned; } private Integer amountSpawned = 0; public Spawner(int amountToSpawn) { this.amountToSpawn = amountToSpawn; } @Override public void run() { System.out.println(\u0026#34;Spawning...\u0026#34;); for (int i = 0; i \u0026lt; amountToSpawn; i++) { synchronized (sync){ this.amountSpawned++; } } } } // Spawned: 45000 Apesar disso, fica meio obvio que nossa performance est√° degradada, ao inv√©s disso, podemos usar AtomicInteger e esquecer os problemas:\nimport java.util.concurrent.atomic.AtomicInteger; public class Spawner implements Runnable { private final Integer amountToSpawn; public AtomicInteger getAmountSpawned() { return amountSpawned; } private final AtomicInteger amountSpawned = new AtomicInteger(0); public Spawner(int amountToSpawn) { this.amountToSpawn = amountToSpawn; } @Override public void run() { System.out.println(\u0026#34;Spawning...\u0026#34;); for (int i = 0; i \u0026lt; amountToSpawn; i++) { this.amountSpawned.incrementAndGet(); } } } Esses objetos em java que encapsulam essas l√≥gicas de maneira geral possuem mais performance por implementar algoritmos que evitem condi√ß√µes de corrida de maneiras eficientes. √© sempre legal utiliz√°-los\nLock e ReentrantLock No exemplo anterior de AtomicInteger, quando usamos synchronized para tornar o m√©todo vi√°vel, note que usei um objeto cru, somente para cuidar da quest√£o do sincronismo. Os locks na realidade servem exatamente para isso, mas com algumas outras vantagens:\nFairness: No construtor, podemos especificar um fairness booleano, que diz que o mecanismo de lock deve tentar \u0026ldquo;passar o bast√£o\u0026rdquo; para a thread que est√° esperando a entrada na zona cr√≠tica a mais tempo\nMecanismo de \u0026ldquo;tentativa\u0026rdquo;: Tente acessar o recurso por x tempo, caso contr√°rio, v√° embora\nPossibilidade de interromper a thread que espera pelo recurso\npackage BLocks; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class Spawner implements Runnable { private final Integer amountToSpawn; private final Lock lock = new ReentrantLock(); public Integer getAmountSpawned() { return amountSpawned; } private Integer amountSpawned = 0; public Spawner(int amountToSpawn) { this.amountToSpawn = amountToSpawn; } @Override public void run() { System.out.println(\u0026#34;Spawning...\u0026#34;); for (int i = 0; i \u0026lt; amountToSpawn; i++) { lock.lock(); this.amountSpawned++; lock.unlock(); } } } Como uma exce√ß√£o pode ocorrer no peda√ßo bloqueado, o ideal √© usarmos try/finally!\ntry { lock.lock(); this.amountSpawned++; } finally { lock.unlock(); } Problema: o c√≥digo fica feio pra caralho! Normalmente usamos o synchronized por conta disso, a menos que voc√™ precise de fairness ou das outras fun√ß√µes que especificamos.\nUm ponto importante aqui, que vai ser explicado com mais detalhes no capitulo sobre virtual threads √© que o uso de synchronized pode ser um grande problema ao trabalhar com virtual threads, incluidas oficialmente no Java 21+\nSe voc√™ √© adepto ao lombok, saiba que foram adicionadas duas annotations bem recentemente: Locked e synchronized, especialmente locked, pode tornar seu c√≥digo mais bonito.\nPara mais detalhes sobre Locks, Conditions, CopyOnWriteArrayList, ArrayBlockingQueue, LinkedTransferQueue, ReentrantReadWriteLock (Toma conta de leitura e escrita), etc, recomendo ver a playlist do devDojo, vou parar de roubar os exemplos dele (nesse assunto) por aqui!\nRefer√™ncias Andre Leon, meu professor de S.O!! https://www.youtube.com/@DevDojoBrasil https://fidelissauro.dev/concorrencia-paralelismo/ ","permalink":"https://kaue.cat/posts/concorrencia-java/thread-safe/","summary":"Seja bem vindo, esse daqui √© o terceiro de 6 posts sobre concorr√™ncia em Java. Nosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida 3. Concorr√™ncia, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures CompletableFuture Virtual Threads Disclaimer: Esse post em espec√≠fico usa como principal refer√™ncia o curso gr√°tis de JAVA Do DevDojo, chamado Java virado no jiraya, que est√° publicado no youtube!","title":"3. Classes Thread Safe em Java -  Conceito e Introdu√ß√£o"},{"content":"Seja bem vindo, esse daqui √© o segundo de 6 posts sobre concorr√™ncia em Java. A s√©rie √© focada em Java, mas esse post em especial apresenta conceitos relevantes para literalmente todas as linguagens e tamb√©m n√£o √© uma leitura muito extensiva :).\nNosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput 2. Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida Concorr√™ncia, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures CompletableFuture Virtual Threads Sincroniza√ß√£o de Threads Um assunto muito abordado em diversos cursos e disciplinas, at√© mesmo arquitetura de computadores e sistemas operacionais √© o sincronismo de threads? Mas por qu√™? Esse t√≥pico vai ser relativamente te√≥rico, mas bem importante, juro.\nExemplo: Um problema cl√°ssico de sincronismo (nesse caso sendo retratado por uma implementa√ß√£o Do DevDojo) √© exemplo que envolve saque monet√°rio em uma mesma conta, por threads diferentes. Quando threads diferentes acessam um mesmo recurso, acontece o que chamamos de condi√ß√£o de corrida. Esse fen√¥meno pode ocasionar em erros grav√≠ssimos e dif√≠ceis de se perceber, olhe:\nNote que ambos v√£o sacar dinheiro ao mesmo tempo quando tem 10 reais an conta, caindo na condi√ß√£o da balance ser igual a quantia, apesar disso, como ambos est√£o correndo e acessando uma mesma zona cr√≠tica, acontece uma inconsist√™ncia, onde uma thread desconta 10 de 10, e o saldo fica 0, e a outra desconta 10 de 0, deixando o saldo negativo.\nComo podemos resolver isso?!\nOpera√ß√µes At√¥micas Uma opera√ß√£o at√¥mica, (na programa√ß√£o concorrente e/ou paralela), √© uma opera√ß√£o indivis√≠vel que √© executada em sua totalidade ou n√£o √© executada de forma alguma. Isso significa que, quando uma opera√ß√£o √© marcada como at√¥mica, ==ela √© tratada como uma unidade indivis√≠vel de execu√ß√£o, mesmo em um ambiente com m√∫ltiplas threads ou processos concorrentes.== Isso √© importante pois ao trabalharmos com programa√ß√£o paralela ou concorrente, tentamos dividir a carga em partes menores, enviadas para as threads\nA atomicidade √© fundamental para evitar condi√ß√µes de corrida e garantir a consist√™ncia dos dados compartilhados entre threads ou processos. Em uma opera√ß√£o at√¥mica, n√£o h√° possibilidade de que outra thread ou processo interrompa a opera√ß√£o no meio do caminho, o que reduz significativamente o risco de conflitos e resultados indesejados.\nExemplos:\nIncremento e Decremento: A opera√ß√£o de incremento ou decremento de uma vari√°vel √© geralmente implementada como uma opera√ß√£o at√¥mica para evitar condi√ß√µes de corrida ao modificar a mesma vari√°vel de diferentes threads. Troca (Swap): A opera√ß√£o de troca de valores entre duas vari√°veis √© frequentemente implementada de forma at√¥mica para garantir que a troca ocorra completamente sem interrup√ß√µes. Teste e Defini√ß√£o (Test-and-Set): Uma opera√ß√£o que verifica o valor de uma vari√°vel e a define para um novo valor se a condi√ß√£o for atendida, tudo de forma at√¥mica. Opera√ß√µes de Bloqueio e Desbloqueio (Locking/Unlocking): Opera√ß√µes de bloqueio e desbloqueio s√£o frequentemente usadas para garantir que uma se√ß√£o cr√≠tica do c√≥digo seja executada por apenas uma thread por vez, evitando conflitos. Essas opera√ß√µes s√£o normalmente implementadas de forma at√¥mica. A zona cr√≠tica A \u0026ldquo;zona cr√≠tica\u0026rdquo; diz respeito √† uma se√ß√£o de c√≥digo onde uma thread acessa ==recursos compartilhados==, como vari√°veis, mem√≥ria ou objetos, que n√£o devem ser modificados por outras threads concorrentes. Essa regi√£o protegida, normalmente, √© acessada por uma thread / programa de cada vez. O objetivo √© tornar a opera√ß√£o sobre o recurso compartilhado¬†at√¥mica. Uma regi√£o cr√≠tica geralmente termina num tempo espec√≠fico, e uma linha de execu√ß√£o ou¬†processo¬†s√≥ precisa esperar um tempo espec√≠fico para entr√°-la. Alguns mecanismos de¬†sincroniza√ß√£o¬†s√£o necess√°rios para implementar a entrada e a sa√≠da de uma regi√£o cr√≠tica para assegurar o uso exclusivo, como por exemplo um¬†sem√°foro, √© o que veremos mais a frente.\nCondi√ß√£o de Corrida i. Acontece quando duas ou mais threads tentam modificar um recurso compartilhado ao mesmo tempo, resultando em resultados n√£o determin√≠sticos e possivelmente err√¥neos.\nDeadlocks i. Muitas vezes os pr√≥prios synchronizers (algor√≠tmos que alternam o acesso √† recursos por threads) causam o deadlock. Inconsist√™ncias\nUm dos fatores para isso acontecer √© o dado cache! Podemos usar recursos do java como \u0026ldquo;Volatile\u0026rdquo; que diz que sempre que formos acessar aquele recurso, ele tem que ser verificado de novo!\nCaso StackOverflow - Muiito Did√°tico (Explica volatile)\nhttps://pt.stackoverflow.com/a/116080\nlong i = 0; void thread1() { ... i++; ... } void thread2() { ... if (i == 1) { fazAlgo(); } ... } No exemplo, as duas threads acessam a mesma vari√°vel. Assumindo que a leitura da¬†thread2 ocorre, numa sequ√™ncia de tempo, exatamente ap√≥s o incremento da¬†thread1, voc√™ acha que pode ocorrer algum problema de concorr√™ncia, considerando que o incremento¬†parece uma opera√ß√£o at√¥mica?\nUma an√°lise ing√™nua diria que est√° tudo bem com as¬†threads¬†pois as duas executam opera√ß√µes at√¥micas de escrita e leitura, logo¬†fazAlgo¬†seria executado sem problemas.\nErrado.\nCada¬†thread¬†pode¬†estar sendo executada em um processador diferente. Cada processador¬†pode¬†ter um¬†cache¬†pr√≥prio. Vari√°veis s√£o lidas e gravadas primeiro no cache local antes de irem para a mem√≥ria principal. Ent√£o,¬†√© poss√≠vel¬†que a segunda¬†thread¬†leia o valor antigo da vari√°vel.\nO cen√°rio problem√°tico ocorreria assim:\nT1 l√™ o valor de¬†i = 0¬†da mem√≥ria principal e faz o incremento; o novo valor¬†i = 1¬†√© armazenado no cache local, mas n√£o na mem√≥ria principal. T2 l√™ o valor de¬†i = 0¬†da mem√≥ria principal e n√£o entra no¬†if. Pior que isto, vari√°veis de 64 bits como¬†long¬†e¬†double¬†podem ter sua escrita em mem√≥ria dividida pela JVM em dois ciclos de 32 bits, o que poderia levar uma leitura completamente corrompida de seus valores. Tais cen√°rios s√£o relativamente raros, mas extremamente dif√≠ceis de identificar em softwares complexos, causando aquele tipo de problema intermitente e ocasional que acaba sendo varrido para debaixo do tapete.\nA solu√ß√£o, neste caso, √© simples:\nvolatile long i = 0; Um atributo vol√°til tem garantia de que o valor atualizado estar√° sempre dispon√≠vel para outras¬†threads, sendo gravado na mem√≥ria principal assim que atualizado, de forma at√¥mica.\nIsso significa que, sempre que o valor for modificado em um processador, ocorrer√° um¬†flush¬†para a mem√≥ria principal, portanto as outras¬†threads¬†v√£o ver sempre o valor mais atualizado e n√£o um poss√≠vel valor defasado.\nClaro que isso n√£o √© gratuito. Fazer o¬†flush¬†do cache para a mem√≥ria principal penaliza o desempenho, afinal existe uma raz√£o para os fabricantes de hardware colocarem caches nos processadores. √â muito mais r√°pido acessar um registrador ou cache prim√°rio do que acessar a mem√≥ria RAM.\nUma solu√ß√£o alternativa seria usar m√©todos de sincroniza√ß√£o como um bloco¬†synchronized¬†ou vari√°veis at√¥micas como¬†AtomicLong, os quais podem ser necess√°rios quando h√° modifica√ß√£o concorrente, mas que s√£o mais lentos.\nNo caso de escrita concorrente, como bem lembrado pelo Rafael na outra resposta, uma vari√°vel¬†volatile¬†ainda poderia incorrer em condi√ß√£o de corrida pois as duas threads podem ler o mesmo valor da mem√≥ria principal, e o valor final dependeria de qual das threads escreveria ele por √∫ltimo.\nMecanismos que regulam acesso √† zonas cr√≠ticas Existem diversos mecanismos que regulam acessos √†s zonas cr√≠ticas do software, evitando condi√ß√µes de corridas - race conditions:\nLocks Locks s√£o o mecanismo padr√£o, que basicamente dizem se algu√©m tem pode entrar ou n√£o na zona cr√≠tica, √© como aquele banheiro qu√≠mico, ou voc√™ pode entrar, ou tem algu√©m l√° dentro e voc√™ tem que esperar pra entrar.\nSem√°foros Apesar de ter sido inventado em 1965, por E. Dijkstra, os sem√°foros s√£o a t√©cnica mais usada atualmente Um sem√°foro √© uma vari√°vel (s), associada a uma regi√£o cr√≠tica, sobre a qual podem incidir duas opera√ß√µes: Opera√ß√£o Down: verifica se o valor de s √© maior que zero.¬†Se for, o valor √© decrementado. Sen√£o, a tarefa √© bloqueada e o valor de s permanece zero. Opera√ß√£o Up: incrementa o valor de s, e desbloqueia as demais tarefas se o valor for zero. Ou seja, um sem√°faro com valor s inicial de 3, permite que 3 tarefas entrem na zona cr√≠tica (3 Downs, descendo o valor para 2,1 e 0)\nTamb√©m existem Sem√°foros Conhecidos como bin√°rios ou mutex, que √© basicamente um sem√°foro de valor s=1, ou seja, acomoda apenas um √∫nico thread, √© um lock convencional :p.\nMecanismos em Java: Syncronized O mais comum √© usarmos a keyword syncronized antes da declara√ß√£o de algum m√©todo ou vari√°vel, indicando que ela tem um lock, ou seja, apenas uma thread pode acess√°-la por vez, como uma passagem de bast√£o Ent√£o, no exemplo anterior, adicionar synchronized resolve nosso problema:\nprivate synchronized void withdrawal(int amount) { if (account.getBalance() \u0026gt;= amount) { System.out.println(getThreadName() + \u0026#34; est√° indo sacar dinheiro\u0026#34;); account.withdrawal(amount); System.out.println(getThreadName() + \u0026#34; completou o saque, valor atual da conta \u0026#34; + account.getBalance()); } else { System.out.println(\u0026#34;Sem dinheiro para \u0026#34; + getThreadName() + \u0026#34; efetuar o saque \u0026#34; + account.getBalance()); } } [‚ùó] Importante Sleeps e outras opera√ß√µes demoradas n√£o liberam o lock / passa o bast√£o para outra thread, na realidade, essas threads esperando sua vez ficam bloqueadas na \u0026ldquo;fila\u0026rdquo;\nPodemos tamb√©m usar o synchronized assim: dividindo uma parte da opera√ß√£o como at√¥mica, mas deixando a outra aberta para m√∫ltiplas threads. Nesse caso marcamos qual objeto sofrer√° o lock e a opera√ß√£o\nprivate void withdrawal(int amount) { System.out.println(getThreadName() +\u0026#34; #### fora do synchronized\u0026#34;); synchronized (account) { System.out.println(getThreadName() +\u0026#34; **** dentro do synchronized\u0026#34;); if (account.getBalance() \u0026gt;= amount) { System.out.println(getThreadName() + \u0026#34; est√° indo sacar dinheiro\u0026#34;); account.withdrawal(amount); System.out.println(getThreadName() + \u0026#34; completou o saque, valor atual da conta \u0026#34; + account.getBalance()); } else { System.out.println(\u0026#34;Sem dinheiro para \u0026#34; + getThreadName() + \u0026#34; efetuar o saque \u0026#34; + account.getBalance()); } } } Nesse caso, estamos sincronizando apenas o objeto account, um ponto de aten√ß√£o aqui √© n√£o trocar a refer√™ncia desse objeto: como fazer account = new Account() por isso, uma boa pr√°tica √© marcar objetos sincronizados como final.\n[ü§ì‚òùÔ∏è] Mutex / Locks Distribu√≠dos Alguns sistemas podem optar por usar locks distribu√≠dos entre diferentes processos, isso pode ser feito direto no banco de dados (se for uma aplica√ß√£o como uma API com m√∫ltiplas inst√¢ncias rodando) ou usando solu√ß√µes como o Apache Zookeper, que possu√≠ recursos avan√ßados para tomar conta dos seus processos, evitando starvation \u0026amp; race conditions\nThread-Safe Classes \u0026ldquo;thread-safe\u0026rdquo; s√£o classes ou componentes de software projetados para funcionar de maneira segura em ambientes multithread, onde v√°rias threads podem acess√°-los e manipul√°-los simultaneamente. Em outras palavras, uma classe thread-safe √© projetada para evitar condi√ß√µes de corrida, deadlocks e outras situa√ß√µes problem√°ticas que podem ocorrer quando v√°rias threads acessam recursos compartilhados.\n[‚ùó] Threads safe que\u0026hellip; n√£o s√£o thread safe Usar uma classe como Collections.synchronizedList n√£o garante que a classe √© thread-safe se uma camada a mais de c√≥digo n√£o thread-safe for colocada em cima dela (Exemplo, uma classe que faz o add e remove, mas n√£o se importa com a sincroniza√ß√£o desses m√©todos).\nUma classe realmente Thread safe:\nclass ThreadSafeNames { private final List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); public synchronized void add (String name){ names.add(name); } public synchronized void removeFirst(){ if(names.size() \u0026gt; 0){ System.out.println(Thread.currentThread().getName()); System.out.println(names.remove(0)); } } } public class ThreadSafeTest01 { public static void main(String[] args) { ThreadSafeNames threadSafeNames = new ThreadSafeNames(); threadSafeNames.add(\u0026#34;Junkrat\u0026#34;); Runnable r = threadSafeNames::removeFirst; new Thread(r).start(); new Thread(r).start(); } } [ü§ì‚òùÔ∏è] Classes √öteis Diversas classes do package java.util.concurrent s√£o √∫teis para concorr√™ncia, exemplos:\nConcurrentHashMap CopyOnWriteArrayList (Uma lista thread-safe em que as opera√ß√µes de leitura n√£o requerem sincroniza√ß√£o, tornando-as eficientes para leitura intensiva.) AtomicInteger (Uma classe que fornece opera√ß√µes at√¥micas para incrementar e atualizar inteiros.) Semaphore - Sem√°foros! Exchanger: Uma classe que permite que duas threads troquem objetos em um ponto de encontro, facilitando a comunica√ß√£o entre threads. Exemplo: Envio de Email Podemos ter um servi√ßo para envio de email, onde temos uma thread colocando emails em uma fila, e sempre notificando as worker-threads quando um email novo chegar, assim agilizando o envio por m√∫ltiplas threads.\npublic class Members { private final Queue\u0026lt;String\u0026gt; emails = new ArrayBlockingQueue\u0026lt;\u0026gt;(10); private boolean open = true; public boolean isOpen() { return open; } public int pendingEmails() { synchronized (emails) { return emails.size(); } } public void addMemberEmail(String email) { synchronized (this.emails) { String threadName = Thread.currentThread().getName(); System.out.println(threadName + \u0026#34; Adicionou email na lista\u0026#34;); this.emails.add(email); this.emails.notifyAll(); } } public String retrieveEmail() throws InterruptedException { System.out.println(Thread.currentThread().getName() + \u0026#34; checking if there are emails\u0026#34;); synchronized (this.emails) { while (this.emails.size() == 0) { if (!open) return null; System.out.println(Thread.currentThread().getName() + \u0026#34; N√£o tem email dispon√≠vel na lista, entrando em modo de espera\u0026#34;); this.emails.wait(); } return this.emails.poll(); } } public void close() { open = false; synchronized (this.emails) { System.out.println(Thread.currentThread().getName() + \u0026#34; Notificando todo mundo que n√£o estamos mais pegando emails\u0026#34;); } } } [‚ùó] Aten√ß√£o! addMemberEmail e retrieveEmail podem ser usados ao mesmo tempo: sim, eles podem ser usados ao mesmo tempo. Embora ambos usem o mesmo objeto (this.emails) como bloqueio, eles est√£o bloqueando diferentes partes cr√≠ticas do c√≥digo. Enquanto addMemberEmail est√° bloqueando para adicionar um email, retrieveEmail est√° bloqueando para verificar e remover um email. Isso permite que esses m√©todos sejam chamados simultaneamente sem interferir um no outro.\npublic class EmailDeliveryService implements Runnable{ private final Members members; public EmailDeliveryService(Members members) { this.members = members; } @Override public void run() { String threadName = Thread.currentThread().getName(); System.out.println(threadName +\u0026#34; starting to deliver emails...\u0026#34;); while(members.isOpen() || members.pendingEmails() \u0026gt; 0){ try { String email = members.retrieveEmail(); if(email == null) continue; System.out.println(threadName + \u0026#34; enviando email para \u0026#34; + email); Thread.sleep(2000); System.out.println(threadName + \u0026#34; enviou email com sucesso para \u0026#34;+ email); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\u0026#34;Todos os emails foram enviados com sucesso!\u0026#34;); } } public class EmailDeliveryTest01 { public static void main(String[] args) { Members members = new Members(); Thread jiraya = new Thread(new EmailDeliveryService(members), \u0026#34;Jiraya\u0026#34;); Thread kakashi = new Thread(new EmailDeliveryService(members), \u0026#34;Kakashi\u0026#34;); jiraya.start(); kakashi.start(); while(true){ String email = JOptionPane.showInputDialog(\u0026#34;Entre com seu email\u0026#34;); if(email == null || email.isEmpty()){ members.close(); break; } members.addMemberEmail(email); } } } Exemplo Cl√°ssico : Jantar Dos Fil√≥sofos (Deadlock) https://blog.pantuza.com/artigos/o-jantar-dos-filosofos-problema-de-sincronizacao-em-sistemas-operacionais\nO jantar dos fil√≥sofos foi pensado por Dijkstra (esse cara realmente foi foda n√©)\nCinco fil√≥sofos est√£o sentados em uma mesa redonda para jantar. Cada fil√≥sofo tem um prato com espaguete √† sua frente. Cada prato possui um garfo para pegar o espaguete. O espaguete est√° muito escorregadio e, para que um fil√≥sofo consiga comer, ser√° necess√°rio utilizar dois garfos.\nLembre-se que √© apenas uma analogia. Nesse sentido, cada fil√≥sofo alterna entre duas tarefas:¬†comer¬†ou¬†pensar. Quando um fil√≥sofo fica com fome, ele tenta pegar os garfos √† sua esquerda e √† sua direita; um de cada vez, independente da ordem. Caso ele consiga pegar¬†dois garfos, ele come durante um determinado tempo e depois recoloca os garfos na mesa. Em seguida ele volta a pensar.\nVoc√™ √© capaz de propor um¬†algoritmo¬†que implemente cada¬†fil√≥sofo¬†de modo que ele execute as tarefas de¬†comer¬†e¬†pensar¬†sem¬†nunca¬†ficar¬†travado?\nN√£o vou colocar a solu√ß√£o aqui, mas se te deixou curioso, acesse o link acima, √© uma √≥tima explica√ß√£o. A solu√ß√£o normalmente aceita √© usar os sem√°foros que falamos anteriormente\nAgradecimentos Especiais Obrigado Andr√© Leon, professor de S.O que me introduziu bem √† esses conceitos, me perdoe se n√£o usei algum termo corretamente professor üôè. Obrigado especial ao Matheus Fidelis, que fez um post super completo sobre concorr√™ncia e paralelismo, mais desvinculado da linguagem Obrigado especial tamb√©m ao William Suane, um dos respons√°veis por uma nova gera√ß√£o de Javeiros competentes no mundo Refer√™ncias https://www.youtube.com/@DevDojoBrasil https://fidelissauro.dev/concorrencia-paralelismo/ https://blog.pantuza.com/artigos/o-jantar-dos-filosofos-problema-de-sincronizacao-em-sistemas-operacionais https://pt.stackoverflow.com/a/116080 https://pt.wikipedia.org/wiki/Regi%C3%A3o_cr%C3%ADtica ","permalink":"https://kaue.cat/posts/concorrencia-java/desafios/","summary":"Seja bem vindo, esse daqui √© o segundo de 6 posts sobre concorr√™ncia em Java. A s√©rie √© focada em Java, mas esse post em especial apresenta conceitos relevantes para literalmente todas as linguagens e tamb√©m n√£o √© uma leitura muito extensiva :).\nNosso roteiro √©:\nThreads! Processando em Paralelo e Ganhando Throughput 2. Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida Concorr√™ncia, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures CompletableFuture Virtual Threads Sincroniza√ß√£o de Threads Um assunto muito abordado em diversos cursos e disciplinas, at√© mesmo arquitetura de computadores e sistemas operacionais √© o sincronismo de threads?","title":"2. Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida"},{"content":"Seja bem vindo, esse daqui √© o primeiro de 6 posts sobre concorr√™ncia em Java. Nosso roteiro √©:\n1. Threads! Processando em Paralelo e Ganhando Throughput 2. Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida 3. Concorr√™ncia, agora melhor - Classes Thread Safe 4. Executors, Thread Pools e Futures 5. CompletableFuture 6. Virtual Threads\nContexto Threads s√£o unidades de execu√ß√£o dentro de um processo. Um processo √© um programa em execu√ß√£o que cont√©m pelo menos uma thread. As threads permitem que um programa execute v√°rias tarefas ao mesmo tempo, alocando uma thread em cada processador dispon√≠vel.\nVantagens de programar com m√∫ltiplas threads: Uma das principais raz√µes para usar m√∫ltiplas threads √© melhorar o desempenho de um programa. Tarefas pesadas e demoradas podem ser divididas em threads separadas, permitindo que diferentes partes do programa sejam executadas em paralelo. Isso pode levar a uma utiliza√ß√£o mais eficiente dos recursos da CPU e, consequentemente, a um tempo de resposta mais r√°pido.\nNo entanto, programar com threads tamb√©m traz desafios, como a necessidade de lidar com concorr√™ncia (quando v√°rias threads tentam acessar ou modificar os mesmos recursos ao mesmo tempo) e a possibilidade de erros dif√≠ceis de depurar (como as condi√ß√µes de corrida), pois os resultados de um mesmo c√≥digo n√£o ser√£o necessariamente os mesmos (n√£o determin√≠sticos).\nO multithreading ajuda ou n√£o? 1. Opera√ß√µes de I/O: Quando um programa precisa realizar opera√ß√µes de entrada/sa√≠da \u0026ndash; I/O (e elas s√£o o gargalo), como leitura/grava√ß√£o de arquivos, comunica√ß√£o com bancos de dados ou solicita√ß√µes de rede, h√° frequentemente momentos em que a CPU fica ociosa, esperando que os dados sejam lidos ou escritos. Nessa situa√ß√£o, se uma nova thread tomasse conta da situa√ß√£o, ela n√£o seria mais executada pelo processador enquanto estivesse ociosa, pois aconteceria o que chamamos de troca de contexto, que √© basicamente fazer com que outra thread seja processada. Isso permite que outras threads que necessitem de processamento real tenham suas opera√ß√µes executadas pelos n√∫cleos da CPU, ou at√© mesmo lan√ßar (ou usar) mais threads para j√° lan√ßar outras chamadas que tamb√©m exigem esse tempo de espera, conhecidas como bloqueantes. Isso ajuda a aproveitar melhor o tempo da CPU, melhorando a efici√™ncia geral do programa. Imagine um contexto onde voc√™ precisa ler dois arquivos .txt, essa opera√ß√£o poderia ser realizada paralelamente se lan√ß√°ssemos duas threads, uma para ler cada arquivo, sendo cada uma processada em um n√∫cleo, diminuindo o tempo de execu√ß√£o essencialmente pela metade\n2. C√≥digo CPU-bound: Quando o programa est√° executando tarefas intensivas em CPU, como c√°lculos matem√°ticos complexos, simula√ß√µes ou processamento de imagem, uma √∫nica thread pode n√£o ser capaz de aproveitar totalmente a capacidade de processamento da CPU. Dividir essas tarefas em threads separadas permite que m√∫ltiplos n√∫cleos da CPU trabalhem em paralelo, acelerando o processamento. Nesse caso, devemos tomar cuidado, pois a quantidade de tarefas que pode ser paralelizada realmente √© igual a quantidade de n√∫cleos do seu processador (l√≥gicos + f√≠sicos).\nA imagem acima representa a troca de contexto, note que esse processo n√£o √© necessariamente instant√¢neo e resulta em poss√≠vel perda de cache, o que pode ser agressor √† performance - Fonte.\nA frequ√™ncia de trocas de contexto tem impacto na efici√™ncia do sistema operacional: quanto menor o n√∫mero de trocas de contexto e menor a dura√ß√£o de cada troca, mais tempo sobrar√° para a execu√ß√£o das tarefas em si. Assim, √© poss√≠vel definir uma medida de efici√™ncia E do uso do processador, em fun√ß√£o das dura√ß√µes m√©dias do quantum de tempo t e da troca de contexto c.\nJava: Threads! O Objeto Thread O objeto java.lang.Thread √© um wrapper em cima das threads do sistema operacional\n[‚ùó] Importante Note que as Threads s√£o objetos wrappers em torno das threads do SO, portanto, se essas threads do S.O s√£o pesadas (e s√£o), as Threads em Java tamb√©m s√£o.\nEm Java, podemos trabalhar com threads de algumas maneiras, a primeira que veremos √© com a classe Thread, essas classes precisam dar o override do m√©todo run:\nclass ThreadExample extends Thread{ char c; public ThreadExample(char c) { this.c = c; } @Override public void run() { System.out.printf(\u0026#34;\\nCome√ßouuu!: %s\\n\u0026#34;, c); for (int i = 0; i \u0026lt; 100 ; i++) { System.out.print(c); } } } public static void main(String[] args) { /* Todo programa em execu√ß√£o √© \u0026#34;feito\u0026#34; de threads, esse n√£o √© uma exce√ß√£o*/ Thread.currentThread().getName(); ThreadExample t1 = new ThreadExample(\u0026#39;A\u0026#39;); ThreadExample t2 = new ThreadExample(\u0026#39;B\u0026#39;); ThreadExample t3 = new ThreadExample(\u0026#39;C\u0026#39;); t1.run(); t2.run(); t3.run(); } Pronto! (S√≥ que n√£o) ‚Üí Note que os objetos thread ainda est√£o rodando na mesma thread, nesse caso, usar Thread.run() executa o m√©todo run, nao inicia a thread, nesse caso, devemos rodar start()!\npublic class Thread01 { public static void main(String[] args) { /* Todo programa em execu√ß√£o √© \u0026#34;feito\u0026#34; de threads, esse n√£o √© uma exce√ß√£o*/ Thread.currentThread().getName(); ThreadExample t1 = new ThreadExample(\u0026#39;A\u0026#39;); ThreadExample t2 = new ThreadExample(\u0026#39;B\u0026#39;); ThreadExample t3 = new ThreadExample(\u0026#39;C\u0026#39;); t1.start(); t2.start(); t3.start(); } } [‚ùì] Reflex√£o Criar um objeto do tipo thread faz sentido? Voc√™ est√° especializando uma thread realmente? A heran√ßa faz sentido nesse caso? [[2. SOLID]]\n1. Interface Runnable Nesse caso, acho v√°lido come√ßar diferente, vamos ler uma parte da javadoc da classe runnable\n0. Javadoc The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. The class must define a method of no arguments called run.\nIn addition, Runnable provides the means for a class to be active while not subclassing Thread. A class that implements Runnable can run without subclassing Thread by instantiating a Thread instance and passing itself in as the target. In most cases, the Runnable interface should be used if you are only planning to override the run() method and no other Thread methods. This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.\nA documenta√ß√£o do JAVA responde perfeitamente a reflex√£o anterior, se voc√™ discorda, pode seguir em frente, mas particularmente acho que √© um argumento dif√≠cil de rebater.\nExemplo:\nclass ThreadRunnable implements Runnable { char c; public ThreadRunnable(char c) { this.c = c; } @Override public void run() { System.out.printf(\u0026#34;\\nCome√ßouuu!: %s\\n\u0026#34;, c); for (int i = 0; i \u0026lt; 100; i++) { System.out.print(c); } } } public class Thread01 { public static void main(String[] args) { /* Todo programa em execu√ß√£o √© \u0026#34;feito\u0026#34; de threads, esse n√£o √© uma exce√ß√£o*/ Thread.currentThread().getName(); var t1Runnable = new ThreadRunnable(\u0026#39;a\u0026#39;); var t2Runnable = new ThreadRunnable(\u0026#39;b\u0026#39;); var t3Runnable = new ThreadRunnable(\u0026#39;c\u0026#39;); Thread t1 = new Thread(t1Runnable); Thread t2 = new Thread(t2Runnable); Thread t3 = new Thread(t3Runnable); t1.start(); t2.start(); t3.start(); } } Estados de uma thread √â interessante sabermos disso, pois podemos dar dicas para o S.O como dizer para que uma thread running pare, ou notificando que uma thread se tornou Runnable.\nMelhorando o C√≥digo Se n√£o precisarmos de construtor! podemos usar uma lambda, pois Runnable √© uma @FunctionalInterface:\nThread t1 = new Thread( () -\u0026gt; {/*codigo*/}); Ou, um pouco mais verboso:\nRunnable simplerRunnable = () -\u0026gt; { System.out.printf(\u0026#34;\\nCome√ßouuu!: %s\\n\u0026#34;, c); for (int i = 0; i \u0026lt; 100; i++) { System.out.print(c); } }; Prioridade Prioridades podem ser atribu√≠das √† threads, conforme mostra o c√≥digo:\nThread t3 = new Thread(t3Runnable,\u0026#34;nomeC\u0026#34;); t3.setPriority(Thread.MAX_PRIORITY); [‚ùó] Importante Note que prioridades s√£o indica√ß√µes do que voc√™ deseja para o scheduler, uma thread de prioridade 1 pode rodar andar da prioridade 10, voc√™ n√£o deve desenvolver um c√≥digo baseado em prioridade\nSleep Imagine que voc√™ deseja que uma thread ocorra sem fim, mas rode a cada 2 minutos, como pode fazer isso? ü§î\nUma das maneiras √© usar um Thread.sleep(milis) e pedir para que a thread pare por algum tempo, note que √© importante esse c√≥digo estar dentro de um try-catch, por sua possibilidade de gerar uma exce√ß√£o (caso a thread seja interrompida, por exemplo)\n@Override public void run() { System.out.printf(\u0026#34;\\nCome√ßouuu!: %s\\n\u0026#34;, c); for (int i = 0; i \u0026lt; 100; i++) { System.out.print(c); } try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } Yield Yield serve para indicarmos / darmos uma dica para o scheduler do JVM fa√ßa a thread voltar para Runnable (pare) por um tempo. [[2. Come√ßando com o C√≥digo]]\nO yield √© um dos principais elementos que permitem a exist√™ncia de Virtual Threads.\nJoin Join serve para avisarmos a thread main que ela deve esperar para continuar seu fluxo q uando as opera√ß√µes terminarem Quando voc√™ chama o m√©todo join em uma determinada (thread), voc√™ est√° essencialmente dizendo: \u0026ldquo;Pera ai, s√≥ continua quando essa tarefa terminar\u0026rdquo;. Isso √© √∫til quando voc√™ tem partes do programa que precisam estar totalmente prontas antes que outras partes possam prosseguir. Um exemplo seria um cen√°rio onde voc√™ precisa comparar 3 pesquisas de viagem de avi√£o para conseguir ver o pre√ßo mais barato, voc√™ pode dar o join nas 3 threads que rodaram essa opera√ß√£o de I/O (a ordem n√£o ir√° importar, pois estaremos limitados pela √∫ltima de qualquer jeito) e ent√£o depois comparamos os resultados\nResumidamnete, o join √© especialmente √∫til quando voc√™ precisa garantir a ordem correta das opera√ß√µes ou quando precisa coletar resultados de v√°rias threads antes de prosseguir.\n// t1 roda antes de t1 e t2 Thread t1 = new Thread(new ThreadRunnableYieldJoin(\u0026#39;A\u0026#39;)); Thread t2 = new Thread(new ThreadRunnableYieldJoin(\u0026#39;B\u0026#39;)); Thread t3 = new Thread(new ThreadRunnableYieldJoin(\u0026#39;C\u0026#39;)); t1.start(); try { t1.join(); } catch (InterruptedException e) { throw new RuntimeException(e); } var threads = List.of(t2,t3); threads.forEach(Thread::start); public static void main(String[] args) { // t1 e t2 em paralelo Thread t1 = new Thread(new ThreadRunnableYieldJoin(\u0026#39;A\u0026#39;)); Thread t2 = new Thread(new ThreadRunnableYieldJoin(\u0026#39;B\u0026#39;)); Thread t3 = new Thread(new ThreadRunnableYieldJoin(\u0026#39;C\u0026#39;)); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { throw new RuntimeException(e); } t3.start(); } } Refer√™ncias [üìö] Qual a finalidade do Transient e Volatile no Java? As vezes quando vou declarar meus atributos noto o transient e o volatile. https://pt.stackoverflow.com/a/116080\n[üìö] Maratona Java Virado no Jiraya Melhor, maior, e o mais completo curso de Java em portugu√™s gr√°tis de toda Internet est√° de volta. https://www.youtube.com/playlist?list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW\u0026gt;)\n","permalink":"https://kaue.cat/posts/concorrencia-java/threads-java/","summary":"Seja bem vindo, esse daqui √© o primeiro de 6 posts sobre concorr√™ncia em Java. Nosso roteiro √©:\n1. Threads! Processando em Paralelo e Ganhando Throughput 2. Sincroniza√ß√£o de Threads - DeadLocks, Zonas Cr√≠ticas e Condi√ß√µes de Corrida 3. Concorr√™ncia, agora melhor - Classes Thread Safe 4. Executors, Thread Pools e Futures 5. CompletableFuture 6. Virtual Threads\nContexto Threads s√£o unidades de execu√ß√£o dentro de um processo. Um processo √© um programa em execu√ß√£o que cont√©m pelo menos uma thread.","title":"1. Concorr√™ncia em Java: Threads! Processando em Paralelo e Ganhando Throughput"},{"content":"[WIP] Replica√ß√£o de Banco de Dados A Replica√ß√£o refere-se ao processo de manter uma c√≥pia dos mesmos dados em v√°rias m√°quinas conectadas atrav√©s de uma rede. Existem v√°rias raz√µes para replicar dados:\nPara manter os dados geograficamente pr√≥ximos aos usu√°rios, reduzindo a lat√™ncia. Para manter a funcionalidade do sistema mesmo que partes falhem (Toler√¢ncia √† falhas), aumentando a disponibilidade. Para escalar o n√∫mero de m√°quinas read-only, aumentando assim o throughput de leitura. Para esse artigo, vamos supor que o conjunto de dados seja pequeno o suficiente para que cada m√°quina possa conter uma c√≥pia completa. Em outro momento podemos discutir o particionamento de banco de dados (sharding).\nSe os dados √† serem replicados forem est√°ticos, a replica√ß√£o √© direta: Copie os dados para cada n√≥ uma vez. No entanto, os dados frequentemente mudam ao longo do tempo.\nVamos explorar tr√™s algoritmos populares para replicar mudan√ßas entre n√≥s: replica√ß√£o com um √∫nico l√≠der, m√∫ltiplos l√≠deres e sem l√≠der.\nL√≠deres e Seguidores Como garantimos que todos os dados sejam replicados com precis√£o? Uma solu√ß√£o comum √© a chamada replica√ß√£o baseada em l√≠der:\nPapel do L√≠der: Uma r√©plica √© designada como l√≠der (tamb√©m conhecida como mestre ou prim√°rio). Para escritas no banco de dados, os clientes devem enviar solicita√ß√µes ao l√≠der, que grava os novos dados no seu armazenamento local.\nPapel do Seguidor: As outras r√©plicas, conhecidas como seguidores (r√©plicas de leitura), recebem mudan√ßas de dados do l√≠der como parte de um log de replica√ß√£o ou fluxo de mudan√ßa. Cada seguidor atualiza seu banco de dados local aplicando todas as escritas na mesma ordem que o l√≠der.\n1. Replica√ß√£o Baseada em √∫nico L√≠der A replica√ß√£o baseada em √∫nico l√≠der √© um recurso integrado nativamente na maioria dos grandes bancos de dados relacionais e alguns bancos de dados n√£o relacionais. Ela tamb√©m √© usada em corretores de mensagens distribu√≠das como Kafka e RabbitMQ.\nReplica√ß√£o S√≠ncrona Versus Ass√≠ncrona Um aspecto importante dos sistemas replicados √© se a replica√ß√£o √© s√≠ncrona ou ass√≠ncrona. Considere um usu√°rio atualizando a imagem do seu perfil em um site. A sequ√™ncia de eventos √©:\nO cliente envia a solicita√ß√£o de atualiza√ß√£o ao l√≠der. O l√≠der recebe a solicita√ß√£o e encaminha a mudan√ßa de dados aos seguidores. O l√≠der notifica o cliente sobre a atualiza√ß√£o bem-sucedida. O momento que o sucesso ser√° dado ao usu√°rio depende da sincroniza√ß√£o dos seguidores.\nSe a replica√ß√£o for s√≠ncrona, os seguidores devem primeiros ficar consistentes para que o usu√°rio receba seu ok. Se for ass√≠ncrona, os dados eventualmente ser√£o consistentes - Isso significa que alguns bancos de dados ainda manter√£o os dados antigos por um tempo, mas eles ser√£o atualizados para alcan√ßar o estado do l√≠der eventualmente A letra ‚ÄúE‚Äù do acr√¥nimo BASE, usado frequentemente para explicar um tipo espec√≠fico de banco de dados que preza por disponibilidade diz respeito √† Eventual Consistency - A Consist√™ncia eventual H√° circunst√¢ncias em que os seguidores podem ficar v√°rios minutos ou mais atr√°s do l√≠der; por exemplo, se um seguidor estiver se recuperando de uma falha, se o sistema estiver operando pr√≥ximo √† capacidade m√°xima, ou se houver problemas de rede entre os n√≥s. Totalmente S√≠ncrono ou Totalmente Ass√≠ncrono Frequentemente, a replica√ß√£o baseada em l√≠der √© completamente ass√≠ncrona - Isso significa que uma escrita n√£o √© garantida como dur√°vel (se o l√≠der falhar e n√£o for recuper√°vel, suas mudan√ßas n√£o ser√£o propagadas mesmo que tenham sido confirmadas ao cliente). No entanto, uma configura√ß√£o totalmente ass√≠ncrona tem a vantagem de que o l√≠der pode continuar processando escritas, mesmo que todos os seus seguidores estejam atrasados.\nIsso √© bom para certos cen√°rios onde queremos alta disponibilidade e velocidade, e perder alguns registros n√£o √© o fim do mundo Em sistemas com muitas leituras, o atraso n√£o √© necessariamente um problema e pode ser considerado usar diversas c√≥pias ass√≠ncronas, receber um tweet com 2 minutos de atraso n√£o √© grande coisa, Enfraquecer a durabilidade dos dados pode parecer uma m√° troca, mas a replica√ß√£o ass√≠ncrona √© amplamente utilizada, especialmente se houver muitos seguidores ou se eles estiverem geograficamente distribu√≠dos. A replica√ß√£o s√≠ncrona garante que os dados sejam replicados para um n√∫mero especificado de seguidores antes de confirmar o sucesso ao cliente. Isso significa que a configura√ß√£o n√£o √© bin√°ria, e voc√™ n√£o precisa seguir a linha de seguidores totalmente s√≠ncronos.\nNa pr√°tica, ter todos os seguidores s√≠ncronos √© impratic√°vel, pois qualquer falha de n√≥ paralisaria o sistema. Tipicamente, um seguidor √© s√≠ncrono, com os outros sendo ass√≠ncronos. Isso garante uma c√≥pia atualizada dos dados em pelo menos dois n√≥s: o l√≠der e um seguidor s√≠ncrono. Se o seguidor s√≠ncrono se tornar indispon√≠vel ou lento, um dos seguidores ass√≠ncronos √© feito s√≠ncrono.\nFalha do L√≠der: Failover Lidar com a falha do l√≠der √© um desafio: um dos seguidores precisa ser promovido a novo l√≠der, os clientes precisam ser reconfigurados para enviar suas escritas ao novo l√≠der, e os outros seguidores precisam come√ßar a consumir mudan√ßas de dados do novo l√≠der. Esse processo √© chamado de failover.\nO failover pode acontecer manualmente (um administrador √© notificado de que o l√≠der falhou e toma as medidas necess√°rias para criar um novo l√≠der) ou automaticamente.\nO processo de failover se d√° dessa forma:\nDeterminar que o L√≠der Falhou. Escolher um Novo L√≠der. Isso pode envolver um processo de elei√ß√£o entre as r√©plicas restantes, ou um novo l√≠der pode ser nomeado por um n√≥ controlador previamente eleito. O melhor candidato √© frequentemente a r√©plica com as mudan√ßas de dados mais atualizadas do antigo l√≠der, para minimizar a perda de dados. Reconfigurar o Sistema para o Novo L√≠der. Os clientes agora precisam enviar suas solicita√ß√µes de escrita ao novo l√≠der. Se o antigo l√≠der voltar, ele deve se tornar um seguidor e reconhecer o novo l√≠der, j√° que pode ainda acreditar que √© o l√≠der. Problemas Se estiver usando replica√ß√£o ass√≠ncrona, o novo l√≠der pode n√£o ter todas as escritas do antigo l√≠der antes da sua falha. Se o antigo l√≠der se reintegrar, h√° uma quest√£o sobre o que acontece com suas escritas n√£o replicadas, especialmente se o novo l√≠der recebeu escritas conflitantes. Comumente, as escritas n√£o replicadas do antigo l√≠der s√£o descartadas, violando potencialmente as expectativas de durabilidade, o que j√° discutimos.\nDescartar escritas √© perigoso se estiver coordenando com sistemas de armazenamento externos fora do banco de dados. Por exemplo, um incidente no GitHub envolveu a promo√ß√£o de um seguidor desatualizado do MySQL a l√≠der. O banco de dados usava um contador autoincrementado para chaves prim√°rias, mas o contador do novo l√≠der estava atrasado, levando √† reutiliza√ß√£o de chaves prim√°rias previamente atribu√≠das pelo antigo l√≠der. Essas chaves tamb√©m eram usadas em um armazenamento Redis, resultando em inconsist√™ncias entre o MySQL e o Redis e causando a divulga√ß√£o de dados privados para usu√°rios incorretos.\nProblemas com Atraso na Replica√ß√£o Ser capaz de tolerar falhas de n√≥s √© apenas uma raz√£o para querer replica√ß√£o. Outras raz√µes incluem escalabilidade (processar mais solicita√ß√µes do que uma √∫nica m√°quina pode lidar) e lat√™ncia (colocar r√©plicas geograficamente mais pr√≥ximas dos usu√°rios).\nA replica√ß√£o baseada em l√≠der exige que todas as escritas passem por um √∫nico n√≥, mas consultas somente de leitura podem ser direcionadas a qualquer r√©plica. Em cargas de trabalho que s√£o principalmente de leitura com √© comum criar muitos seguidores e distribuir as solicita√ß√µes de leitura entre eles. Essa abordagem reduz a carga sobre o l√≠der e permite atender solicita√ß√µes de leitura por r√©plicas pr√≥ximas.\nInfelizmente, ler de um seguidor ass√≠ncrono pode resultar em informa√ß√µes desatualizadas se o seguidor estiver atrasado. Isso leva a inconsist√™ncias aparentes no banco de dados: a mesma consulta executada no l√≠der e em um seguidor simultaneamente pode produzir resultados diferentes porque nem todas as escritas foram refletidas no seguidor.\nEssa inconsist√™ncia tempor√°ria √© conhecida como consist√™ncia eventual. O termo ‚Äúeventualmente‚Äù √© intencionalmente vago. Geralmente, n√£o h√° limite para o quanto uma r√©plica pode ficar para tr√°s.\nQuando o atraso se torna significativo, pode se tornar um problema real, √© vamos ver alguns problemas e solu√ß√µes a seguir\nLer Suas Pr√≥prias Escritas Muitas aplica√ß√µes permitem que os usu√°rios enviem dados (como um registro em um banco de dados de clientes ou um coment√°rio em um f√≥rum de discuss√£o) e depois vejam o que enviaram. Novos dados devem ser enviados ao l√≠der, mas a visualiza√ß√£o dos dados pode ser feita a partir de um seguidor. Isso √© apropriado se os dados s√£o frequentemente visualizados, mas apenas ocasionalmente escritos.\nCom a replica√ß√£o ass√≠ncrona, surge um problema: Se o usu√°rio visualizar os dados logo ap√≥s uma escrita, os novos dados podem ainda n√£o estar na r√©plica. Para o usu√°rio, parece que sua altera√ß√£o n√£o foi feita com sucesso.\nNessa situa√ß√£o, √© v√°lida a consist√™ncia de de ler-suas-pr√≥prias-escritas. Isso garante que, se o usu√°rio recarregar a p√°gina, ele sempre ver√° quaisquer atualiza√ß√µes que tenha enviado. Isso n√£o promete visibilidade imediata das atualiza√ß√µes de outros usu√°rios, mas n√£o d√° a falsa impress√£o que suas altera√ß√µes foram um fracasso.\nAo ler algo que o usu√°rio possa ter modificado, obtenha-o do l√≠der (Ou de um seguidor s√≠ncrono!). Caso contr√°rio, use um seguidor. Isso requer um m√©todo para determinar modifica√ß√µes potenciais sem realmente consultar. Por exemplo, em uma rede social, o perfil de um usu√°rio normalmente √© edit√°vel apenas por ele mesmo. Assim, uma regra simples √©: sempre leia o perfil do pr√≥prio usu√°rio do l√≠der e os perfis de outros usu√°rios de um seguidor.\nLeituras Monot√¥nicas Uma segunda anomalia com seguidores ass√≠ncronos √© a possibilidade de os usu√°rios perceberem o tempo retrocedendo. Isso ocorre se um usu√°rio ler de diferentes r√©plicas em momentos diferentes. Por exemplo, um usu√°rio pode consultar um seguidor com pouco atraso e depois um seguidor com maior atraso, resultando nele vendo dados mais recentes primeiro e depois dados mais antigos.\nPara alcan√ßar leituras monot√¥nicas, garanta que cada usu√°rio sempre leia da mesma r√©plica, embora diferentes usu√°rios possam ler de r√©plicas diferentes.\nLeituras de Prefixo Consistentes O terceiro exemplo de anomalias devido ao atraso na replica√ß√£o envolve viola√ß√µes de causalidade. Se algumas parti√ß√µes replicarem mais lentamente do que outras, √© poss√≠vel observar o resultado (resposta) antes da causa (pergunta).\nPara mais detalhes sobre os √∫ltimos t√≥picos, consulte \u0026ldquo;Designing Data-Intensive Applications\u0026rdquo; (DDIA), p√°gina 164 e 165.\n2. Replica√ß√£o Multi-L√≠der A principal limita√ß√£o da replica√ß√£o baseada em l√≠der √© sua restri√ß√£o de √∫nico l√≠der: todas as escritas devem passar por um l√≠der. Se voc√™ n√£o puder se conectar ao l√≠der, talvez devido a uma interrup√ß√£o de rede, n√£o poder√° escrever no banco de dados.\nUma extens√£o natural √© a replica√ß√£o multi-l√≠der (tamb√©m conhecida como replica√ß√£o ativa/ativa), onde mais de um n√≥ pode aceitar escritas. A replica√ß√£o ocorre como de costume: cada n√≥ que processa uma escrita encaminha a mudan√ßa de dados para todos os outros n√≥s.\nCasos de Uso para Replica√ß√£o Multi-L√≠der Usar uma configura√ß√£o multi-l√≠der dentro de um √∫nico datacenter raramente √© ben√©fico devido √† sua complexidade. No entanto, pode ser vantajoso em certos cen√°rios:\nOpera√ß√£o Multi-datacenter Considere um banco de dados com r√©plicas em v√°rios datacenters, seja para toler√¢ncia a falhas ou proximidade com os usu√°rios. Em uma configura√ß√£o padr√£o baseada em l√≠der, um datacenter abriga o l√≠der, e todas as escritas devem passar por ele.\nEm uma configura√ß√£o multi-l√≠der, cada datacenter pode ter seu pr√≥prio l√≠der, enquanto o l√≠der de cada datacenter replica mudan√ßas para os l√≠deres nos outros datacenters.\nVamos comparar como as configura√ß√µes de l√≠der √∫nico e multi-l√≠der se saem em uma implanta√ß√£o multi-datacenter:\nClientes com Opera√ß√£o Offline Aplica√ß√µes que precisam funcionar enquanto desconectadas da internet, como aplicativos de calend√°rio em telefones celulares e laptops. Esses aplicativos requerem a capacidade de visualizar e inserir dados a qualquer momento, independentemente da conectividade com a internet, com mudan√ßas sincronizadas quando o dispositivo estiver novamente online. Implementa√ß√£o: Cada dispositivo tem um banco de dados local atuando como um l√≠der, com um processo de replica√ß√£o multi-l√≠der ass√≠ncrona entre todas as r√©plicas do dispositivo. O atraso na replica√ß√£o pode variar de horas a dias.\nSemelhante √† replica√ß√£o multi-l√≠der entre datacenters, mas com cada dispositivo como um \u0026ldquo;datacenter\u0026rdquo;.\nDesvantagens da Replica√ß√£o Multi-L√≠der: Modifica√ß√µes concorrentes podem levar a conflitos de escrita que precisam ser resolvidos, isso n√£o necessariamente √© simples e √© o principal lado negativo da replica√ß√£o com m√∫ltiplos l√≠deres. Esse padr√£o √© at√© mesmo considerado negativo na maior parte dos casos.\nChaves autoincrementadas, gatilhos e restri√ß√µes de integridade podem ser problem√°ticos, tornando a replica√ß√£o multi-l√≠der uma escolha arriscada para casos de uso comuns.\nFor example, autoincrementing keys, triggers, and integrity constraints can be problematic. For this reason, multi-leader replication is often considered dangerous territory that should be avoided if possible.\nSe o seu caso de uso pede (ou realmente v√™ benef√≠cios na arquitetura com m√∫ltiplos l√≠deres, recomendo a leitura do livro DDIA no cap√≠tulo correspondente para entender com detalhes os desafios e recomenda√ß√µes de como lidar com os conflitos.\nComparativos Desempenho Configura√ß√£o de L√≠der √önico: Cada escrita deve passar pela internet at√© o datacenter com o l√≠der, potencialmente adicionando lat√™ncia significativa e contrariando o prop√≥sito de m√∫ltiplos datacenters. Configura√ß√£o Multi-L√≠der: As escritas s√£o processadas no datacenter local e replicadas de forma ass√≠ncrona para outros datacenters, ocultando o atraso da rede inter-datacenter e potencialmente melhorando o desempenho percebido.\nToler√¢ncia a Falhas de Datacenter L√≠der √önico: Se o datacenter com o l√≠der falhar, o failover pode promover um seguidor em outro datacenter a l√≠der. Multi-L√≠der: Cada datacenter continua operando independentemente, com a replica√ß√£o se atualizando quando o datacenter com falha voltar a funcionar.\nReplica√ß√£o Sem L√≠der As abordagens de replica√ß√£o discutidas at√© agora ‚Äî l√≠der √∫nico e multi-l√≠der ‚Äî baseiam-se no envio de solicita√ß√µes de escrita para um n√≥ (o l√≠der), com o sistema de banco de dados copiando essa escrita para outras r√©plicas.\nO l√≠der determina a ordem das escritas, e os seguidores as aplicam nessa ordem. A replica√ß√£o sem l√≠der, uma abordagem diferente, abandona o conceito de l√≠der e permite que qualquer r√©plica aceite escritas diretamente dos clientes. Este estilo, repopularizado pelo sistema Dynamo da Amazon, tamb√©m √© encontrado outras solu√ß√µes como o Cassandra.\nEm alguns sistemas sem l√≠der, os clientes enviam escritas diretamente para v√°rias r√©plicas, enquanto em outros, um n√≥ coordenador faz isso em nome do cliente.\nEscrevendo no Banco de Dados Quando um N√≥ Est√° Inativo Considere um banco de dados com tr√™s r√©plicas, sendo uma delas atualmente indispon√≠vel. Em uma configura√ß√£o baseada em l√≠der, a continua√ß√£o do processamento de escritas pode exigir um failover. Em contraste, uma configura√ß√£o sem l√≠der n√£o tem failover. O cliente envia a escrita para todas as tr√™s r√©plicas, e as duas dispon√≠veis a aceitam. Se o reconhecimento de duas em tr√™s r√©plicas for suficiente, a escrita √© considerada bem-sucedida, apesar de uma r√©plica ter perdido.\nQuando o n√≥ indispon√≠vel volta a funcionar, ele n√£o possui as escritas feitas durante seu tempo de inatividade. Leituras desse n√≥ podem retornar valores desatualizados. Para resolver isso, as solicita√ß√µes de leitura s√£o enviadas a v√°rios n√≥s simultaneamente, com n√∫meros de vers√£o usados para determinar o valor mais recente.\nReparo de Leitura e Anti-Entropia Para garantir a consist√™ncia eventual, dois mecanismos s√£o usados:\nReparo de Leitura: Quando um cliente l√™ de v√°rios n√≥s e detecta respostas desatualizadas, ele escreve o valor mais novo de volta para o n√≥ com informa√ß√µes desatualizadas. Isso √© eficaz para valores frequentemente lidos. Processo Anti-Entropia: Alguns reposit√≥rios de dados executam um processo em segundo plano para encontrar diferen√ßas de dados entre r√©plicas e copiar os dados ausentes de acordo. Este processo n√£o segue uma ordem espec√≠fica para copiar escritas e pode ter um atraso significativo antes que os dados sejam replicados. Opera√ß√£o Multi-Datacenter A replica√ß√£o entre datacenters, conforme discutido no contexto da replica√ß√£o multi-l√≠der, tamb√©m √© aplic√°vel na replica√ß√£o sem l√≠der. Este modelo √© projetado para lidar com escritas concorrentes conflitantes, interrup√ß√µes de rede e picos de lat√™ncia.\nImplementa√ß√£o em Cassandra Em Cassandra, o suporte multi-datacenter √© integrado ao modelo sem l√≠der:\nO n√∫mero total de r√©plica, n, inclui n√≥s em todos os datacenters.\nA configura√ß√£o permite especificar o n√∫mero de r√©plicas em cada datacenter. Cada escrita do cliente √© enviada para todas as r√©plicas, independentemente da localiza√ß√£o do datacenter. Os clientes normalmente aguardam o reconhecimento de um qu√≥rum de n√≥s dentro do seu datacenter local, minimizando o impacto dos atrasos de link entre datacenters. As escritas para outros datacenters costumam ser configuradas para serem ass√≠ncronas, com alguma flexibilidade de configura√ß√£o. Detectando Escritas Concorrentes Bancos de dados estilo Dynamo, que permitem escritas concorrentes na mesma chave por v√°rios clientes, enfrentam conflitos semelhantes √† replica√ß√£o multi-l√≠der (\u0026ldquo;Tratamento de Conflitos de Escrita\u0026rdquo; na p√°gina 171). Conflitos podem surgir durante o reparo de leitura ou a transfer√™ncia sugerida.\nAtrasos vari√°veis na rede e falhas parciais podem levar a diferentes n√≥s recebendo eventos em ordens diferentes. Por exemplo:\nO N√≥ 1 recebe uma escrita do Cliente A, mas perde a escrita do Cliente B devido a uma falha. O N√≥ 2 primeiro recebe a escrita do Cliente A, seguida pela do Cliente B. O N√≥ 3 recebe primeiro a escrita do Cliente B e depois a do Cliente A. Se cada n√≥ simplesmente sobrescrever valores ao receber solicita√ß√µes de escrita, inconsist√™ncias permanentes surgem, como ilustrado no cen√°rio final de solicita√ß√£o de obten√ß√£o: O N√≥ 2 v√™ o valor final de X como B, enquanto os outros o veem como A.\nPara alcan√ßar a consist√™ncia eventual e convergir para o mesmo valor, √© necess√°rio um mecanismo de resolu√ß√£o de conflitos adequado. Infelizmente, muitas implementa√ß√µes de banco de dados exigem um profundo entendimento de seus mecanismos internos de tratamento de conflitos por parte do desenvolvedor da aplica√ß√£o para evitar perda de dados.\nPara informa√ß√µes detalhadas sobre a resolu√ß√£o de conflitos de escrita, consulte o livro de refer√™ncia na p√°gina 171.\nBibliografia Designing Data-Intensive Applications (DDIA) - Martin Kleppmann. https://dataintensive.net/\nhttps://fidelissauro.dev/teorema-cap/\n","permalink":"https://kaue.cat/posts/database-replication/","summary":"[WIP] Replica√ß√£o de Banco de Dados A Replica√ß√£o refere-se ao processo de manter uma c√≥pia dos mesmos dados em v√°rias m√°quinas conectadas atrav√©s de uma rede. Existem v√°rias raz√µes para replicar dados:\nPara manter os dados geograficamente pr√≥ximos aos usu√°rios, reduzindo a lat√™ncia. Para manter a funcionalidade do sistema mesmo que partes falhem (Toler√¢ncia √† falhas), aumentando a disponibilidade. Para escalar o n√∫mero de m√°quinas read-only, aumentando assim o throughput de leitura.","title":"[WIP] Replica√ß√£o de Banco de Dados"},{"content":"Aviso - Algumas imagens estar√£o quebradas aqui, enquanto for um trabalho em progresso, recomendo a leitura aqui!\nSpring + Testing Configura√ß√£o do Maven: Certifique-se de que o Maven esteja instalado em seu sistema. No arquivo pom.xml do seu projeto, adicione as depend√™ncias necess√°rias para JUnit e o suporte de testes do Spring Boot. Normalmente, essas depend√™ncias (normalmente spring-boot-starter-test) j√° est√£o inclu√≠das no arquivo de modelo gerado pelo Spring Initializr ao criar um projeto Spring Boot. Estrutura de diret√≥rios: No diret√≥rio do seu projeto, crie a estrutura de diret√≥rios padr√£o para testes: src/test/java e src/test/resources. Os testes de unidade devem ser colocados no diret√≥rio src/test/java seguindo a mesma estrutura de pacotes do c√≥digo-fonte principal. Cria√ß√£o de testes: Crie classes de teste, essas classes de teste s√£o geralmente nomeadas de acordo com a classe que est√£o testando, seguidas por \u0026ldquo;Test\u0026rdquo;. Exemplo: UserService, ‚Üí**UserServiceTest**.\nAnote a classe de teste com @RunWith(SpringRunner.class) para permitir a execu√ß√£o do teste no contexto do Spring Boot.\nAnote a classe de teste com @SpringBootTest para carregar o contexto do Spring Boot durante a execu√ß√£o do teste.\nInjete as depend√™ncias necess√°rias\nCrie m√©todos de teste usando a anota√ß√£o @Test e implemente a l√≥gica de teste dentro desses m√©todos.\nSe esse teste lan√ßar uma exce√ß√£o, defina a propriedade expected na annotation. JUnit - Testes de Unidade Testes de unidade s√£o testes feitos para cobrir um comportamento ou unidade espec√≠fica de execu√ß√£o dentro de um m√©todo. Seu m√©todo de iniciar conversa√ß√£o pode ter v√°rios e-se, nesse caso, um teste de unidade seria criado para validar cada e-se Testes de unidade, de maneira geral s√£o executados com a biblioteca JUnit, que ser√° o foco desse cap√≠tulo. Para sua utiliza√ß√£o, criamos um m√©todo que retorna void e √© anotado por @Test, esse m√©todo deve conter opera√ß√µes e valida√ß√µes (assertions) para garantir o retorno esperado. import org.junit.Test; import static org.junit.Assert.assertEquals; public class CalculadoraTest { @Test @DisplayName(\u0026#34;Testando soma\u0026#34;) public void testSoma() { // Arrange (prepara√ß√£o) Calculadora calculadora = new Calculadora(); // Act (a√ß√£o) int resultado = calculadora.soma(2, 3); // Assert (verifica√ß√£o) assertEquals(5, resultado); } @Test public void testSubtracao() { // Arrange Calculadora calculadora = new Calculadora(); // Act int resultado = calculadora.subtracao(5, 2); // Assert assertEquals(3, resultado); } @Disabled(\u0026#34;Esperando resolverem o bug que 3 √© diferente de 1\u0026#34;) @Test public void testNaoSeiOq(){ assertEquals(3,1); } } Normalmente organizamos nossos testes de unidade em 3 etapas: given-when-then ou o triplo A: Arrange, Act \u0026amp; Assert Assertions // Padr√£o: assertEquals(2, calculadora.soma(1, 1)); assertEquals(4, calculadora.multiplica(2, 2), \u0026#34;The optional failure message is now the last parameter\u0026#34;); assertTrue(\u0026#39;a\u0026#39; \u0026lt; \u0026#39;b\u0026#39;); // Exceptions Exception exception = assertThrows(Aritmetica.class, () -\u0026gt; calculadora.divide(1, 0)); assertEquals(\u0026#34;/ por zero\u0026#34;, exception.getMessage()); // opcional Existem tamb√©m bibliotecas focadas em gerar assertions mais leg√≠veis/fluentes, como AssertJ e Hamcrest, podemos usa-las em conjunto com JUnit:\nimport static org.assertj.core.api.Assertions.*; assertThat(frodo.getName()).isEqualTo(\u0026#34;Frodo\u0026#34;); assertThat(frodo).isNotEqualTo(sauron); assertThat(fellowshipOfTheRing).hasSize(9) .contains(frodo, sam) .doesNotContain(sauron); Testes Parametrizados Testes parametrizados permitem a execu√ß√£o do ‚Äúmesmo teste‚Äù, mas com inputs diferentes, com bem mais facilidade do que criar testes separados:\nimport org.junit.Test; import org.junit.runner.RunWith; import java.util.Arrays; import java.util.Collection; import static org.junit.Assert.assertEquals; public class CalculadoraTest { @ParameterizedTest @CsvSource({\u0026#34;2, 3, 5\u0026#34;, \u0026#34;5, 2, 3\u0026#34;, \u0026#34;0, 0, 0\u0026#34;, \u0026#34;-1, 1, 0\u0026#34;}) public void testSoma(int inputA, int inputB, int expectedResult) { // Arrange Calculadora calculadora = new Calculadora(); // Act int resultado = calculadora.soma(inputA, inputB); // Assert assertEquals(expectedResult, resultado); } } Note que passamos os valores usando @CsvSource, mas n√£o √© a √∫nica maneira\n@ValueSource Uma das maneiras mais simples de realizar testes parametrizados no JUnit 5 √© usando a anota√ß√£o @ValueSource. Esta anota√ß√£o permite especificar um √∫nico vetor de valores literais para fornecer argumentos a um m√©todo de teste parametrizado.\nOs principais tipos s√£o suportados**:** int, long, float, String, Class, etc:\njavaCopy code import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.ValueSource; import static org.junit.jupiter.api.Assertions.assertTrue; public class ExemploTest { @ParameterizedTest @ValueSource(ints = {1, 2, 3}) void testComValueSource(int argumento) { assertTrue(argumento \u0026gt; 0 \u0026amp;\u0026amp; argumento \u0026lt; 4); } } @NullSource, @EmptySource Para testes de fronteira, ou input ruins pode ser √∫til passar valores nulos ou empty para nossos testes parametrizados:\n@NullSource: Fornece um argumento nulo para o m√©todo de teste parametrizado anotado. N√£o pode ser usada para par√¢metros que t√™m um tipo primitivo. @EmptySource: Fornece um argumento vazio para o teste parametrizado. Ela pode ser utilizada para par√¢metros de tipos como java.lang.String, java.util.Collection, java.util.List, java.util.Set, java.util.Map, e arrays primitivos e de objetos. @NullAndEmptySource: Esta √© uma anota√ß√£o composta que combina as funcionalidades de @NullSource e @EmptySource. Se precisarmos fornecer v√°rios tipos de strings em branco para um teste parametrizado, podemos usar @ValueSource da seguinte maneira:\n@ValueSource(strings = {\u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34;\\t\u0026#34;, \u0026#34;\\n\u0026#34;}) Podemos combinar @NullSource, @EmptySource e @ValueSource:\n@ParameterizedTest @NullAndEmptySource @ValueSource(strings = {\u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34;\\t\u0026#34;, \u0026#34;\\n\u0026#34;}) void testNullEmptyAndBlankStrings(String texto) { assertTrue(texto == null || texto.trim().isEmpty()); } @MethodSource A anota√ß√£o @MethodSource permite referenciar m√©todos na pr√≥pria classe de teste ou em classes externas. Esses m√©todos devem ser est√°ticos. Cada m√©todo deve gerar uma sequ√™ncia de argumentos. No final das contas, teremos uma Stream\u0026lt;Arguments\u0026gt;, mas podemos enviar uma ArrayList, Arrays ou qualquer coisa que fa√ßa sentido e deixar o JUnit se virar üôÇ.\nExemplo:\n@ParameterizedTest @MethodSource(\u0026#34;stringProvider\u0026#34;) void testComMethodSource(String argument) { assertNotNull(argument); } static Stream\u0026lt;String\u0026gt; stringProvider() { return Stream.of(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;); } Se um m√©todo parametrizado tiver diversos par√¢mtros, voc√™ precisar√° retornar uma collection, stream ou array de inst√¢ncias de Arguments, ou um arrays de objetos:\n@ParameterizedTest @MethodSource(\u0026#34;stringIntAndListProvider\u0026#34;) void testWithMultiArgMethodSource(String str, int num, List\u0026lt;String\u0026gt; list) { assertEquals(5, str.length()); assertTrue(num \u0026gt;=1 \u0026amp;\u0026amp; num \u0026lt;=2); assertEquals(2, list.size()); } static Stream\u0026lt;Arguments\u0026gt; stringIntAndListProvider() { return Stream.of( arguments(\u0026#34;apple\u0026#34;, 1, Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)), arguments(\u0026#34;lemon\u0026#34;, 2, Arrays.asList(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;)) ); } Podemos usar m√©todos est√°ticos de outras classes como MethodSource dessa forma:\n@MethodSource(\u0026#34;example.StringsProviders#tinyStrings\u0026#34;) @CsvSource A anota√ß√£o @CsvSource permite expressar listas de argumentos como valores separados por v√≠rgulas. Cada string fornecida representa um registro CSV e resulta em uma invoca√ß√£o do teste parametrizado.\nO delimitador padr√£o √© a v√≠rgula, mas pode ser alterado.\nAs aspas simples s√£o usadas como aspas reais, servem para indicar que aquilo dentro √© um texto, mas isso tamb√©m pode ser configurado.\nExample Input Resulting Argument List @CsvSource({ \u0026ldquo;apple, banana\u0026rdquo; }) \u0026ldquo;apple\u0026rdquo;,¬†\u0026ldquo;banana\u0026rdquo; @CsvSource({ \u0026ldquo;apple, \u0026rsquo;lemon, lime\u0026rsquo;\u0026rdquo; }) \u0026ldquo;apple\u0026rdquo;,¬†\u0026ldquo;lemon, lime\u0026rdquo; @CsvSource({ \u0026ldquo;apple, \u0026lsquo;\u0026rsquo;\u0026rdquo; }) \u0026ldquo;apple\u0026rdquo;,¬†\u0026quot;\u0026quot; @CsvSource({ \u0026ldquo;apple, \u0026quot; }) \u0026ldquo;apple\u0026rdquo;,¬†null @CsvSource(value = { \u0026ldquo;apple, banana, NIL\u0026rdquo; }, nullValues = \u0026ldquo;NIL\u0026rdquo;) \u0026ldquo;apple\u0026rdquo;,¬†\u0026ldquo;banana\u0026rdquo;,¬†null @CsvSource(value = { \u0026quot; apple , banana\u0026rdquo; }, ignoreLeadingAndTrailingWhitespace = false) \u0026quot; apple \u0026ldquo;,¬†\u0026quot; banana\u0026rdquo; Exemplo:\n@ParameterizedTest @CsvSource({ \u0026#34;apple, 1\u0026#34;, \u0026#34;banana, 2\u0026#34;, \u0026#34;\u0026#39;lemon, lime\u0026#39;, 0xF1\u0026#34;, \u0026#34;strawberry, 700_000\u0026#34; }) void testComCsvSource(String fruit, int rank) { assertNotNull(fruit); assertNotEquals(0, rank); } Talvez a magia do csv source, al√©m da leitura, seja a possibilidade de implementar diversos testes via um arquivo csv localizado no sistema de arquivos local e/ou classpath\n@CsvFileSource(resources = \u0026quot;/custom-csv.csv\u0026quot;)\nMocking Tanto em testes de integra√ß√£o quanto de unidade, percebemos que devemos travar alguns valores, ou seja, se estamos testando uma regra de neg√≥cio dentro de um service, gostar√≠amos que nosso reposit√≥rio sempre estivesse correto, assumimos isso como verdade para que nosso teste de unidade seja realmente de unidade.\nN√£o indo muito longe, √© f√°cil criar mocks usando a biblioteca mockito:\nimport static org.mockito.Mockito.*; // (4.10+) List mockedList = mock(); // em vers√µes mais antigas: List mockedList = mock(List.class); // Com um objeto mockado, n√£o recebemos exceptions: mockedList.add(\u0026#34;one\u0026#34;); mockedList.clear(); // Com um objeto mockado, sabemos tudo que aconteceu: verify(mockedList).add(\u0026#34;one\u0026#34;); verify(mockedList).clear(); import org.junit.jupiter.api.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import static org.mockito.Mockito.when; public class UserServiceTest { @Mock UserRepository repository; @InjectMocks UserService service; @BeforeEach void setUp() { MockitoAnnotations.initMocks(this); } @Test void test() { when(repository.findById(\u0026#34;123\u0026#34;)).thenReturn(new User()); // mockado :) } } Configurando Comportamento: Utilize when() ou given() para especificar como o mock deve se comportar. Se as respostas padr√£o n√£o atenderem, implemente sua pr√≥pria l√≥gica estendendo a interface Answer e atribua ao mock. spy() e @Spy: Utilize spy() para criar um spy, √© quase que um mock parcial, que chama os m√©todos reais, mas ainda pode ser verificado e manipulado. @InjectMocks: Anote a classe de teste com @InjectMocks para a inje√ß√£o autom√°tica de mocks e spies anotados com @Mock ou @Spy. verify(): Use verify() para verificar se os m√©todos foram chamados com os argumentos esperados. Voc√™ pode ser mais flex√≠vel usando coisas como any(). Testando Reposit√≥rios (De verdade!) Podemos testar reposit√≥rios de alguns jeitos, uma das maneiras √© utilizar um banco em mem√≥ria. Para SQL, h2 √© f√°cil e r√°pido, podemos fazer as configs no banco usando um application-properties para os testes e validar tudo bonitinho normalmente üôÇ. Outra alternativa seria utilizar TestContainers TestContainers \u0026ldquo;Testcontainers √© um framework de c√≥digo aberto para fornecer inst√¢ncias descart√°veis e leves de bancos de dados, message brokers, browsers ou praticamente qualquer coisa que possa ser executada em um container Docker.‚Äù\nAdicionando depend√™ncias: \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mongodb\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;testcontainers\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; A primeira depend√™ncia ir√° variar de acordo com suas necessidades, dependendo do que precisar subir, no meu caso, s√≥ o MongoDB, se precisasse de RabbitMQ, tamb√©m o adicionaria, por exemplo.\nNo c√≥digo, √© simples, depois de termos as depend√™ncias configuradas corretamente, podemos adicionar e instanciar os containers passando a tag da imagem docker como par√¢metro, para o mongodb, mongo:latest.\nAdicionar o Container: private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026quot;mongo:latest\u0026quot;); Adicionar @Container √† vari√°vel do container Se estiver usando Spring 3.1+, adicionar a anota√ß√£o @ServiceConnection tamb√©m. Essa configura√ß√£o pega os dados do container criado e automaticamente sobrescreve com essas informa√ß√µes o container que seria usado originalmente Caso contr√°rio, precisamos fazer isso na m√£o: crie um m√©todo que recebe como par√¢metro DynamicPropertyRegistry Anote esse m√©todo com @DynamicPropertySource Altere as propriedades que estavam configuradas anteriormente usando registry.add(\u0026quot;propriedade\u0026quot;, valor) @Container private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026#34;mongo:latest\u0026#34;); @Container private static final RabbitMQContainer RABBIT_MQ_CONTAINER = new RabbitMQContainer(\u0026#34;rabbitmq:management\u0026#34;); @DynamicPropertySource static void mongoDbProperties(DynamicPropertyRegistry registry) { MONGO_DB_CONTAINER.start(); registry.add(\u0026#34;spring.data.mongodb.uri\u0026#34;, MONGO_DB_CONTAINER::getReplicaSetUrl); registry.add(\u0026#34;spring.rabbitmq.addresses\u0026#34;,() -\u0026gt; \u0026#34;amqp://guest:guest@localhost:\u0026#34;+RABBIT_MQ_CONTAINER.getAmqpPort()); } A partir da√≠, siga sua vida com seu Rabbit, Mongo ou qualquer outra inst√¢ncia descart√°vel.\n@Testcontainers @SpringBootTest public class TicketRepositoryJPATest { @Autowired private TicketRepositoryJPA ticketRepository; @Autowired private TicketFactory ticketFactory; @Container // @ServiceConnection spring 3.1+ - makes DynamicPropertySource unnecessary private static final MongoDBContainer MONGO_DB_CONTAINER = new MongoDBContainer(\u0026#34;mongo:latest\u0026#34;); @DynamicPropertySource static void mongoDbProperties(DynamicPropertyRegistry registry) { MONGO_DB_CONTAINER.start(); registry.add(\u0026#34;spring.data.mongodb.uri\u0026#34;, MONGO_DB_CONTAINER::getReplicaSetUrl); } @Test @Order(0) void InsertTicket_Success(){ Ticket t = ticketFactory.createTicket(\u0026#34;validemail@gmail.com\u0026#34;, \u0026#34;I have a problem\u0026#34;, \u0026#34;hellp\u0026#34;); ticketRepository.insert(t); } @Test @Order(1) void FindAll_findsOne(){ var tickets = ticketRepository.findAll(); assertEquals(tickets.size(), 1); } } No caso acima fa√ßo um teste simples de reposit√≥rio onde garanto que alguns m√©todos est√£o sendo executados corretamente, mas poderia por exemplo, fazer um teste de integra√ß√£o que garante service + reposit√≥rio, ou at√© mesmo um teste de integra√ß√£o completo com TestRestTemplate.\nImportanto classes de declara√ß√£o de Testcontainer Um padr√£o comum ao usar o Testcontainers √© declarar inst√¢ncias de **Container**como campos est√°ticos. Frequentemente, esses campos s√£o definidos diretamente na classe de teste. Eles tamb√©m podem ser declarados em uma classe pai ou em uma interface que o teste implementa:\npublic interface MyContainers { @Container MongoDBContainer mongoContainer = new MongoDBContainer(\u0026#34;mongo:5.0\u0026#34;); @Container Neo4jContainer\u0026lt;?\u0026gt; neo4jContainer = new Neo4jContainer\u0026lt;\u0026gt;(\u0026#34;neo4j:5\u0026#34;); } Para mais discuss√µes, n√£o focando s√≥ no setup, mas em configura√ß√µes diferentes, pr√≥s e contras, recomendo esse post: https://maciejwalkowiak.com/blog/testcontainers-spring-boot-setup/\nOutra ideia interessante √© que podemos configurar TestContainers para aplica√ß√µes rodando em desenvolvimento, vai servir como um docker compose que n√£o precisamos rodar. √â legal, mas n√£o gosto muito da abordagem pois usar docker-compose se tornou parte comum dia a dia de muitos devs e possu√≠ f√°cil leitura e troubleshooting. Se te animar, para explorar esse ponto: https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.testcontainers.at-development-time\nRefer√™ncias: https://spring.io/blog/2023/06/23/improved-testcontainers-support-in-spring-boot-3-1\nhttps://howtodoinjava.com/spring-boot/testcontainers-with-junit-and-spring-boot/\nhttps://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.testcontainers\nTestes de Integra√ß√£o - TestRestTemplate TestRestTemplate TestRestTemplate¬†is a convenience alternative to Spring‚Äôs¬†RestTemplate¬†that is useful in integration tests. You can get a vanilla template or one that sends Basic HTTP authentication (with a username and password). In either case, the template is fault tolerant. This means that it behaves in a test-friendly way by not throwing exceptions on 4xx and 5xx errors. Instead, such errors can be detected through the returned¬†ResponseEntity¬†and its status code.\nSpring Framework 5.0 provides a new¬†WebTestClient¬†that works for¬†https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.spring-boot-applications.spring-webflux-tests¬†and both¬†https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.spring-boot-applications.with-running-server. It provides a fluent API for assertions, unlike¬†TestRestTemplate. It is recommended, but not mandatory, to use the Apache HTTP Client (version 5.1 or better). If you have that on your classpath, the¬†TestRestTemplate¬†responds by configuring the client appropriately. If you do use Apache‚Äôs HTTP client, some additional test-friendly features are enabled:\nRedirects are not followed (so you can assert the response location). Cookies are ignored (so the template is stateless). TestRestTemplate¬†can be instantiated directly in your integration tests, as shown in the following example:\nJavaKotlin\n`class MyTests {\nprivate final TestRestTemplate template = new TestRestTemplate(); @Test void testRequest() { ResponseEntity\u0026lt;String\u0026gt; headers = this.template.getForEntity(\u0026quot;https://myhost.example.com/example\u0026quot;, String.class); assertThat(headers.getHeaders().getLocation()).hasHost(\u0026quot;other.example.com\u0026quot;); } }`\nAlternatively, if you use the¬†@SpringBootTest¬†annotation with¬†WebEnvironment.RANDOM_PORT¬†or¬†WebEnvironment.DEFINED_PORT, you can inject a fully configured¬†TestRestTemplate¬†and start using it. If necessary, additional customizations can be applied through the¬†RestTemplateBuilder¬†bean. Any URLs that do not specify a host and port automatically connect to the embedded server, as shown in the following example:\nimport org.junit.jupiter.api.Test; import java.time.Duration; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.http.HttpHeaders; import static org.assertj.core.api.Assertions.assertThat; @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MySpringBootTests { @Autowired private TestRestTemplate template; @Test void testRequest() { HttpHeaders headers = this.template.getForEntity(\u0026#34;/example\u0026#34;, String.class).getHeaders(); assertThat(headers.getLocation()).hasHost(\u0026#34;other.example.com\u0026#34;); } @TestConfiguration(proxyBeanMethods = false) static class RestTemplateBuilderConfiguration { @Bean RestTemplateBuilder restTemplateBuilder() { return new RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(1)) .setReadTimeout(Duration.ofSeconds(1)); } } } Execu√ß√£o de testes: Use a ferramenta de linha de comando do Maven para executar seus testes. Execute o comando mvn test na raiz do seu projeto. O Maven compilar√° o c√≥digo-fonte e as classes de teste, carregar√° o contexto do Spring Boot e executar√° os testes de unidade. Os resultados dos testes ser√£o exibidos no console, indicando se os testes passaram ou falharam. Application-Test √â normal usarmos vari√°veis de ambientes para a defini√ß√£o de diversos fatores da nossa aplica√ß√£o, contudo, por isso √© uma boa pr√°tica a cria√ß√£o de de uma estrutura de application properties (ou yaml) para testes dentro de src/test/resources\nExemplo:\nspring: autoconfigure: exclude: - org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration - org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration - org.springframework.cloud.openfeign.FeignAutoConfiguration - org.springframework.cloud.openfeign.hateoas.FeignHalAutoConfiguration - org.springframework.cloud.openfeign.loadbalancer.FeignLoadBalancerAutoConfiguration - org.springframework.cloud.openfeign.encoding.FeignAcceptGzipEncodingAutoConfiguration - org.springframework.cloud.openfeign.encoding.FeignContentGzipEncodingAutoConfiguration - org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration logging: level: org: springframework: web: client: RestTemplate: debug Organization: zendesk: country-to-instance: co: base-url: https://example.com/co user: co_zendesk_user api-token: co_zendesk_api_token ec: base-url: https://example.com/ec user: ec_zendesk_user password: ec_zendesk_password caffeine-cache: country-schedule-cache: refresh-after-write: PT1M countries: enabled: - co - ec - sa # invalid country - it will pass the entry point but will get stuck in any other country filtering point conversation: default-virtual-agent-profile: name: Test Agent Com essa classe criada, podemos passar no nosso SpringBootTest o profile que queremos utilizar.\n@Slf4j @SpringBootTest( webEnvironment = WebEnvironment.RANDOM_PORT, properties = \u0026#34;spring.profiles.active=test\u0026#34;) Testes de Integra√ß√£o Caso poss√≠vel, devemos usar o autowired para injetar as depend√™ncias. Se necess√°rio, podemos mockar depend√™ncias com @MockBean\n@MockBean ChatInfoRepository repository; @Autowired ScheduleProperties scheduleProperties; Rest Assured ou cucumber ","permalink":"https://kaue.cat/posts/testes_java/","summary":"Aviso - Algumas imagens estar√£o quebradas aqui, enquanto for um trabalho em progresso, recomendo a leitura aqui!\nSpring + Testing Configura√ß√£o do Maven: Certifique-se de que o Maven esteja instalado em seu sistema. No arquivo pom.xml do seu projeto, adicione as depend√™ncias necess√°rias para JUnit e o suporte de testes do Spring Boot. Normalmente, essas depend√™ncias (normalmente spring-boot-starter-test) j√° est√£o inclu√≠das no arquivo de modelo gerado pelo Spring Initializr ao criar um projeto Spring Boot.","title":"[WIP] Testes em Java - JUnit, Mockito, Integra√ß√£o e TestContainers"},{"content":"Mudan√ßas em Cascata, Menos pontos de contato Encapsulamento √© um princ√≠pio fundamental da programa√ß√£o orientada a objetos (POO) que ajuda a controlar o acesso e a modifica√ß√£o de dados dentro de uma classe. Ele se refere √† pr√°tica de esconder os detalhes de implementa√ß√£o de uma classe de c√≥digos externos e expor apenas uma interface p√∫blica para interagir com a classe. Isso pode ajudar a evitar mudan√ßas em cascata em um sistema de software limitando o n√∫mero de pontos de contato entre diferentes partes do c√≥digo.\nUma maneira de alcan√ßar o encapsulamento (pelo menos em uma linguagem OO) √© usando modificadores de acesso como \u0026ldquo;private\u0026rdquo; ou \u0026ldquo;protected\u0026rdquo; em campos e m√©todos de classe. Isso pode evitar que c√≥digos externos acessem ou modifiquem diretamente o estado interno da classe e for√ßar o uso de m√©todos ou propriedades p√∫blicas que fornecem uma forma controlada de interagir com a classe.\nEssa n√£o √© a √∫nica maneira e nem todos os atributos de uma classe devem ter cegamente getters e setters, faz sentido uma pessoa depois de sua cria√ß√£o ter seu id alterado? Esse setter tem que existir, realmente? Outra ocasi√£o importante que indica falta de encapsulamento √© comentada no ponto 1 do cap√≠tulo de 3. Refatora√ß√£o ‚Üí Casos Usuais.\nclass MyClass { private int data; public int getData() { return data; } public void setData(int newData) { data = newData; } } O encapsulamento tamb√©m pode ser usado para evitar mudan√ßas em cascata mantendo o n√∫mero de pontos de contato entre diferentes partes do c√≥digo o m√≠nimo poss√≠vel. Ou seja, ao inv√©s de termos em 5 lugares diferentes o c√≥digo Float.parseFloat(getData()) poder√≠amos encapsular isso dentro de um m√©todo na classe Data se isso for uma regra de Data ou um comportamento relacionado √† ela (mesmo que n√£o seja, provavelmente √© um comportamento de alguma outra classe). Depois dessa refatora√ß√£o, ao mexermos nesse m√©todo, cuidaremos dos 5 pontos que o utilizam, ao inv√©s de ficar buscando por ai a linha de Float.parseFloat(getData()) e quebrarmos o c√≥digo pois n√£o encontramos uma ocorr√™ncia.\nDevo abstrair um determinado par√¢metro/retorno? J√° dissemos muito sobre abstra√ß√µes e encapsulamento, mas quando voc√™ deve abstrair um certo par√¢metro ou retorno? Aquele atributo String CPF na sua classe √© realmente prejudicial? Se sim, vale a pena criar uma classe para defini-lo?\nSuponha que voc√™ precise criar um objeto Usu√°rio, que tem como par√¢metro do construtor um nome e senha.\nclass Usuario{ ... public Usuario (String nome, String senha){} } Usuario user1 = new Usuario(\u0026#34;kaue\u0026#34;, \u0026#34;123456\u0026#34;); Nesse caso, como voc√™ pode garantir que usu√°rio deve receber sua senha como plain text, e n√£o depois de passar por um hash? Ou que a senha deve ter ao menos 6 caracteres, isso foge da l√≥gica e sem√¢ntica estabelecida pela tipo String, apesar disso, n√£o √© uma valida√ß√£o que d√° muito trabalho, um simples length j√° resolveria o problema do tamanho, nesse caso, n√£o acho que valeria criar uma classe somente para isso, mas quanto ao problema do hash, como validar√≠amos que o cliente usou corretamente o construtor e passou uma senha como plain text?\n√â simples, somente ver a implementa√ß√£o da classe Usu√°rio, mas se isso n√£o est√° claro, temos ai um code smell, uma esp√©cie de acoplamento mental. Se voc√™ n√£o tivesse acesso √† Usu√°rio, n√£o teria como adivinhar. Nesse caso em espec√≠fico, mudar o nome da vari√°vel para plainText seria uma solu√ß√£o caso.\nContudo, se a solu√ß√£o n√£o for t√£o simples, acredito que normalmente passa a valer a pena criar uma classe de dom√≠nio para o par√¢metro (ou retorno). Uma classe Senha com um construtor privado e m√©todos factory seria uma alternativa.\nTrazendo isso para um exemplo real, durante o handling de metadatas as guard√°vamos como Map\u0026lt;String,Object\u0026gt; , repetidos em diversos lugares, apesar disso, us√°vamos o Map em seu exato contexto, sem a necessidade de m√©todos a mais al√©m dos pr√≥prios do Map e o seu contexto e significado era exatamente o que um map representava, nesse caso, n√£o sentimos necessidade de abstrair o tipo.\nProtegendo Fronteiras As fronteiras s√£o a parte do seu software que agem como portas ao mundo externo. No caso de uma API, os seus clientes e pessoas que chamam a API tamb√©m s√£o externos, nenhum dado externo deve ser confiado.\nProteger as fronteiras de um software refere-se a garantir que as interfaces externas e entradas do software sejam validadas e sanitizadas adequadamente para evitar ataques maliciosos ou entradas inesperadas. Isso √© uma parte importante da seguran√ßa de software e pode ajudar a prevenir problemas como SQL Injection, cross-site scripting (XSS) e outros tipos de ataques de inje√ß√£o.\nUma das principais partes de proteger as fronteiras de software √© a valida√ß√£o de entrada (input validation). Isso envolve verificar todos os dados de entrada para garantir que eles atendam a certos crit√©rios antes de serem processados. Por exemplo, uma entrada de formul√°rio pode ser necess√°ria para ter um certo comprimento ou estar em um formato espec√≠fico. Isso pode ajudar a prevenir erros e comportamentos inesperados, al√©m de proteger contra entradas maliciosas.\nOutra parte importante de proteger as fronteiras de software √© a sanitiza√ß√£o. Isso envolve remover ou modificar qualquer elemento potencialmente prejudicial de dados de entrada. Por exemplo, uma aplica√ß√£o web pode sanitizar a entrada de usu√°rios para remover qualquer c√≥digo JavaScript ou HTML que possa ser usado para realizar um ataque cibern√©tico.\nO DDD (Domain Driven Design) tamb√©m desempenha um papel importante na prote√ß√£o das fronteiras de software. O DDD √© uma abordagem de design de software que se concentra no dom√≠nio empresarial e enfatiza a import√¢ncia de criar uma separa√ß√£o clara entre a l√≥gica do dom√≠nio e os detalhes t√©cnicos da implementa√ß√£o. Isso pode ajudar a garantir que as interfaces externas do software sejam bem definidas e f√°ceis de entender, o que pode tornar mais f√°cil validar e sanitizar entradas.\nSerializar classes de dom√≠nio ‚Üí n√£o fazer Ao expor os objetos do dom√≠nio atrav√©s de uma API, serializ√°-los e envi√°-los diretamente para o cliente como uma resposta, pode levar a uma s√©rie de problemas:\nO cliente pode potencialmente modificar o estado do objeto do dom√≠nio e violar as regras do dom√≠nio. O objeto do dom√≠nio pode conter informa√ß√µes sens√≠veis que n√£o devem ser expostas ao cliente. O objeto do dom√≠nio pode conter informa√ß√µes que n√£o s√£o relevantes para o cliente e podem levar √† coleta excessiva de dados. Para evitar esses problemas, √© recomendado criar um DTO (Objeto de Transfer√™ncia de Dados) separado que √© especificamente projetado para a API, ele deve conter apenas as informa√ß√µes que o cliente precisa e n√£o deve conter nenhum comportamento ou m√©todos que possam mudar o estado do objeto do dom√≠nio. Isso ajudar√° a proteger a integridade do modelo de dom√≠nio e manter o cliente desacoplado dos detalhes de implementa√ß√£o interna dos objetos do dom√≠nio.\nPrinc√≠pio: Favorecemos coes√£o atrav√©s do encapsulamento\nO B√°sico O Encapsulamento √© basicamente o ato de juntar comportamentos e estados que fazem sentido no mesmo lugar, garantindo maior coes√£o ao c√≥digo, √© um conceito b√°sico que precisa ser dominado. Veja esse c√≥digo em um reposit√≥rio de um framework da Apache\nfor (Address address : vcard.getAddresses()) { boolean workAddress = false; for (AddressType addressType : address.getTypes()) { if (AddressType.PREF.equals(addressType) || AddressType.WORK.equals(addressType)) { workAddress = true; break; } } if (!workAddress) continue; Sem entender muito do c√≥digo e de seu contexto, j√° somos capaz de refatorar isso de uma maneira melhor, poder√≠amos simplesmente usar:\nif(!adress.hasWorkAdress()) continue; Com isso, o c√≥digo escrito na classe ficaria mais leg√≠vel e a fun√ß√£o de descobrir se h√° endere√ßo de trabalho ou n√£o, passa a ser da classe Adress e pode ser replicado sem problemas atrav√©s de toda a aplica√ß√£o. Se decidirmos mudar a regra de neg√≥cio no estado atual, ter√≠amos que verificar por esse imenso c√≥digo esparramado por todo o programa, o que n√£o acontece no c√≥digo refatorado.\nApenas com essa altera√ß√£o:\nO service fica mais leg√≠vel O service fica mais test√°vel O c√≥digo √© reaproveitado e muda junto com apenas um ponto de contato (dentro da classe Adres) O service tem maior complexidade A complexidade n√£o surge, ela √© distribu√≠da, a regra j√° existe. Como podemos detectar isso? Um forte indicativo que algo est√° estranho √© estarmos usando um estado interno e aplicando l√≥gica em cima desse estado interno fora de sua classe.\nM√©todos privados tamb√©m podem indicar esse tipo de comportamento, talvez at√© mesmo a necessidade do nascimento de novas entidades.\nprivate Person createUserAccount(String username, Collection\u0026lt;GrantedAuthority\u0026gt; authorities,PersonAttributesLookup personAttributesLookup) { Person person = null; if (hasAccountCreationPermission(authorities)) { person = new Person(); person.setEnabled(true); person.setUsername(username); try { // Get the Person Attributes to create the person final PersonAttributesResult attr = personAttributesLookup.lookupPersonAttributes(username); person.setSchoolId(attr.getSchoolId()); person.setFirstName(attr.getFirstName()); person.setLastName(attr.getLastName()); person.setPrimaryEmailAddress(attr.getPrimaryEmailAddress()); ensureRequiredFieldsForDirectoryPerson(person); person = create(person); externalPersonService.updatePersonFromExternalPerson(person, false); LOGGER.info(\u0026#34;Successfully Created Account for {}\u0026#34;, username); } catch (final ObjectNotFoundException onfe) { ... } Refatorando:\nperson.setSchoolId(attr.getSchoolId()); person.setFirstName(attr.getFirstName()); person.setLastName(attr.getLastName()); person.setPrimaryEmailAddress(attr.getPrimaryEmailAddress()); // passa a se tornar public Class Person{ ... Person setAttributesBasedOnAttributesResult(PersonAttributesResult attr){ this.person.setSchoolId(attr.getSchoolId()); this.person.setFirstName(attr.getFirstName()); this.person.setLastName(attr.getLastName()); this.person.setPrimaryEmailAddress(attr.getPrimaryEmailAddress()); } } // seria usado: person.setAttributesBasedOnAttributesResult(attr); Somente nessa altera√ß√£o, j√° travamos setters que podem n√£o ser interessantes para o neg√≥cio (como alterar o schoolId sem alterar o emailAdress, se isso for uma regra existente), ou seja, o c√≥digo antigo estava desprotegido e acoplado mentalmente √† alguma regra externa, precisamos sempre que atualizarmos o primeiro nome atualizar tamb√©m o segundo? n√£o sei. Se sim, podemos fazer com que o encapsulamento garanta isso.\nOutro ponto de refatoramento em Person √© essa parte:\nperson = new Person(); person.setEnabled(true); person.setUsername(username); Talvez os m√©todos de setEnabled e setUsername sejam necess√°rios, ou seja, n√£o faz sentido criarmos um usu√°rio sem Username e desabilitado, por que isso n√£o faz parte do construtor? Esses setters provavelmente nem deveriam existir, com os atributos setados no pr√≥prio construtor. Tratamos isso no cap√≠tulo de refatora√ß√£o\nO c√≥digo final poderia ficar:\nprivate Person createUserAccount(String username, Collection\u0026lt;GrantedAuthority\u0026gt; authorities,PersonAttributesLookup personAttributesLookup) { Person person = null; if (hasAccountCreationPermission(authorities)) { person = new Person(); try { // Get the Person Attributes to create the person final PersonAttributesResult attr = personAttributesLookup.lookupPersonAttributes(username); person.setAttributesBasedOnAttributesResult(attr); ensureRequiredFieldsForDirectoryPerson(person); person = create(person); externalPersonService.updatePersonFromExternalPerson(person, false); LOGGER.info(\u0026#34;Successfully Created Account for {}\u0026#34;, username); } catch (final ObjectNotFoundException onfe) { ... } } Disclaimer! N√£o leve tudo que leu aqui como verdades absolutas ou regras a serem seguida em 100% dos casos, n√£o existe martelo de ouro nem bala de prata. Se houver algum questionamento ou sugest√£o, pode deixar aqui!\nRefer√™ncias: Encapsulamento para ganhar mais coes√£o: O feij√£o com arroz que precisa estar dominado\nOOP E Solid para ninjas - Casa do c√≥digo - Aniche\nDesbravando SOLID - Casa do C√≥digo - Aquiles\n","permalink":"https://kaue.cat/posts/encapsulamento/","summary":"Mudan√ßas em Cascata, Menos pontos de contato Encapsulamento √© um princ√≠pio fundamental da programa√ß√£o orientada a objetos (POO) que ajuda a controlar o acesso e a modifica√ß√£o de dados dentro de uma classe. Ele se refere √† pr√°tica de esconder os detalhes de implementa√ß√£o de uma classe de c√≥digos externos e expor apenas uma interface p√∫blica para interagir com a classe. Isso pode ajudar a evitar mudan√ßas em cascata em um sistema de software limitando o n√∫mero de pontos de contato entre diferentes partes do c√≥digo.","title":"Encapsulamento: O B√°sico que todo jr. precisa saber!"},{"content":"Contexto Quando trabalhando em sistemas reais, temos que nos preocupar com a seguran√ßa de nosso c√≥digo, pontos espec√≠ficos de nosso c√≥digo podem ser mais suscet√≠veis a falhas, mudan√ßas de uma camada de baixo n√≠vel (infraestrutura) podem acarretar em problemas caso haja grandes altera√ß√µes ou at√© mesmo uma mudan√ßa de vendor. Nesse breve artigo irei discutir duas atividades bem frequentes na minha rotina no Bees/AmBev\n1. Features Toggle Em diversos momentos, faz sentido que uma feature seja facilmente desligada ou n√£o usando um toggle, fazendo com que essa altera√ß√£o n√£o precise de um deploy, dando mais agilidade e seguran√ßa √† sua altera√ß√£o. Para isso temos algumas op√ß√µes, podemos usar vari√°veis de ambientes ou at√© mesmo guardar o valor no banco de dados. Uma maneira f√°cil de implementar em Spring √© simplesmente puxar os dados de seu application.properties ou application.yaml\nNo Spring Op√ß√£o 1: @Value Essa op√ß√£o √© particularmente √∫til para configura√ß√µes mais simples, que possuem apenas um campo (ex: Enabled) e n√£o s√£o usadas em diversos lugares. Yaml:\nfeatures: algumaFeature: enabled: true outraFeature: enabled: true Spring:\n@Value(\u0026#34;${features.algumaFeature.enabled}\u0026#34;) private Boolean valueFromFile; Op√ß√£o 2: @ConfigurationProperties Melhor para cen√°rios mais complexos, ou quando a propriedade √© usada em diversos lugares. Yaml:\nbroker: queues: ticket: name: default.ticket exchanges: ticket: name: direct.ticket type: direct bindings: ticket: exchange: direct.ticket queue: default.ticket routingKey: default.ticke Spring:\n@Configuration @ConfigurationProperties(prefix = \u0026#34;broker\u0026#34;) @Data public class BrokerConfigurationProperties { private Map\u0026lt;String, QueueProperties\u0026gt; queues; private Map\u0026lt;String, ExchangeProperties\u0026gt; exchanges; private Map\u0026lt;String, BindingProperties\u0026gt; bindings; @Data public static class QueueProperties { @NotEmpty private String name; } @Data public static class ExchangeProperties { @NotEmpty private String name; private String type; } @Data public static class BindingProperties { @NotEmpty private String exchange; @NotEmpty private String queue; @NotEmpty private String routingKey; } } Aqui basta voc√™ fazer o mapeamento das classes de acordo com suas propriedades. Se houver dificuldade, √© uma tarefa em que alguma AI provavelmente vai lidar com facilidade.\n2. Diferentes Beans de Infraestrutura! Permita um rollback f√°cil Em um c√≥digo ideal, a sua camada de dom√≠nio provavelmente estar√° desacoplada de sua camada de infraestrutura por meio de interfaces. Se isso n√£o faz sentido para voc√™, recomendo meu post de SOLID :) Continuando, com um c√≥digo com m√≥dulos de alto e baixo n√≠vel desacoplados, conseguimos mudar a infraestrutura sem mexer no dom√≠nio. Isso nos d√° a liberdade de gerenciar os beans que sua classe de dom√≠nio ir√° usar com mais facilidade, pois todas as implementa√ß√µes de infraestrutura ir√£o respeitar a interface.\n@AllArgsConstructor public class TicketService { private final TicketRepository repository; private final Notifier messagePublisher; public List\u0026lt;Ticket\u0026gt; findAll(){ return repository.findAll(); } public Ticket findById(String Id){ return repository.findById(Id).orElseThrow( () -\u0026gt; new TicketNotFoundException(\u0026#34;Ticket not found\u0026#34;) ); } public Ticket save(Ticket ticket){ messagePublisher.Notify(TicketEventsEnum.TICKET_CREATED); return repository.save(ticket); } } Temos aqui um Simples Service, tendo suas depend√™ncias injetadas via construtor pelo SPRING. Note que nosso servi√ßo conhece regras de neg√≥cio, dentre elas, quando um ticket √© criado, ele tem que notificar algo, e tem que guardar em algum lugar (repository pode cuidar de mongoDB, MySQL, et cetera.) Note que se tivermos um reposit√≥rio com c√≥digo espec√≠fico do MySQL e quisermos migrar para um c√≥digo com Spring Data JPA, teremos que mudar a camada de infraestrutura (resumidamente, vamos escrever mais c√≥digo de Reposit√≥rio), mas nossa regra de neg√≥cio √© a mesma. Imagine agora que essa camada √© um ponto cr√≠tico da sua aplica√ß√£o, caso a implementa√ß√£o que voc√™ fez com tanta boa vontade d√™ errado, voc√™ ter√° que fazer um rollback.\nDefinindo os Beans Manualmente Ao inv√©s de definir os reposit√≥rios com @Component, como teremos dois reposit√≥rios, o Spring n√£o saber√° com qual Bean lidar. Temos diversas maneiras de fazer a desambigua√ß√£o de Beans, dentre elas, prioridades, primary, qualifier, aqui vou para uma abordagem simples, apenas para exemplificar a feature. No meu yaml, irei definir uma propriedade:\nrepository: type: ${DEFINED_REPOSITORY:mysql} Caso exista uma vari√°vel de ambiente chamada DEFINED_REPOSITORY, ela ser√° o padr√£o para o tipo do meu reposit√≥rio, caso contr√°rio, ser√° mysql, como um fallback. (No caso, escolhi deixar o MySQL como fallback pois teoricamente ele √© o reposit√≥rio testado e j√° em produ√ß√£o). Perfeito, agora vamos definir qual bean utilizar:\n@Configuration public class RepositoryConfiguration{ @Value(\u0026#34;${repository.type}\u0026#34;) private String repositoryType; @Bean public TicketRepository ticketRepository (){ if(\u0026#34;mysql\u0026#34;.equalsIgnoreCase(repositoryType)){ return new MySQLTicketRepository(); } if(\u0026#34;spring\u0026#34;.equalsIgnoreCase(repositoryType)){ return new JpaTicketRepository(); } return new MySQLTicketRepository(); // fallback } } Outra maneira de fazer esse tipo de configura√ß√£o √© usar profiles do Spring.\nObrigado! Obrigado, espero que o breve artigo tenha sido √∫til. Escrevi em 20 minutos e n√£o o revisei, ent√£o se houver algum problema, pode me avisar :)\n","permalink":"https://kaue.cat/posts/refactors_seguros/","summary":"Contexto Quando trabalhando em sistemas reais, temos que nos preocupar com a seguran√ßa de nosso c√≥digo, pontos espec√≠ficos de nosso c√≥digo podem ser mais suscet√≠veis a falhas, mudan√ßas de uma camada de baixo n√≠vel (infraestrutura) podem acarretar em problemas caso haja grandes altera√ß√µes ou at√© mesmo uma mudan√ßa de vendor. Nesse breve artigo irei discutir duas atividades bem frequentes na minha rotina no Bees/AmBev\n1. Features Toggle Em diversos momentos, faz sentido que uma feature seja facilmente desligada ou n√£o usando um toggle, fazendo com que essa altera√ß√£o n√£o precise de um deploy, dando mais agilidade e seguran√ßa √† sua altera√ß√£o.","title":"Features e Refactors Seguros com Java e SPRING: 2 dicas simples!"}]