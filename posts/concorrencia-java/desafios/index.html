<!doctype html><html lang=pt dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida | Kaue Gatto</title><meta name=keywords content="Concorrencia,JAVA"><meta name=description content="Os benefícios associados à programação paralela e concorrente são muitos, mas os perigos também!"><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="G-6MZTJBEG75"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=apple-touch-icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=mask-icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=pt href=https://kaue.cat/posts/concorrencia-java/desafios/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6MZTJBEG75"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6MZTJBEG75",{anonymize_ip:!1})}</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-6MZTJBEG75","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6MZTJBEG75"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6MZTJBEG75",{anonymize_ip:!1})}</script><meta property="og:title" content="2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida"><meta property="og:description" content="Os benefícios associados à programação paralela e concorrente são muitos, mas os perigos também!"><meta property="og:type" content="article"><meta property="og:url" content="https://kaue.cat/posts/concorrencia-java/desafios/"><meta property="og:image" content="https://kaue.cat/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-31T19:16:03+00:00"><meta property="article:modified_time" content="2024-03-31T19:16:03+00:00"><meta property="og:site_name" content="Kaue Gatto - Blog de Desenvolvimento"><meta property="og:see_also" content="https://kaue.cat/posts/concorrencia-java/virtual-threads/"><meta property="og:see_also" content="https://kaue.cat/posts/concorrencia-java/completablefuture/"><meta property="og:see_also" content="https://kaue.cat/posts/concorrencia-java/executors-e-threadpools/"><meta property="og:see_also" content="https://kaue.cat/posts/concorrencia-java/thread-safe/"><meta property="og:see_also" content="https://kaue.cat/posts/concorrencia-java/threads-java/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kaue.cat/%3Cimage%20path/url%3E"><meta name=twitter:title content="2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida"><meta name=twitter:description content="Os benefícios associados à programação paralela e concorrente são muitos, mas os perigos também!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kaue.cat/posts/"},{"@type":"ListItem","position":3,"name":"2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida","item":"https://kaue.cat/posts/concorrencia-java/desafios/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida","name":"2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida","description":"Os benefícios associados à programação paralela e concorrente são muitos, mas os perigos também!","keywords":["Concorrencia","JAVA"],"articleBody":"Seja bem vindo, esse daqui é o segundo de 6 posts sobre concorrência em Java. A série é focada em Java, mas esse post em especial apresenta conceitos relevantes para literalmente todas as linguagens e também não é uma leitura muito extensiva :).\nNosso roteiro é:\nThreads! Processando em Paralelo e Ganhando Throughput Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida Concorrência, agora melhor - Classes Thread Safe Executors, Thread Pools e Futures CompletableFuture Virtual Threads Sincronização de Threads Um assunto muito abordado em diversos cursos e disciplinas, até mesmo arquitetura de computadores e sistemas operacionais é o sincronismo de threads? Mas por quê? Esse tópico vai ser relativamente teórico, mas bem importante, juro.\nExemplo: Um problema clássico de sincronismo (nesse caso sendo retratado por uma implementação Do DevDojo) é exemplo que envolve saque monetário em uma mesma conta, por threads diferentes. Quando threads diferentes acessam um mesmo recurso, acontece o que chamamos de condição de corrida. Esse fenômeno pode ocasionar em erros gravíssimos e difíceis de se perceber, olhe:\nNote que ambos vão sacar dinheiro ao mesmo tempo quando tem 10 reais an conta, caindo na condição da balance ser igual a quantia, apesar disso, como ambos estão correndo e acessando uma mesma zona crítica, acontece uma inconsistência, onde uma thread desconta 10 de 10, e o saldo fica 0, e a outra desconta 10 de 0, deixando o saldo negativo.\nComo podemos resolver isso?!\nOperações Atômicas Uma operação atômica, (na programação concorrente e/ou paralela), é uma operação indivisível que é executada em sua totalidade ou não é executada de forma alguma. Isso significa que, quando uma operação é marcada como atômica, ==ela é tratada como uma unidade indivisível de execução, mesmo em um ambiente com múltiplas threads ou processos concorrentes.== Isso é importante pois ao trabalharmos com programação paralela ou concorrente, tentamos dividir a carga em partes menores, enviadas para as threads\nA atomicidade é fundamental para evitar condições de corrida e garantir a consistência dos dados compartilhados entre threads ou processos. Em uma operação atômica, não há possibilidade de que outra thread ou processo interrompa a operação no meio do caminho, o que reduz significativamente o risco de conflitos e resultados indesejados.\nExemplos:\nIncremento e Decremento: A operação de incremento ou decremento de uma variável é geralmente implementada como uma operação atômica para evitar condições de corrida ao modificar a mesma variável de diferentes threads. Troca (Swap): A operação de troca de valores entre duas variáveis é frequentemente implementada de forma atômica para garantir que a troca ocorra completamente sem interrupções. Teste e Definição (Test-and-Set): Uma operação que verifica o valor de uma variável e a define para um novo valor se a condição for atendida, tudo de forma atômica. Operações de Bloqueio e Desbloqueio (Locking/Unlocking): Operações de bloqueio e desbloqueio são frequentemente usadas para garantir que uma seção crítica do código seja executada por apenas uma thread por vez, evitando conflitos. Essas operações são normalmente implementadas de forma atômica. A zona crítica A “zona crítica” diz respeito à uma seção de código onde uma thread acessa ==recursos compartilhados==, como variáveis, memória ou objetos, que não devem ser modificados por outras threads concorrentes. Essa região protegida, normalmente, é acessada por uma thread / programa de cada vez. O objetivo é tornar a operação sobre o recurso compartilhado atômica. Uma região crítica geralmente termina num tempo específico, e uma linha de execução ou processo só precisa esperar um tempo específico para entrá-la. Alguns mecanismos de sincronização são necessários para implementar a entrada e a saída de uma região crítica para assegurar o uso exclusivo, como por exemplo um semáforo, é o que veremos mais a frente.\nCondição de Corrida i. Acontece quando duas ou mais threads tentam modificar um recurso compartilhado ao mesmo tempo, resultando em resultados não determinísticos e possivelmente errôneos.\nDeadlocks i. Muitas vezes os próprios synchronizers (algorítmos que alternam o acesso à recursos por threads) causam o deadlock. Inconsistências\nUm dos fatores para isso acontecer é o dado cache! Podemos usar recursos do java como “Volatile” que diz que sempre que formos acessar aquele recurso, ele tem que ser verificado de novo!\nCaso StackOverflow - Muiito Didático (Explica volatile)\nhttps://pt.stackoverflow.com/a/116080\nlong i = 0; void thread1() { ... i++; ... } void thread2() { ... if (i == 1) { fazAlgo(); } ... } No exemplo, as duas threads acessam a mesma variável. Assumindo que a leitura da thread2 ocorre, numa sequência de tempo, exatamente após o incremento da thread1, você acha que pode ocorrer algum problema de concorrência, considerando que o incremento parece uma operação atômica?\nUma análise ingênua diria que está tudo bem com as threads pois as duas executam operações atômicas de escrita e leitura, logo fazAlgo seria executado sem problemas.\nErrado.\nCada thread pode estar sendo executada em um processador diferente. Cada processador pode ter um cache próprio. Variáveis são lidas e gravadas primeiro no cache local antes de irem para a memória principal. Então, é possível que a segunda thread leia o valor antigo da variável.\nO cenário problemático ocorreria assim:\nT1 lê o valor de i = 0 da memória principal e faz o incremento; o novo valor i = 1 é armazenado no cache local, mas não na memória principal. T2 lê o valor de i = 0 da memória principal e não entra no if. Pior que isto, variáveis de 64 bits como long e double podem ter sua escrita em memória dividida pela JVM em dois ciclos de 32 bits, o que poderia levar uma leitura completamente corrompida de seus valores. Tais cenários são relativamente raros, mas extremamente difíceis de identificar em softwares complexos, causando aquele tipo de problema intermitente e ocasional que acaba sendo varrido para debaixo do tapete.\nA solução, neste caso, é simples:\nvolatile long i = 0; Um atributo volátil tem garantia de que o valor atualizado estará sempre disponível para outras threads, sendo gravado na memória principal assim que atualizado, de forma atômica.\nIsso significa que, sempre que o valor for modificado em um processador, ocorrerá um flush para a memória principal, portanto as outras threads vão ver sempre o valor mais atualizado e não um possível valor defasado.\nClaro que isso não é gratuito. Fazer o flush do cache para a memória principal penaliza o desempenho, afinal existe uma razão para os fabricantes de hardware colocarem caches nos processadores. É muito mais rápido acessar um registrador ou cache primário do que acessar a memória RAM.\nUma solução alternativa seria usar métodos de sincronização como um bloco synchronized ou variáveis atômicas como AtomicLong, os quais podem ser necessários quando há modificação concorrente, mas que são mais lentos.\nNo caso de escrita concorrente, como bem lembrado pelo Rafael na outra resposta, uma variável volatile ainda poderia incorrer em condição de corrida pois as duas threads podem ler o mesmo valor da memória principal, e o valor final dependeria de qual das threads escreveria ele por último.\nMecanismos que regulam acesso à zonas críticas Existem diversos mecanismos que regulam acessos às zonas críticas do software, evitando condições de corridas - race conditions:\nLocks Locks são o mecanismo padrão, que basicamente dizem se alguém tem pode entrar ou não na zona crítica, é como aquele banheiro químico, ou você pode entrar, ou tem alguém lá dentro e você tem que esperar pra entrar.\nSemáforos Apesar de ter sido inventado em 1965, por E. Dijkstra, os semáforos são a técnica mais usada atualmente Um semáforo é uma variável (s), associada a uma região crítica, sobre a qual podem incidir duas operações: Operação Down: verifica se o valor de s é maior que zero. Se for, o valor é decrementado. Senão, a tarefa é bloqueada e o valor de s permanece zero. Operação Up: incrementa o valor de s, e desbloqueia as demais tarefas se o valor for zero. Ou seja, um semáfaro com valor s inicial de 3, permite que 3 tarefas entrem na zona crítica (3 Downs, descendo o valor para 2,1 e 0)\nTambém existem Semáforos Conhecidos como binários ou mutex, que é basicamente um semáforo de valor s=1, ou seja, acomoda apenas um único thread, é um lock convencional :p.\nMecanismos em Java: Syncronized O mais comum é usarmos a keyword syncronized antes da declaração de algum método ou variável, indicando que ela tem um lock, ou seja, apenas uma thread pode acessá-la por vez, como uma passagem de bastão Então, no exemplo anterior, adicionar synchronized resolve nosso problema:\nprivate synchronized void withdrawal(int amount) { if (account.getBalance() \u003e= amount) { System.out.println(getThreadName() + \" está indo sacar dinheiro\"); account.withdrawal(amount); System.out.println(getThreadName() + \" completou o saque, valor atual da conta \" + account.getBalance()); } else { System.out.println(\"Sem dinheiro para \" + getThreadName() + \" efetuar o saque \" + account.getBalance()); } } [❗] Importante Sleeps e outras operações demoradas não liberam o lock / passa o bastão para outra thread, na realidade, essas threads esperando sua vez ficam bloqueadas na “fila”\nPodemos também usar o synchronized assim: dividindo uma parte da operação como atômica, mas deixando a outra aberta para múltiplas threads. Nesse caso marcamos qual objeto sofrerá o lock e a operação\nprivate void withdrawal(int amount) { System.out.println(getThreadName() +\" #### fora do synchronized\"); synchronized (account) { System.out.println(getThreadName() +\" **** dentro do synchronized\"); if (account.getBalance() \u003e= amount) { System.out.println(getThreadName() + \" está indo sacar dinheiro\"); account.withdrawal(amount); System.out.println(getThreadName() + \" completou o saque, valor atual da conta \" + account.getBalance()); } else { System.out.println(\"Sem dinheiro para \" + getThreadName() + \" efetuar o saque \" + account.getBalance()); } } } Nesse caso, estamos sincronizando apenas o objeto account, um ponto de atenção aqui é não trocar a referência desse objeto: como fazer account = new Account() por isso, uma boa prática é marcar objetos sincronizados como final.\n[🤓☝️] Mutex / Locks Distribuídos Alguns sistemas podem optar por usar locks distribuídos entre diferentes processos, isso pode ser feito direto no banco de dados (se for uma aplicação como uma API com múltiplas instâncias rodando) ou usando soluções como o Apache Zookeper, que possuí recursos avançados para tomar conta dos seus processos, evitando starvation \u0026 race conditions\nThread-Safe Classes “thread-safe” são classes ou componentes de software projetados para funcionar de maneira segura em ambientes multithread, onde várias threads podem acessá-los e manipulá-los simultaneamente. Em outras palavras, uma classe thread-safe é projetada para evitar condições de corrida, deadlocks e outras situações problemáticas que podem ocorrer quando várias threads acessam recursos compartilhados.\n[❗] Threads safe que… não são thread safe Usar uma classe como Collections.synchronizedList não garante que a classe é thread-safe se uma camada a mais de código não thread-safe for colocada em cima dela (Exemplo, uma classe que faz o add e remove, mas não se importa com a sincronização desses métodos).\nUma classe realmente Thread safe:\nclass ThreadSafeNames { private final List\u003cString\u003e names = new ArrayList\u003c\u003e(); public synchronized void add (String name){ names.add(name); } public synchronized void removeFirst(){ if(names.size() \u003e 0){ System.out.println(Thread.currentThread().getName()); System.out.println(names.remove(0)); } } } public class ThreadSafeTest01 { public static void main(String[] args) { ThreadSafeNames threadSafeNames = new ThreadSafeNames(); threadSafeNames.add(\"Junkrat\"); Runnable r = threadSafeNames::removeFirst; new Thread(r).start(); new Thread(r).start(); } } [🤓☝️] Classes Úteis Diversas classes do package java.util.concurrent são úteis para concorrência, exemplos:\nConcurrentHashMap CopyOnWriteArrayList (Uma lista thread-safe em que as operações de leitura não requerem sincronização, tornando-as eficientes para leitura intensiva.) AtomicInteger (Uma classe que fornece operações atômicas para incrementar e atualizar inteiros.) Semaphore - Semáforos! Exchanger: Uma classe que permite que duas threads troquem objetos em um ponto de encontro, facilitando a comunicação entre threads. Exemplo: Envio de Email Podemos ter um serviço para envio de email, onde temos uma thread colocando emails em uma fila, e sempre notificando as worker-threads quando um email novo chegar, assim agilizando o envio por múltiplas threads.\npublic class Members { private final Queue\u003cString\u003e emails = new ArrayBlockingQueue\u003c\u003e(10); private boolean open = true; public boolean isOpen() { return open; } public int pendingEmails() { synchronized (emails) { return emails.size(); } } public void addMemberEmail(String email) { synchronized (this.emails) { String threadName = Thread.currentThread().getName(); System.out.println(threadName + \" Adicionou email na lista\"); this.emails.add(email); this.emails.notifyAll(); } } public String retrieveEmail() throws InterruptedException { System.out.println(Thread.currentThread().getName() + \" checking if there are emails\"); synchronized (this.emails) { while (this.emails.size() == 0) { if (!open) return null; System.out.println(Thread.currentThread().getName() + \" Não tem email disponível na lista, entrando em modo de espera\"); this.emails.wait(); } return this.emails.poll(); } } public void close() { open = false; synchronized (this.emails) { System.out.println(Thread.currentThread().getName() + \" Notificando todo mundo que não estamos mais pegando emails\"); } } } [❗] Atenção! addMemberEmail e retrieveEmail podem ser usados ao mesmo tempo: sim, eles podem ser usados ao mesmo tempo. Embora ambos usem o mesmo objeto (this.emails) como bloqueio, eles estão bloqueando diferentes partes críticas do código. Enquanto addMemberEmail está bloqueando para adicionar um email, retrieveEmail está bloqueando para verificar e remover um email. Isso permite que esses métodos sejam chamados simultaneamente sem interferir um no outro.\npublic class EmailDeliveryService implements Runnable{ private final Members members; public EmailDeliveryService(Members members) { this.members = members; } @Override public void run() { String threadName = Thread.currentThread().getName(); System.out.println(threadName +\" starting to deliver emails...\"); while(members.isOpen() || members.pendingEmails() \u003e 0){ try { String email = members.retrieveEmail(); if(email == null) continue; System.out.println(threadName + \" enviando email para \" + email); Thread.sleep(2000); System.out.println(threadName + \" enviou email com sucesso para \"+ email); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"Todos os emails foram enviados com sucesso!\"); } } public class EmailDeliveryTest01 { public static void main(String[] args) { Members members = new Members(); Thread jiraya = new Thread(new EmailDeliveryService(members), \"Jiraya\"); Thread kakashi = new Thread(new EmailDeliveryService(members), \"Kakashi\"); jiraya.start(); kakashi.start(); while(true){ String email = JOptionPane.showInputDialog(\"Entre com seu email\"); if(email == null || email.isEmpty()){ members.close(); break; } members.addMemberEmail(email); } } } Exemplo Clássico : Jantar Dos Filósofos (Deadlock) https://blog.pantuza.com/artigos/o-jantar-dos-filosofos-problema-de-sincronizacao-em-sistemas-operacionais\nO jantar dos filósofos foi pensado por Dijkstra (esse cara realmente foi foda né)\nCinco filósofos estão sentados em uma mesa redonda para jantar. Cada filósofo tem um prato com espaguete à sua frente. Cada prato possui um garfo para pegar o espaguete. O espaguete está muito escorregadio e, para que um filósofo consiga comer, será necessário utilizar dois garfos.\nLembre-se que é apenas uma analogia. Nesse sentido, cada filósofo alterna entre duas tarefas: comer ou pensar. Quando um filósofo fica com fome, ele tenta pegar os garfos à sua esquerda e à sua direita; um de cada vez, independente da ordem. Caso ele consiga pegar dois garfos, ele come durante um determinado tempo e depois recoloca os garfos na mesa. Em seguida ele volta a pensar.\nVocê é capaz de propor um algoritmo que implemente cada filósofo de modo que ele execute as tarefas de comer e pensar sem nunca ficar travado?\nNão vou colocar a solução aqui, mas se te deixou curioso, acesse o link acima, é uma ótima explicação. A solução normalmente aceita é usar os semáforos que falamos anteriormente\nAgradecimentos Especiais Obrigado André Leon, professor de S.O que me introduziu bem à esses conceitos, me perdoe se não usei algum termo corretamente professor 🙏. Obrigado especial ao Matheus Fidelis, que fez um post super completo sobre concorrência e paralelismo, mais desvinculado da linguagem Obrigado especial também ao William Suane, um dos responsáveis por uma nova geração de Javeiros competentes no mundo Referências https://www.youtube.com/@DevDojoBrasil https://fidelissauro.dev/concorrencia-paralelismo/ https://blog.pantuza.com/artigos/o-jantar-dos-filosofos-problema-de-sincronizacao-em-sistemas-operacionais https://pt.stackoverflow.com/a/116080 https://pt.wikipedia.org/wiki/Regi%C3%A3o_cr%C3%ADtica ","wordCount":"2542","inLanguage":"pt","image":"https://kaue.cat/%3Cimage%20path/url%3E","datePublished":"2024-03-31T19:16:03Z","dateModified":"2024-03-31T19:16:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kaue.cat/posts/concorrencia-java/desafios/"},"publisher":{"@type":"Organization","name":"Kaue Gatto","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kaue.cat accesskey=h title="Home (Alt + H)"><img src=https://kaue.cat/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://kaue.cat/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://kaue.cat/archives title=Arquivo><span>Arquivo</span></a></li><li><a href=https://kaue.cat/search/ title=Buscar><span>Buscar</span></a></li><li><a href=https://kaue.cat/series/ title=Séries><span>Séries</span></a></li><li><a href=https://kaue.cat/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kaue.cat>Início</a>&nbsp;»&nbsp;<a href=https://kaue.cat/posts/>Posts</a></div><h1 class=post-title>2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida</h1><div class=post-description>Os benefícios associados à programação paralela e concorrente são muitos, mas os perigos também!</div><div class=post-meta><span title='2024-03-31 19:16:03 +0000 UTC'>31 de março , 2024</span>&nbsp;·&nbsp;12 minutos&nbsp;·&nbsp;2542 palavras&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/kauegatto/kauedotcat/content/posts/concorrencia-java/desafios.md rel="noopener noreferrer" target=_blank>Sugerir Alterações</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Conteúdo</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#operações-atômicas>Operações Atômicas</a></li><li><a href=#a-zona-crítica>A zona crítica</a></li></ul><ul><li><a href=#locks>Locks</a></li><li><a href=#semáforos>Semáforos</a></li></ul><ul><li><ul><li><a href=#syncronized>Syncronized</a></li></ul></li></ul><ul><li><a href=#exemplo-envio-de-email>Exemplo: Envio de Email</a></li></ul></nav></div></details></div><div class=post-content><p>Seja bem vindo, esse daqui é o segundo de 6 posts sobre concorrência em Java. A série é focada em Java, mas esse post em especial apresenta conceitos relevantes para literalmente todas as linguagens e também não é uma leitura muito extensiva :).</p><p>Nosso roteiro é:</p><ol><li>Threads! Processando em Paralelo e Ganhando Throughput</li><li><strong>Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida</strong></li><li>Concorrência, agora melhor - Classes Thread Safe</li><li>Executors, Thread Pools e Futures</li><li>CompletableFuture</li><li>Virtual Threads</li></ol><h1 id=sincronização-de-threads>Sincronização de Threads<a hidden class=anchor aria-hidden=true href=#sincronização-de-threads>#</a></h1><p>Um assunto muito abordado em diversos cursos e disciplinas, até mesmo arquitetura de computadores e sistemas operacionais é o sincronismo de threads? Mas por quê?
Esse tópico vai ser relativamente teórico, mas bem importante, juro.</p><h1 id=exemplo>Exemplo:<a hidden class=anchor aria-hidden=true href=#exemplo>#</a></h1><p>Um problema clássico de sincronismo (nesse caso sendo retratado por uma implementação Do <a href=https://www.youtube.com/@DevDojoBrasil>DevDojo</a>) é exemplo que envolve saque monetário em uma mesma conta, por threads diferentes.
Quando threads diferentes acessam um mesmo recurso, acontece o que chamamos de <em>condição de corrida</em>. Esse fenômeno pode ocasionar em erros gravíssimos e difíceis de se perceber, olhe:</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6fdl3s5facb7yzz8nxdh.png alt="Image description"></p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u6pqyujbeodxke9jr4le.png alt="Image description"></p><p>Note que ambos vão sacar dinheiro ao mesmo tempo quando tem 10 reais an conta, caindo na condição da balance ser igual a quantia, apesar disso, como ambos estão correndo e acessando uma mesma <em>zona crítica</em>, acontece uma inconsistência, onde uma thread desconta 10 de 10, e o saldo fica 0, e a outra desconta 10 de 0, deixando o saldo negativo.</p><p>Como podemos resolver isso?!</p><h2 id=operações-atômicas>Operações Atômicas<a hidden class=anchor aria-hidden=true href=#operações-atômicas>#</a></h2><p>Uma operação atômica, (na programação concorrente e/ou paralela), é uma operação indivisível que é executada em sua totalidade ou não é executada de forma alguma. Isso significa que, quando uma operação é marcada como atômica, <strong>==ela é tratada como uma unidade indivisível de execução, mesmo em um ambiente com múltiplas threads ou processos concorrentes.==</strong> Isso é importante pois ao trabalharmos com programação paralela ou concorrente, tentamos dividir a carga em partes menores, enviadas para as threads</p><p>A atomicidade é fundamental para evitar condições de corrida e garantir a consistência dos dados compartilhados entre threads ou processos. Em uma operação atômica, não há possibilidade de que outra thread ou processo interrompa a operação no meio do caminho, o que reduz significativamente o risco de conflitos e resultados indesejados.</p><p>Exemplos:</p><ol><li><strong>Incremento e Decremento</strong>: A operação de incremento ou decremento de uma variável é geralmente implementada como uma operação atômica para evitar condições de corrida ao modificar a mesma variável de diferentes threads.</li><li><strong>Troca (Swap)</strong>: A operação de troca de valores entre duas variáveis é frequentemente implementada de forma atômica para garantir que a troca ocorra completamente sem interrupções.</li><li><strong>Teste e Definição (Test-and-Set)</strong>: Uma operação que verifica o valor de uma variável e a define para um novo valor se a condição for atendida, tudo de forma atômica.</li><li><strong>Operações de Bloqueio e Desbloqueio (Locking/Unlocking)</strong>: Operações de bloqueio e desbloqueio são frequentemente usadas para garantir que uma seção crítica do código seja executada por apenas uma thread por vez, evitando conflitos. Essas operações são normalmente implementadas de forma atômica.</li></ol><h2 id=a-zona-crítica>A zona crítica<a hidden class=anchor aria-hidden=true href=#a-zona-crítica>#</a></h2><p>A &ldquo;<em>zona crítica</em>&rdquo; diz respeito à uma seção de código onde uma thread acessa ==recursos compartilhados==, como variáveis, memória ou objetos, que <strong>não</strong> devem ser modificados por outras threads concorrentes. Essa região protegida, normalmente, é acessada por uma thread / programa de cada vez.
O objetivo é tornar a operação sobre o recurso compartilhado <a href=https://pt.wikipedia.org/wiki/Transa%C3%A7%C3%A3o_at%C3%B4mica title="Transação atômica">atômica</a>. Uma região crítica geralmente termina num tempo específico, e uma linha de execução ou <a href=https://pt.wikipedia.org/wiki/Processo_(inform%C3%A1tica) title="Processo (informática)">processo</a> só precisa esperar um tempo específico para entrá-la. Alguns mecanismos de <a href=https://pt.wikipedia.org/wiki/Sincroniza%C3%A7%C3%A3o title=Sincronização>sincronização</a> são necessários para implementar a entrada e a saída de uma região crítica para assegurar o uso exclusivo, como por exemplo um <a href=https://pt.wikipedia.org/wiki/Sem%C3%A1foro_(computa%C3%A7%C3%A3o) title="Semáforo (computação)">semáforo</a>, é o que veremos mais a frente.</p><ol><li><p>Condição de Corrida
i. Acontece quando duas ou mais threads tentam modificar um recurso compartilhado ao mesmo tempo, resultando em resultados não determinísticos e possivelmente errôneos.</p></li><li><p>Deadlocks
i. Muitas vezes os próprios synchronizers (algorítmos que alternam o acesso à recursos por threads) causam o deadlock.
<img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mjjhbdumdmprb9d4h6i1.png alt="Imagem mostrando um deadlock, os recursos t1 está do lado esquerdo de um circulo, e o t2 no lado direito, o recurso t1 tenta acessar o recurso r1 e obtém o lock, o t2 faz o mesmo com r2, mas r1 espera infinitamente por r2 e t2 por r1"></p></li><li><p>Inconsistências</p></li></ol><p>Um dos fatores para isso acontecer é o dado cache! Podemos usar recursos do java como &ldquo;Volatile&rdquo; que diz que sempre que formos acessar aquele recurso, ele tem que ser verificado de novo!</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8cdcx5pejtjzl1t14a8c.png alt="Image description"></p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/msv5ltlzzodf41ixmuku.png alt="Image description"></p><ul><li><p>Caso StackOverflow - <strong>Muiito Didático (Explica volatile)</strong></p></li><li><p><a href=https://pt.stackoverflow.com/a/116080>https://pt.stackoverflow.com/a/116080</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread1</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=n>i</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread2</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fazAlgo</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div></li></ul><p>No exemplo, as duas threads acessam a mesma variável. Assumindo que a leitura da <code>thread2</code> ocorre, numa sequência de tempo, exatamente após o incremento da <code>thread1</code>, você acha que pode ocorrer algum problema de concorrência, considerando que o incremento <strong>parece uma operação atômica</strong>?</p><p>Uma análise ingênua diria que está tudo bem com as <em>threads</em> pois as duas executam operações atômicas de escrita e leitura, logo <code>fazAlgo</code> seria executado sem problemas.</p><p><strong>Errado.</strong></p><p>Cada <em>thread</em> <strong>pode</strong> estar sendo executada em um processador diferente. Cada processador <strong>pode</strong> ter um <em>cache</em> próprio. Variáveis são lidas e gravadas primeiro no cache local antes de irem para a memória principal. Então, <strong>é possível</strong> que a segunda <em>thread</em> leia o valor antigo da variável.</p><p>O cenário problemático ocorreria assim:</p><ol><li>T1 lê o valor de <code>i = 0</code> da memória principal e faz o incremento; o novo valor <code>i = 1</code> é armazenado no cache local, mas não na memória principal.</li><li>T2 lê o valor de <code>i = 0</code> da memória principal e não entra no <code>if</code>.
Pior que isto, variáveis de 64 bits como <code>long</code> e <code>double</code> podem ter sua escrita em memória dividida pela JVM em dois ciclos de 32 bits, o que poderia levar uma leitura completamente corrompida de seus valores.</li></ol><p><strong>Tais cenários são relativamente raros, mas extremamente difíceis de identificar em softwares complexos, causando aquele tipo de problema intermitente e ocasional que acaba sendo varrido para debaixo do tapete.</strong></p><p>A solução, neste caso, é simples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>volatile</span> <span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span></code></pre></div><p>Um atributo volátil tem garantia de que o valor atualizado estará sempre disponível para outras <em>threads</em>, sendo gravado na memória principal assim que atualizado, de forma atômica.</p><p>Isso significa que, sempre que o valor for modificado em um processador, ocorrerá um <em>flush</em> para a memória principal, portanto as outras <em>threads</em> vão ver sempre o valor mais atualizado e não um possível valor defasado.</p><p>Claro que isso não é gratuito. Fazer o <code>flush</code> do cache para a memória principal penaliza o desempenho, afinal existe uma razão para os fabricantes de hardware colocarem caches nos processadores. É muito mais rápido acessar um registrador ou cache primário do que acessar a memória RAM.</p><p>Uma solução alternativa seria usar métodos de sincronização como um bloco <code>synchronized</code> ou variáveis atômicas como <code>AtomicLong</code>, os quais podem ser necessários quando há modificação concorrente, mas que são mais lentos.</p><p>No caso de escrita concorrente, como bem lembrado pelo Rafael na outra resposta, uma variável <code>volatile</code> ainda poderia incorrer em condição de corrida pois as duas threads podem ler o mesmo valor da memória principal, e o valor final dependeria de qual das threads escreveria ele por último.</p><h1 id=mecanismos-que-regulam-acesso-à-zonas-críticas>Mecanismos que regulam acesso à zonas críticas<a hidden class=anchor aria-hidden=true href=#mecanismos-que-regulam-acesso-à-zonas-críticas>#</a></h1><p>Existem diversos mecanismos que regulam acessos às zonas críticas do software, evitando condições de corridas - <em>race conditions</em>:</p><h2 id=locks>Locks<a hidden class=anchor aria-hidden=true href=#locks>#</a></h2><p>Locks são o mecanismo padrão, que basicamente dizem se alguém tem pode entrar ou não na zona crítica, é como aquele banheiro químico, ou você pode entrar, ou tem alguém lá dentro e você tem que esperar pra entrar.</p><h2 id=semáforos>Semáforos<a hidden class=anchor aria-hidden=true href=#semáforos>#</a></h2><ul><li>Apesar de ter sido inventado em 1965, por E. Dijkstra, os semáforos são a técnica mais usada atualmente</li><li>Um semáforo é uma variável (s), associada a uma região crítica, sobre a qual podem incidir duas operações:</li></ul><ol><li>Operação Down: verifica se o valor de s é maior que zero.  Se for, o valor é decrementado. Senão, a tarefa é bloqueada e o valor de s permanece zero.</li><li>Operação Up: incrementa o valor de s, e desbloqueia as demais tarefas se o valor for zero.</li></ol><p>Ou seja, um semáfaro com valor <em>s</em> inicial de 3, permite que 3 tarefas entrem na zona crítica (3 Downs, descendo o valor para 2,1 e 0)</p><p>Também existem Semáforos Conhecidos como binários ou <em>mutex</em>, que é basicamente um semáforo de valor <em>s</em>=1, ou seja, acomoda apenas um único thread, é um lock convencional :p.</p><h1 id=mecanismos-em-java>Mecanismos em Java:<a hidden class=anchor aria-hidden=true href=#mecanismos-em-java>#</a></h1><h3 id=syncronized>Syncronized<a hidden class=anchor aria-hidden=true href=#syncronized>#</a></h3><p>O mais comum é usarmos a keyword <code>syncronized</code> antes da declaração de algum método ou variável, indicando que ela tem um lock, ou seja, apenas uma thread pode acessá-la por vez, como uma passagem de bastão
Então, no exemplo anterior, adicionar <code>synchronized</code> resolve nosso problema:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>withdrawal</span><span class=o>(</span><span class=kt>int</span> <span class=n>amount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>account</span><span class=o>.</span><span class=na>getBalance</span><span class=o>()</span> <span class=o>&gt;=</span> <span class=n>amount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getThreadName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; está indo sacar dinheiro&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>      <span class=n>account</span><span class=o>.</span><span class=na>withdrawal</span><span class=o>(</span><span class=n>amount</span><span class=o>);</span>
</span></span><span class=line><span class=cl>      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getThreadName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; completou o saque, valor atual da conta &#34;</span> <span class=o>+</span> <span class=n>account</span><span class=o>.</span><span class=na>getBalance</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Sem dinheiro para &#34;</span> <span class=o>+</span> <span class=n>getThreadName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; efetuar o saque &#34;</span> <span class=o>+</span> <span class=n>account</span><span class=o>.</span><span class=na>getBalance</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span></code></pre></div><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6orr8qa7n38oi2x8e53n.png alt="Image description"></p><blockquote><p>[❗] <strong>Importante</strong>
Sleeps e outras operações demoradas não liberam o lock / passa o bastão para outra thread, na realidade, essas threads esperando sua vez ficam bloqueadas na &ldquo;fila&rdquo;</p></blockquote><p>Podemos também usar o synchronized assim: dividindo uma parte da operação como atômica, mas deixando a outra aberta para múltiplas threads. <strong>Nesse caso marcamos qual objeto sofrerá o lock e a operação</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>withdrawal</span><span class=o>(</span><span class=kt>int</span> <span class=n>amount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getThreadName</span><span class=o>()</span> <span class=o>+</span><span class=s>&#34; #### fora do synchronized&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=n>account</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getThreadName</span><span class=o>()</span> <span class=o>+</span><span class=s>&#34; **** dentro do synchronized&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>account</span><span class=o>.</span><span class=na>getBalance</span><span class=o>()</span> <span class=o>&gt;=</span> <span class=n>amount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getThreadName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; está indo sacar dinheiro&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>account</span><span class=o>.</span><span class=na>withdrawal</span><span class=o>(</span><span class=n>amount</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getThreadName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; completou o saque, valor atual da conta &#34;</span> <span class=o>+</span> <span class=n>account</span><span class=o>.</span><span class=na>getBalance</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Sem dinheiro para &#34;</span> <span class=o>+</span> <span class=n>getThreadName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; efetuar o saque &#34;</span> <span class=o>+</span> <span class=n>account</span><span class=o>.</span><span class=na>getBalance</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>Nesse caso, estamos sincronizando apenas o objeto account, um ponto de atenção aqui é não trocar a referência desse objeto: como fazer <code>account = new Account()</code> por isso, uma boa prática é marcar objetos sincronizados como <code>final</code>.</p><blockquote><p>[🤓☝️] <strong>Mutex / Locks Distribuídos</strong>
Alguns sistemas podem optar por usar locks distribuídos entre diferentes processos, isso pode ser feito direto no banco de dados (se for uma aplicação como uma API com múltiplas instâncias rodando) ou usando soluções como o <em><strong>Apache Zookeper</strong></em>, que possuí recursos avançados para tomar conta dos seus processos, evitando <em>starvation</em> & <em>race conditions</em></p></blockquote><h1 id=thread-safe>Thread-Safe<a hidden class=anchor aria-hidden=true href=#thread-safe>#</a></h1><p>Classes &ldquo;thread-safe&rdquo; são classes ou componentes de software projetados para funcionar de maneira segura em ambientes multithread, onde várias threads podem acessá-los e manipulá-los simultaneamente. Em outras palavras, uma classe thread-safe é projetada para evitar condições de corrida, deadlocks e outras situações problemáticas que podem ocorrer quando várias threads acessam recursos compartilhados.</p><blockquote><p>[❗] <strong>Threads safe que&mldr; não são thread safe</strong>
Usar uma classe como Collections.synchronizedList não garante que a classe é thread-safe se uma camada a mais de código não thread-safe for colocada em cima dela (Exemplo, uma classe que faz o add e remove, mas não se importa com a sincronização desses métodos).</p></blockquote><p>Uma classe realmente Thread safe:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>ThreadSafeNames</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>names</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>add</span> <span class=o>(</span><span class=n>String</span> <span class=n>name</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>names</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>name</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>removeFirst</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>names</span><span class=o>.</span><span class=na>size</span><span class=o>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>names</span><span class=o>.</span><span class=na>remove</span><span class=o>(</span><span class=mi>0</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadSafeTest01</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ThreadSafeNames</span> <span class=n>threadSafeNames</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadSafeNames</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>threadSafeNames</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;Junkrat&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Runnable</span> <span class=n>r</span> <span class=o>=</span> <span class=n>threadSafeNames</span><span class=o>::</span><span class=n>removeFirst</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Thread</span><span class=o>(</span><span class=n>r</span><span class=o>).</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Thread</span><span class=o>(</span><span class=n>r</span><span class=o>).</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><blockquote><p>[🤓☝️] <strong>Classes Úteis</strong>
Diversas classes do package java.util.concurrent são úteis para concorrência, exemplos:</p><ol><li>ConcurrentHashMap</li><li>CopyOnWriteArrayList (Uma lista thread-safe em que as operações de leitura não requerem sincronização, tornando-as eficientes para leitura intensiva.)</li><li>AtomicInteger (Uma classe que fornece operações atômicas para incrementar e atualizar inteiros.)</li><li>Semaphore - Semáforos!</li><li>Exchanger: Uma classe que permite que duas threads troquem objetos em um ponto de encontro, facilitando a comunicação entre threads.</li></ol></blockquote><h2 id=exemplo-envio-de-email>Exemplo: Envio de Email<a hidden class=anchor aria-hidden=true href=#exemplo-envio-de-email>#</a></h2><p>Podemos ter um serviço para envio de email, onde temos uma thread colocando emails em uma fila, e sempre notificando as worker-threads quando um email novo chegar, assim agilizando o envio por múltiplas threads.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Members</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Queue</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>emails</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayBlockingQueue</span><span class=o>&lt;&gt;(</span><span class=mi>10</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>boolean</span> <span class=n>open</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isOpen</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>open</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>pendingEmails</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=n>emails</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>emails</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>addMemberEmail</span><span class=o>(</span><span class=n>String</span> <span class=n>email</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>emails</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>String</span> <span class=n>threadName</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>threadName</span> <span class=o>+</span> <span class=s>&#34; Adicionou email na lista&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>.</span><span class=na>emails</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>email</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>.</span><span class=na>emails</span><span class=o>.</span><span class=na>notifyAll</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>retrieveEmail</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; checking if there are emails&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>emails</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>emails</span><span class=o>.</span><span class=na>size</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(!</span><span class=n>open</span><span class=o>)</span> <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; Não tem email disponível na lista, entrando em modo de espera&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>this</span><span class=o>.</span><span class=na>emails</span><span class=o>.</span><span class=na>wait</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>emails</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>close</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>open</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>emails</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; Notificando todo mundo que não estamos mais pegando emails&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><blockquote><p>[❗] <strong>Atenção!</strong>
addMemberEmail e retrieveEmail podem ser usados ao mesmo tempo: sim, eles podem ser usados ao mesmo tempo. Embora ambos usem o mesmo objeto (this.emails) como bloqueio, eles estão bloqueando diferentes partes críticas do código. Enquanto addMemberEmail está bloqueando para adicionar um email, retrieveEmail está bloqueando para verificar e remover um email. Isso permite que esses métodos sejam chamados simultaneamente sem interferir um no outro.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>EmailDeliveryService</span> <span class=kd>implements</span> <span class=n>Runnable</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Members</span> <span class=n>members</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>EmailDeliveryService</span><span class=o>(</span><span class=n>Members</span> <span class=n>members</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>members</span> <span class=o>=</span> <span class=n>members</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>threadName</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>threadName</span> <span class=o>+</span><span class=s>&#34; starting to deliver emails...&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=o>(</span><span class=n>members</span><span class=o>.</span><span class=na>isOpen</span><span class=o>()</span> <span class=o>||</span> <span class=n>members</span><span class=o>.</span><span class=na>pendingEmails</span><span class=o>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>String</span> <span class=n>email</span> <span class=o>=</span> <span class=n>members</span><span class=o>.</span><span class=na>retrieveEmail</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=o>(</span><span class=n>email</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>continue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>threadName</span> <span class=o>+</span> <span class=s>&#34; enviando email para &#34;</span> <span class=o>+</span> <span class=n>email</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>Thread</span><span class=o>.</span><span class=na>sleep</span><span class=o>(</span><span class=mi>2000</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>threadName</span> <span class=o>+</span> <span class=s>&#34; enviou email com sucesso para &#34;</span><span class=o>+</span> <span class=n>email</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Todos os emails foram enviados com sucesso!&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>EmailDeliveryTest01</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Members</span> <span class=n>members</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Members</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>jiraya</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>(</span><span class=k>new</span> <span class=n>EmailDeliveryService</span><span class=o>(</span><span class=n>members</span><span class=o>),</span> <span class=s>&#34;Jiraya&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>kakashi</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>(</span><span class=k>new</span> <span class=n>EmailDeliveryService</span><span class=o>(</span><span class=n>members</span><span class=o>),</span> <span class=s>&#34;Kakashi&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>jiraya</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>kakashi</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=n>String</span> <span class=n>email</span> <span class=o>=</span> <span class=n>JOptionPane</span><span class=o>.</span><span class=na>showInputDialog</span><span class=o>(</span><span class=s>&#34;Entre com seu email&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=o>(</span><span class=n>email</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>email</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>()){</span>
</span></span><span class=line><span class=cl>                <span class=n>members</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>members</span><span class=o>.</span><span class=na>addMemberEmail</span><span class=o>(</span><span class=n>email</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h1 id=exemplo-clássico--jantar-dos-filósofos-deadlock>Exemplo Clássico : Jantar Dos Filósofos (Deadlock)<a hidden class=anchor aria-hidden=true href=#exemplo-clássico--jantar-dos-filósofos-deadlock>#</a></h1><p><a href=https://blog.pantuza.com/artigos/o-jantar-dos-filosofos-problema-de-sincronizacao-em-sistemas-operacionais>https://blog.pantuza.com/artigos/o-jantar-dos-filosofos-problema-de-sincronizacao-em-sistemas-operacionais</a></p><p>O jantar dos filósofos foi pensado por Dijkstra (esse cara realmente foi foda né)</p><p>Cinco filósofos estão sentados em uma mesa redonda para jantar. Cada filósofo tem um prato com espaguete à sua frente. Cada prato possui um garfo para pegar o espaguete. O espaguete está muito escorregadio e, para que um filósofo consiga comer, será necessário utilizar dois garfos.</p><p>Lembre-se que é apenas uma analogia. Nesse sentido, cada filósofo alterna entre duas tarefas: <strong>comer</strong> ou <strong>pensar</strong>. Quando um filósofo fica com fome, ele tenta pegar os garfos à sua esquerda e à sua direita; um de cada vez, independente da ordem. Caso ele consiga pegar <strong>dois garfos</strong>, ele come durante um determinado tempo e depois recoloca os garfos na mesa. Em seguida ele volta a pensar.</p><p><em>Você é capaz de propor um <strong>algoritmo</strong> que implemente cada <strong>filósofo</strong> de modo que ele execute as tarefas de <strong>comer</strong> e <strong>pensar</strong> sem <strong>nunca</strong> ficar <strong>travado</strong>?</em></p><p>Não vou colocar a solução aqui, mas se te deixou curioso, acesse o link acima, é uma ótima explicação. A solução normalmente aceita é usar os semáforos que falamos anteriormente</p><h1 id=agradecimentos-especiais>Agradecimentos Especiais<a hidden class=anchor aria-hidden=true href=#agradecimentos-especiais>#</a></h1><ul><li>Obrigado André Leon, professor de S.O que me introduziu bem à esses conceitos, me perdoe se não usei algum termo corretamente professor 🙏.</li><li>Obrigado especial ao <a href=https://fidelissauro.dev/concorrencia-paralelismo/>Matheus Fidelis</a>, que fez um post super completo sobre concorrência e paralelismo, mais desvinculado da linguagem</li><li>Obrigado especial também ao <a href=https://www.youtube.com/@DevDojoBrasil>William Suane</a>, um dos responsáveis por uma nova geração de Javeiros competentes no mundo</li></ul><h1 id=referências>Referências<a hidden class=anchor aria-hidden=true href=#referências>#</a></h1><ul><li><a href=https://www.youtube.com/@DevDojoBrasil>https://www.youtube.com/@DevDojoBrasil</a></li><li><a href=https://fidelissauro.dev/concorrencia-paralelismo/>https://fidelissauro.dev/concorrencia-paralelismo/</a></li><li><a href=https://blog.pantuza.com/artigos/o-jantar-dos-filosofos-problema-de-sincronizacao-em-sistemas-operacionais>https://blog.pantuza.com/artigos/o-jantar-dos-filosofos-problema-de-sincronizacao-em-sistemas-operacionais</a></li><li><a href=https://pt.stackoverflow.com/a/116080>https://pt.stackoverflow.com/a/116080</a></li><li><a href=https://pt.wikipedia.org/wiki/Regi%C3%A3o_cr%C3%ADtica>https://pt.wikipedia.org/wiki/Regi%C3%A3o_cr%C3%ADtica</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://kaue.cat/tags/concorrencia/>Concorrencia</a></li><li><a href=https://kaue.cat/tags/java/>JAVA</a></li></ul><nav class=paginav><a class=prev href=https://kaue.cat/posts/concorrencia-java/thread-safe/><span class=title>« Página Anterior</span><br><span>3. Classes Thread Safe em Java - Conceito e Introdução</span></a>
<a class=next href=https://kaue.cat/posts/concorrencia-java/threads-java/><span class=title>Próxima Página »</span><br><span>1. Concorrência em Java: Threads! Processando em Paralelo e Ganhando Throughput</span></a></nav><div class=share-buttons><a>Compartilhar:</a><br><a target=_blank rel="noopener noreferrer" aria-label="share 2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida on x" href="https://x.com/intent/tweet/?text=2.%20Sincroniza%c3%a7%c3%a3o%20de%20Threads%20-%20DeadLocks%2c%20Zonas%20Cr%c3%adticas%20e%20Condi%c3%a7%c3%b5es%20de%20Corrida&url=https%3a%2f%2fkaue.cat%2fposts%2fconcorrencia-java%2fdesafios%2f&hashtags=Concorrencia%2cJAVA"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkaue.cat%2fposts%2fconcorrencia-java%2fdesafios%2f&title=2.%20Sincroniza%c3%a7%c3%a3o%20de%20Threads%20-%20DeadLocks%2c%20Zonas%20Cr%c3%adticas%20e%20Condi%c3%a7%c3%b5es%20de%20Corrida&summary=2.%20Sincroniza%c3%a7%c3%a3o%20de%20Threads%20-%20DeadLocks%2c%20Zonas%20Cr%c3%adticas%20e%20Condi%c3%a7%c3%b5es%20de%20Corrida&source=https%3a%2f%2fkaue.cat%2fposts%2fconcorrencia-java%2fdesafios%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2. Sincronização de Threads - DeadLocks, Zonas Críticas e Condições de Corrida on whatsapp" href="https://api.whatsapp.com/send?text=2.%20Sincroniza%c3%a7%c3%a3o%20de%20Threads%20-%20DeadLocks%2c%20Zonas%20Cr%c3%adticas%20e%20Condi%c3%a7%c3%b5es%20de%20Corrida%20-%20https%3a%2f%2fkaue.cat%2fposts%2fconcorrencia-java%2fdesafios%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//www-kaue-cat.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://kaue.cat>Kaue Gatto</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copiar";function s(){t.innerHTML="copiado!",setTimeout(()=>{t.innerHTML="copiar"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>