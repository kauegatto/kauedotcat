<!doctype html><html lang=pt dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[WIP] Virtual Threads em Java! | Kaue Gatto</title><meta name=keywords content="ARCHITECTURE"><meta name=description content="Vamos finalmente entender o Project Loom! Que adiciona as virutal threads no LTS da JDK 21"><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=apple-touch-icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=mask-icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=pt href=https://kaue.cat/posts/virtual-threads/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6MZTJBEG75"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6MZTJBEG75",{anonymize_ip:!1})}</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-6MZTJBEG75","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6MZTJBEG75"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6MZTJBEG75",{anonymize_ip:!1})}</script><meta property="og:title" content="[WIP] Virtual Threads em Java!"><meta property="og:description" content="Vamos finalmente entender o Project Loom! Que adiciona as virutal threads no LTS da JDK 21"><meta property="og:type" content="article"><meta property="og:url" content="https://kaue.cat/posts/virtual-threads/"><meta property="og:image" content="https://kaue.cat/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-25T16:43:03+00:00"><meta property="article:modified_time" content="2024-03-25T16:43:03+00:00"><meta property="og:site_name" content="Kaue Gatto - Blog de Desenvolvimento"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kaue.cat/%3Cimage%20path/url%3E"><meta name=twitter:title content="[WIP] Virtual Threads em Java!"><meta name=twitter:description content="Vamos finalmente entender o Project Loom! Que adiciona as virutal threads no LTS da JDK 21"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kaue.cat/posts/"},{"@type":"ListItem","position":3,"name":"[WIP] Virtual Threads em Java!","item":"https://kaue.cat/posts/virtual-threads/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[WIP] Virtual Threads em Java!","name":"[WIP] Virtual Threads em Java!","description":"Vamos finalmente entender o Project Loom! Que adiciona as virutal threads no LTS da JDK 21","keywords":["ARCHITECTURE"],"articleBody":"O Artigo Primeiro, vamos estabelecer objetivos desse artigo:\n‚úÖ Objetivos\nDar uma breve Introdu√ß√£o √† Programa√ß√£o Concorrente e Paralela Explicar o hist√≥rico da programa√ß√£o concorrente no JAVA Mostrar brevemente como o problema de throughput era resolvido no JAVA Explicar Virtual Threads Mostrar exemplos pr√°ticos do uso de Virtual Threads Mostrar concorr√™ncia estruturada\nE‚Ä¶\n‚ùå N√£o Objetivos\nN√£o √© objetivo explicar em detalhes mecanismos de programa√ß√£o concorrente \u0026 paralela, para isso, recomendo fortemente esse artigo do Matheus Fidelis N√£o √© objetivo explicar em detalhes como a programa√ß√£o reativa e multithreaded √© feita em JAVA (sem ser com Virtual Threads) Entrar em detalhe sobre assuntos espec√≠ficos do pacote java.util.concurrent - Futures, Executors, Synchronizers, Cole√ß√µes Thread-Safe, etc. Para isso, recomendo ocurso gratuito de Java do DevDojo\nVirtual Threads Virtual Threads √© uma feature que est√° dispon√≠vel para uso em um LTS desde o Java 21, tamb√©m chamado de project loom, √© o projeto de integrar maneiras mais f√°ceis de escrever programas concorrentes e reativos em JAVA, a fim de misturar performance e usabilidade\nüîë Pontos Chave\nA virtual thread is a¬†Thread¬†‚Äî in code, at runtime, in the debugger and in the profiler. A virtual thread is not a wrapper around an OS thread, but a Java entity. Creating a virtual thread is cheap ‚Äî have millions, and don‚Äôt pool them! Blocking a virtual thread is cheap ‚Äî be synchronous! No language changes are needed. Pluggable schedulers offer the flexibility of asynchronous programming. ‚úÖ Objetivos\nEnable server applications written in the simple thread-per-request style to scale with near-optimal hardware utilization. Enable existing code that uses the java.lang.Thread API to adopt virtual threads with minimal change. Enable easy troubleshooting, debugging, and profiling of virtual threads with existing JDK tools. ‚ùå N√£o Objetivos\nIt is not a goal to remove the traditional implementation of threads, or to silently migrate existing applications to use virtual threads. It is not a goal to change the basic concurrency model of Java. It is not a goal to offer a new data parallelism construct in either the Java language or the Java libraries. The¬†Stream API¬†remains the preferred way to process large data sets in parallel. Conceitos De maneira geral, usamos as virtual threads por um motivo: Aumentar o throughput (vaz√£o) da nossa aplica√ß√£o (n√£o velocidade, que est√° relacionado √† lat√™ncia. Por enquanto, a maneira mais comum √© uma: Programa√ß√£o Reativa, vamos entender como a programa√ß√£o reativa era no passado, e como vamos implement√°-la com as virtual threads.\nüí° Throughput?\nThroughput diz respeito √† quantidade de elementos que voc√™ processa por uma medida de tempo (exemplo: Requests/Segundo em uma aplica√ß√£o HTTP, Mensagens Processadas por Segundo em um message broker).\nPrograma√ß√£o Ass√≠ncrona e Concorrente A maior parte do c√≥digo que escrevemos √© s√≠ncrono, isso significa que o c√≥digo vai ser executado imediatamente quando chegar naquela instru√ß√£o, o c√≥digo ass√≠ncrono √© um c√≥digo que vai ser executado, em algum momento no futuro, como uma promessa de execu√ß√£o. C√≥digos ass√≠ncronos n√£o significam a mesma coisa que concorrentes, um forEach ass√≠nrono, por exemplo, roda na thread principal de um programa, um c√≥digo concorrente significa que ele vai ser executado em outra thread!\nPodemos criar tarefas (Tasks) para rodarem em Threads, e para criarmos uma Thread, temos duas maneiras:\nCriar uma Thread a partir de seu construtor, e passar √† ela sua Task Usar uma pool (piscina) de Threads e deixar com que o executor entregue a tarefa √† uma thread dispon√≠vel (se ela existir) Essa Abordagem √© muito comum pois Threads s√£o recursos limitados que n√£o s√£o leves de criar e destruir Conex√µes de Banco de dados tamb√©m passam ficam em um ‚ÄúPool‚Äù quando usamos frameworks como o Spring, a biblioteca que cuida da cria√ß√£o de um Pool de Conex√µes √© o Hikari Nesse cen√°rio, vamos criar uma task, submet√™-la ao Executor, e receberemos uma promessa de execu√ß√£o, por esse ponto de vista, essa tarefa √© ass√≠ncrona pois ser√° executada no futuro, mas tamb√©m √© concorrente, pois ser√° executada em uma thread diferente. Aqui os conceitos se encontram, mas n√£o s√£o a mesma coisa c√≥digo concorrente √© ass√≠ncrono, mas nem todo c√≥digo ass√≠ncrono √© concorrente!\nExecu√ß√£o Bloqueante Uma execu√ß√£o bloqueante significa que uma instru√ß√£o est√° sendo executada pela sua CPU (ou por um core dela) e que nenhuma outra instru√ß√£o ir√° ocorrer enquanto a anterior ainda estiver acontecendo, mesmo que sua CPU n√£o esteja sendo utilizada, normalmente em uma espera de I/O ou para entrar em um bloco de c√≥digo sincronizado. Nesse cen√°rio ir√° ocorrer uma troca de contexto, um processo relativamente ‚Äúcaro‚Äù para sua CPU que basicamente desaloca o processo at√© que ele exija algo novamente da CPU, por sua vez, o c√≥digo n√£o bloqueante garante que sua CPU evite trocas de contextos e esteja sempre sendo utilizada.\nO Cen√°rio Atual - Por qu√™ usar Virtual Threads? Primeiro, analise o c√≥digo JAVA que faz uma chamada HTTP padr√£o para um servidor:\nURI url = URI.create(\"https://mydata.com/data\"); HttpClient client = HttpClient.newBuilder().build(); HttpRequest request = HttpRequest.newBuilder(url).GET().build(); var response = client.send(request, HttpResponse.BodyHandlers.ofString()); Aqui, podemos ver que nossa CPU s√≥ √© realmente utilizada de maneira eficiente durante 200 nano segundos, e fica ociosa a maior parte do tempo, esperando a resposta da chamada.\nComo podemos arrumar isso?\n0. O Patinho lento - One Request Per Thread A primeira ideia √© irmos no aspecto concorrente, quando sua thread estiver esperando, o Task Scheduler vai remover ela do n√∫cleo que est√° rodando (Context Switching) e coloca outra thread no lugar, executar uma request em cada thread (One-Request-Per-Thread) √© a maneira convencional, que v√™m sido utilizada h√° bons anos.\nNesse cen√°rio, precisar√≠amos de 500 mil de threads - advindo da propor√ß√£o entre tempo ocioso e trabalhado. 100ms/200ns - (requests) nesse n√∫cleo para alcan√ßarmos o uso de 100% de CPU, garantindo que sua CPU n√£o fique ociosa. Isso definitivamente n√£o boa bom, n√©? As threads no JAVA encapsula uma thread do Sistema Operacional, tamb√©m chamada de Platform Thread ou Kernel Thread, o problema √© que o custo de cria√ß√£o de cria√ß√£o de uma Thread em JAVA, √© o mesmo de criar uma Thread no SO, que √© relativamente caro\nFonte\nRecursos caros como threads s√£o colocados em ‚ÄúPools‚Äù para lidar com eles de maneiras mais eficientes:\n‚ùù ‚ùû\nDevelopers sometimes use thread pools to limit concurrent access to limited resources. For example, if a service cannot handle more than 20 concurrent requests then making all requests to the service via tasks submitted to a thread pool of size 20 will ensure that. This idiom has become ubiquitous because the high cost of platform threads has made thread pools ubiquitous Fonte: https://openjdk.org/jeps/444\nPerfeito, mas voltando ao exemplo anterior, precisamos de 500.000 threads, quanto isso vai nos custar?\nMem√≥ria: 500.000Mb Tempo de in√≠cio: 500 Segundos Com isso, entendemos que o modelo One Request Per Thread n√£o √© mais vi√°vel: O artigo Transformation patterns for a reactive application, de Bruno Miguel Mendon√ßa Maia pontua como caracter√≠stica desses sistemas :\nPontos Negativos ( ‚Äì ) Concurrency. Synchronous programming is not the best suited model for dealing with concurrency as the execution will start and block the current thread while waiting for the result. ( ‚Äì ) Throughput. While a thread waits for the expensive execution to return its result, the OS can exchange active threads to promote concurrency, but this has overhead costs and hinders throughput due to thread context switching and cache invalidation. ( ‚Äì ) Latency. Thread blocking on execution and the lower throughput due to the OS exchanging active threads and consequently cache invalidation leads to poorer latency.\nPontos Positivos (+) Ease of use. The synchronous sequential model and its typical imperative programming style provides a familiar thinking model that results in ease of use. (+) Maintainability. Synchronous programming and its sequential execution model provides an easy to reason with concept that in turn increase maintainability. Furthermore, error handling in sequential execution is easier to tackle.\n1. O patinho feio - Processar m√∫ltiplos requests em uma Thread Essa abordagem √© a abordagem Reativa. A abordagem reativa tem um princ√≠pio simples de dividir uma request em pequenas por√ß√µes e nenhuma por√ß√£o pode conter c√≥digo bloqueantes:\nAqui dividimos as etapas como foi acordado anteriormente (exceto pelo fato de que a step2 pode bloquear a CPU) Com isso, precisamos usar um framework reativo que permita que usemos essas lambdas (aqui o exemplo √© completableFuture, que faz a mesma coisa, mas usando a pool de threads, mas serve bem para explicar.):\nSeu framework de execu√ß√£o ter√° a responsabilidade de conectar as lambdas para que o resultado delas seja passado para a pr√≥xima fun√ß√£o corretamente, √© seu trabalho n√£o escrever c√≥digo bloqueante nesse caso. Como seu framework vai ter pouqu√≠ssimas threads (talvez s√≥ uma por n√∫cleo), e muitas requests v√£o ser processadas em uma mesma thread, escrever c√≥digo bloqueante vai impactar MUITO sua performance.\nNesse caso em espec√≠fico, a thread n√£o ser√° bloqueada pois CompletableFuture conhece o HttpRequest.send() e registra um callback, que ser√° executado quando a fun√ß√£o terminar de rodar.\nPontos Negativos C√≥digo dif√≠cil de ler C√≥digo dif√≠cil de dar manuten√ß√£o √â f√°cil de arruinar a performance com um peda√ßo de c√≥digo bloqueante. Dif√≠cil de testar 2. O Patinho que Existe - Futures e Callback Hell Aqui, usamos ainda do One Request Per Thread, mas com estrat√©gias um pouco diferentes, usamos Futures para escrever c√≥digo paraleliz√°vel e concorrente, ganhando performance.\nFonte https://blog.soaresdev.com/funcoes-callback-em-javascript/\nO post Virtual threads: Are futures a thing of the past?, na Java Magazine, retrata a hist√≥ria do c√≥digo concorrente em Java. L√°, √© retratado o uso de Futures para colocar suas Threads para rodar por√ß√µes bloqueantes em paralelo:\nvoid handleRequest(Socket socket) { var request = new Request(socket); var futureWeather = CompletableFuture.supplyAsync(() -\u003e Weather.fetch(request), exec2); var futureRestaurants = CompletableFuture.supplyAsync(() -\u003e Restaurants.fetch(request), exec2); var futureTheaters = CompletableFuture.supplyAsync(() -\u003e Theaters.fetch(request), exec2); new Page(request) .setWeather(futureWeather.join()) .setRestaurants(futureRestaurants.join()) .setTheaters(futureTheaters.join()) .send(); } A ordem em que as tr√™s tasks esperam pelo resultado n√£o importa, a thread coloca os 3 Jobs para rodar, e depois bloqueia (espera) at√© que elas tenham terminado. Mas pera, ‚Äúe depois bloqueia (espera) at√© que elas tenham terminado‚Äù‚Ä¶ Exato, ainda podemos melhorar isso bastante, bloquear Threads tem um custo:\nEsse blocking traz a possibilidade de deadlocks acontecerem. Aqui, teremos uma pool para computar recursos e para lidar com requests. Bloquear e desbloquear threads traz perda de performance. Claramente sua CPU n√£o vai ficar 2 Segundos esperando a sua resposta de I/O e vai colocar outra thread para trabalhar nesse meio termo, apesar disso, existe um custo n√£o s√≥ para fazer a troca de contexto, mas isso tamb√©m ir√° causar perda de dados em cache no processador, resultando em cache misses quando a thread estiver de volta. Podemos ‚Äúresolver‚Äù isso usando callbacks!\npublic class Server { private final ServerSocket server = new ServerSocket(port); private final ExecutorService exec = Executors.newFixedThreadPool(16); public void run() { while (!server.isClosed()) { var socket = server.accept(); exec.execute(() -\u003e handleRequest(socket)); } exec.close(); } void handleRequest(Socket socket) { var request = new Request(socket); var futureWeather = CompletableFuture.supplyAsync(() -\u003e Weather.fetch(request), exec); var futureRestaurants = CompletableFuture.supplyAsync(() -\u003e Restaurants.fetch(request), exec); var futureTheaters = CompletableFuture.supplyAsync(() -\u003e Theaters.fetch(request), exec); var page = new Page(request); futureWeather.thenAccept(weather -\u003e futureRestaurants.thenAccept(restaurants -\u003e futureTheaters.thenAccept(theaters -\u003e page.setWeather(weather) .setRestaurants(restaurants) .setTheaters(theaters) .send()))); } } Future.thenAccept recebe como argumento um consumer, que ir√° consumir o resultado dessa future, a invoca√ß√£o de thenAccept s√≥ registra o c√≥digo para uma execu√ß√£o futura, ele n√£o espera o c√≥digo ser completado, registrando um callback. Nesse cen√°rio, as threads nunca s√£o bloqueadas e uma √∫nica pool n√£o muito vasta pode ser usada. O c√≥digo tamb√©m est√° livre de deadlocks.\nCallbacks s√£o dif√≠ceis de escrever e de debugar, voc√™ pode ter percebido que nesse simples evento, j√° temos 3 n√≠veis de aninhamento de c√≥digo, podemos melhorar isso usando outras features para lidar com futures de maneira n√£o bloqueantes, como usando thenCombine:\nvoid handleRequest(Socket socket) { var request = new Request(socket); var futureWeather = CompletableFuture.supplyAsync(() -\u003e Weather.fetch(request), exec); var futureRestaurants = CompletableFuture.supplyAsync(() -\u003e Restaurants.fetch(request), exec); var futureTheaters = CompletableFuture.supplyAsync(() -\u003e Theaters.fetch(request), exec); CompletableFuture.completedFuture(new Page(request)) .thenCombine(futureWeather, Page::setWeather) .thenCombine(futureRestaurants, Page::setRestaurants) .thenCombine(futureTheaters, Page::setTheaters) .thenAccept(Page::send); } Nesse cen√°rio, o √∫nico processamento que a thread que lida com as conex√µes performa √© a cria√ß√£o da p√°gina base, mas isso tamb√©m poderia ser ass√≠ncrono:\npublic class Server { private final ServerSocket server = new ServerSocket(port); private final ExecutorService exec = Executors.newFixedThreadPool(16); public void run() { while (!server.isClosed()) { var socket = server.accept(); handleRequest(socket); } exec.close(); } void handleRequest(Socket socket) { var futureRequest = CompletableFuture.supplyAsync(() -\u003e new Request(socket), exec); var futureWeather = futureRequest.thenApplyAsync(Weather::fetch, exec); var futureRestaurants = futureRequest.thenApplyAsync(Restaurants::fetch, exec); var futureTheaters = futureRequest.thenApplyAsync(Theaters::fetch, exec); futureRequest .thenApplyAsync(Page::new, exec) .thenCombine(futureWeather, Page::setWeather) .thenCombine(futureRestaurants, Page::setRestaurants) .thenCombine(futureTheaters, Page::setTheaters) .thenAccept(Page::send); } } 3. O Patinho bonito - Construir uma thread virtual, mais leve que Platform Threads. As virtual threads s√£o exatamente isso, conseguimos performance, simplicidade e boa capacidade de manuten√ß√£o evitando c√≥digos reativos e sem ter medo de c√≥digos bloqueantes.\n‚ùù ‚ùû Implica√ß√µes\nVirtual threads are cheap and plentiful, and thus should never be pooled: A new virtual thread should be created for every application task. Most virtual threads will thus be short-lived and have shallow call stacks, performing as little as a single HTTP client call or a single JDBC query. Platform threads, by contrast, are heavyweight and expensive, and thus often must be pooled. They tend to be long-lived, have deep call stacks, and be shared among many tasks. In summary, virtual threads preserve the reliable thread-per-request style that is harmonious with the design of the Java Platform while utilizing the available hardware optimally. Using virtual threads does not require learning new concepts, though it may require unlearning habits developed to cope with today‚Äôs high cost of threads. Virtual threads will not only help application developers ‚Äî they will also help framework designers provide easy-to-use APIs that are compatible with the platform‚Äôs design without compromising on scalability.\n‚ùó Refor√ßando!\nN√£o crie pools de threads virtuais!\nEscrevendo Virtual Threads As maneiras que podemos criar virtual s√£o simples:\nVia factory Thread t3 = Thread.ofVirtual() .name(\"Thread virtual!\") .start(task); t3.join(); Thread.startVirtualThread(task) Thread t4 = Thread.startVirtualThread(task); t4.join(); Usando um executorService (com o m√©todo newVirtualThreadPerTaskExecutor): public static void execute(){ var set = ConcurrentHashMap.\u003cString\u003enewKeySet(); Runnable task = () -\u003e set.add(Thread.currentThread().toString()); int N_TASKS = 500; try (var executorService = Executors.newVirtualThreadPerTaskExecutor()) { for (int index = 0; index \u003c N_TASKS; index++) { executorService.submit(task); } } System.out.println(\"# threads used = \" + set.size()); } Como Virtual Threads funcionam Uma virtual thread √© executada em cima de uma platform thread, que chamamos de Carrier Thread. Essas carrier threads s√£o organizadas em uma √∫nica ForkJoinPool, onde cada Platform (tamb√©m carrier) ter√° uma waitlist de virtual threads associadas √† ela.\nPara evitar Starvation das threads do Sistema Operacional, se uma waitlist de uma Platform Thread zerar, ela vai ‚Äúroubar‚Äù tarefas de outras threads. Com isso, percebemos que executar um ‚Äúrunnable‚Äù em uma virtual thread, na realidade roda ele em uma thread real, portanto, se formos executar uma opera√ß√£o completamente n√£o bloqueante, virtual threads s√£o mais caras, √© um overhead, se for o caso, rode-as diretamente na thread comum. Virtual Threads s√£o feitas para executar c√≥digos bloqueantes!\n‚ö†Ô∏è Aviso\nVirtual Threads n√£o s√£o feitas para rodar opera√ß√µes em mem√≥ria!\nQuando opera√ß√µes bloqueantes rodam em virtual threads, elas se separam de sua Carrier Thread, usando ‚Äúyield‚Äù para basicamente suspender a execu√ß√£o desse c√≥digo, liberando a thread principal para trabalhar com outras coisas, ent√£o essa virtual thread √© guardada na mem√≥ria principal (heap) e quando estiver pronta, √© colocada de novo na waitlist das threads principais, atrav√©s de um callback, mas isso tudo √© feito de maneira transparente!\nNote que Continuation.yield() respons√°vel por garantir esse processo para que a thread principal n√£o seja bloqueada, precisa ser implementado em opera√ß√µes bloqueantes (isso j√° est√° feito).\nPor exemplo, nessa linha de c√≥digo:\nresponse.send(future1.get() + future2.get()); Essas opera√ß√µes v√£o fazer com que a thread virutal monte e desmonte de sua carrier thread diversas vezes, provavelmente uma para cada call para get()e poss√≠velmente muitas outras vezes ao longo da execu√ß√£o de .send() gra√ßas √†s opera√ß√µes de I/O.\nExemplos Exemplo usando um executor que cria uma virtual thread para cada task bloqueante. void handle(Request request, Response response) { var url1 = ... var url2 = ... try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { var future1 = executor.submit(() -\u003e fetchURL(url1)); var future2 = executor.submit(() -\u003e fetchURL(url2)); response.send(future1.get() + future2.get()); } catch (ExecutionException | InterruptedException e) { response.fail(e); } } String fetchURL(URL url) throws IOException { try (var in = url.openStream()) { return new String(in.readAllBytes(), StandardCharsets.UTF_8); } } Mesmo procedimento usado no cap√≠tulo [[#2. O Patinho que Existe - Futures e Callback Hell]], mas usando virtual threads, que n√£o bloqueiam sua CPU! void handleRequest(Socket socket) { var request = new Request(socket); var futureWeather = new CompletableFuture\u003cWeather\u003e(); var futureRestaurants = new CompletableFuture\u003cRestaurants\u003e(); var futureTheaters = new CompletableFuture\u003cTheaters\u003e(); Thread.startVirtualThread(() -\u003e futureWeather.complete(Weather.fetch(request))); Thread.startVirtualThread(() -\u003e futureRestaurants.complete(Restaurants.fetch(request))); Thread.startVirtualThread(() -\u003e futureTheaters.complete(Theaters.fetch(request))); new Page(request) .setWeather(futureWeather.join()) .setRestaurants(futureRestaurants.join()) .setTheaters(futureTheaters.join()) .send(); } Parecido com o exemplo 2, mas com um aroma mais funcional (Considerando que o executorService prov√™ virtual threads.) void handleRequest(Socket socket) { var futureRequest = CompletableFuture.supplyAsync(() -\u003e new Request(socket), exec); var futureWeather = futureRequest.thenApplyAsync(Weather::fetch, exec); var futureRestaurants = futureRequest.thenApplyAsync(Restaurants::fetch, exec); var futureTheaters = futureRequest.thenApplyAsync(Theaters::fetch, exec); futureRequest .thenApplyAsync(Page::new, exec) .thenCombine(futureWeather, Page::setWeather) .thenCombine(futureRestaurants, Page::setRestaurants) .thenCombine(futureTheaters, Page::setTheaters) .thenAccept(Page::send); } } Uma maneira imperativa, sem o uso de futures void handleRequest(Socket socket) { var request = new Request(socket); var page = new Page(request); Thread t1 = Thread.startVirtualThread(() -\u003e page.setWeather(Weather.fetch(request))); Thread t2 = Thread.startVirtualThread(() -\u003e page.setRestaurants(Restaurants.fetch(request))); Thread t3 = Thread.startVirtualThread(() -\u003e page.setTheaters(Theaters.fetch(request))); t1.join(); t2.join(); t3.join(); page.send(); } Um ponto negativo aqui √© que a Pagina deve ser thread safe e deve ser constru√≠da antes do uso dos fetches pois todos esses m√©todos podem alterar e acessar esse recurso ao mesmo tempo. Nesse caso, algum tipo de sincroniza√ß√£o ou lock ter√° de ocorrer (pinning nesse caso n√£o soa t√£o ruim pelo contexto que a cria√ß√£o/set de um objeto Page √© r√°pido)\nMais uma imagem de exemplo:\n‚ö†Ô∏è Aviso\nComo movemos coisas para a mem√≥ria e trazemos-as de volta, teremos problemas se estivermos usando ponteiros diretamente, mas voc√™ provavelmente n√£o vai fazer isso em JAVA. Apesar disso, o bloco ‚Äúsynchronized‚Äù, faz isso, e quando isso acontece, a task executa de maneira bloqueante na platform thread, sem ir para a heap memory como as virtual threads fazem, ou seja, o yield n√£o acontece. Chamamos isso de pinning, se voc√™ precisar usar ‚Äúsynchronized‚Äù em um bloco que leva uma quantidade consider√°vel de tempo (milisegundos), refatore-o para usar ReentrantLock, sen√£o voc√™ vai bloquear sua pequena quantidade de platform threads por bastante tempo :(\nAdicionalmente, voc√™ pode observar com facilidade os pinnings de platform threads: New diagnostics assist in migrating code to virtual threads and in assessing whether you should replace a particular use of¬†synchronized¬†with a¬†java.util.concurrent¬†lock:\nA JDK Flight Recorder (JFR) event is emitted when a thread blocks while pinned (see¬†JDK Flight Recorder). Habilitando no Spring Para habilitar virtual threads no SPRING, use:\nspring: threads: virtual: enabled: true ## ou spring.threads.virtual.enabled=true Essa altera√ß√£o j√° far√° com que seu servidor deixe de trabalhar com o antigo cen√°rio de uma thread por request, poss√≠velmente melhorando sua performance, mesmo sem muitas altera√ß√µes (No caso, isso provavelmente s√≥ ocorrer√° se voc√™ j√° estiver recebendo uma quantidade de chamadas o suficiente para esgotar sua pool de platform threads, que √© 200).\nConcorr√™ncia Estruturada - Feature Preview A feature de Concorr√™ncia Estruturada, tem como foco a escrita simples de c√≥digos concorentes, usando o paradigma imperativo.\nEm um passado distante, os c√≥digos que eram escritos eram recheados de ‚Äúgo-tos‚Äù, o que dificultava muito o custo de manuten√ß√£o pela dificuldade de entender o fluxo de execu√ß√£o do programa, estar dentro de um else n√£o significava necessariamente, que seu if falhou.\nO problema disso √© que c√≥digo concorrente, em sua forma atual √© como usar um go-to, voc√™ n√£o consegue saber quem invocou a instru√ß√£o que est√° rodando na thread.\n‚úÖ Objetivos\nPromover um estilo de programa√ß√£o concorrente que pode evitar riscos comuns associados ao uso de c√≥digos concorrentes e paralelizado Melhorar a observabilidade desse tipo de c√≥digo ‚ùå N√£o-Objetivos\nSubstituir maneiras de trabalhar com c√≥digo concorrente, como : ExecutorService¬†e¬†Future. Definir a API definitiva de Concorr√™ncia Estruturada para a plataforma java, permitindo que outras formas surjam em novas bibliotecas ou releases da JDK Definir maneiras de compartilhar streams de dados entre diferentes threads (exemplo: canais) Substituir o mecanismo de interrup√ß√£o de thread j√° existente, mas pode ser no futuro. ‚ö°‚ò†Ô∏è Structured Concurrency √© uma Feature Preview no JAVA 21\nOu seja, essa API pode sofrer altera√ß√µes ao longo do tempo, e para utiliz√°-la, precisamos explicitamente liberar seu uso.\nCom structured concurrency, criamos um escopo onde tarefas ir√£o rodar de maneira ass√≠ncrona com fork e join, e depois retornamos o resultado dessas opera√ß√µes\nPapos T√©cnicos para nerds O Fork-Join-Pool das Threads que as Virtuals usam Comentamos anteriormente como as Virtual Threads funcionavam em cima de threads reais: O scheduler de virtual threads √© um ‚Äòwork-stealing‚Äô¬†ForkJoinPool¬†que opera usando FIFO mode. O¬†paralelismo¬†padr√£o do scheduler √© a quantidade padr√£o de processadores (ou quantidade de threads dos seus processadores :) que sua m√°quina tem. D√° para alterar isso na prop:¬†jdk.virtualThreadScheduler.parallelism. Esse¬†ForkJoinPool¬†especificamente √© tunado de uma maneira diferente de um pool normal, que opera usando LIFO. Mais Refer√™ncias JEP 444: Virtual Threads\nState of Loom\nPerformance and scalability analysis of Java IO and NIO based server models, their implementation and comparison, Karabyn Petro. 2019\nVirtual threads: Are futures a thing of the past? - Java Magazine\nThe Ultimate Guide to Java Virtual Threads - Rock the JVM Blog/\nCompletableFuture with Virtual threads/\nJava Virtual Threads - Esse n√£o foi usado diretamente no texto, mas foi uma boa fonte de conhecimentos.\nhttps://www.youtube.com/watch?v=YQ6EpIk7KgY - Pelo engenheiro chefe respons√°vel pela concep√ß√£o da JEP das virtual threads.\n","wordCount":"3594","inLanguage":"pt","image":"https://kaue.cat/%3Cimage%20path/url%3E","datePublished":"2024-03-25T16:43:03Z","dateModified":"2024-03-25T16:43:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kaue.cat/posts/virtual-threads/"},"publisher":{"@type":"Organization","name":"Kaue Gatto","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kaue.cat accesskey=h title="Home (Alt + H)"><img src=https://kaue.cat/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://kaue.cat/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://kaue.cat/archives title=Arquivo><span>Arquivo</span></a></li><li><a href=https://kaue.cat/search/ title=Buscar><span>Buscar</span></a></li><li><a href=https://kaue.cat/series/ title=S√©ries><span>S√©ries</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kaue.cat>In√≠cio</a>&nbsp;¬ª&nbsp;<a href=https://kaue.cat/posts/>Posts</a></div><h1 class=post-title>[WIP] Virtual Threads em Java!<sup><span class=entry-isdraft>&nbsp;&nbsp;[draft]</span></sup></h1><div class=post-description>Vamos finalmente entender o Project Loom! Que adiciona as virutal threads no LTS da JDK 21</div><div class=post-meta><span title='2024-03-25 16:43:03 +0000 UTC'>mar√ßo 25, 2024</span>&nbsp;¬∑&nbsp;17 minutos&nbsp;¬∑&nbsp;3594 palavras&nbsp;¬∑&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/kauegatto/kauedotcat/content/posts/virtual-threads.md rel="noopener noreferrer" target=_blank>Sugerir Altera√ß√µes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Conte√∫do</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#programa√ß√£o-ass√≠ncrona-e-concorrente>Programa√ß√£o Ass√≠ncrona e Concorrente</a></li><li><a href=#execu√ß√£o-bloqueante>Execu√ß√£o Bloqueante</a></li></ul><ul><li><a href=#0-o-patinho-lento---one-request-per-thread>0. O Patinho lento - One Request Per Thread</a><ul><li><a href=#pontos-negativos>Pontos Negativos</a></li><li><a href=#pontos-positivos>Pontos Positivos</a></li><li><a href=#1-o-patinho-feio---processar-m√∫ltiplos-requests-em-uma-thread>1. O patinho feio - Processar m√∫ltiplos requests em uma Thread</a></li></ul></li><li><a href=#pontos-negativos-1>Pontos Negativos</a></li><li><a href=#2-o-patinho-que-existe---futures-e-callback-hell>2. O Patinho que Existe - Futures e Callback Hell</a><ul><li><a href=#3-o-patinho-bonito---construir-uma-thread-virtual-mais-leve-que-platform-threads>3. O Patinho bonito - Construir uma thread virtual, mais leve que Platform Threads.</a></li></ul></li></ul><ul><li><a href=#como-virtual-threads-funcionam>Como Virtual Threads funcionam</a></li><li><a href=#exemplos>Exemplos</a></li><li><a href=#habilitando-no-spring>Habilitando no Spring</a></li></ul><ul><li><a href=#o-fork-join-pool-das-threads-que-as-virtuals-usam>O Fork-Join-Pool das Threads que as Virtuals usam</a></li><li><a href=#mais>Mais</a></li></ul></nav></div></details></div><div class=post-content><h1 id=o-artigo>O Artigo<a hidden class=anchor aria-hidden=true href=#o-artigo>#</a></h1><p>Primeiro, vamos estabelecer objetivos desse artigo:</p><blockquote><p>‚úÖ Objetivos</p><p>Dar uma breve Introdu√ß√£o √† Programa√ß√£o Concorrente e Paralela
Explicar o hist√≥rico da programa√ß√£o concorrente no JAVA
Mostrar brevemente como o problema de throughput era resolvido no JAVA
Explicar Virtual Threads
Mostrar exemplos pr√°ticos do uso de Virtual Threads
Mostrar concorr√™ncia estruturada</p></blockquote><p>E&mldr;</p><blockquote><p>‚ùå N√£o Objetivos</p><p>N√£o √© objetivo explicar em detalhes mecanismos de programa√ß√£o concorrente & paralela, para isso, recomendo fortemente <a href=https://fidelissauro.dev/concorrencia-paralelismo/>esse artigo</a> do Matheus Fidelis
N√£o √© objetivo explicar em detalhes como a programa√ß√£o reativa e multithreaded √© feita em JAVA (sem ser com Virtual Threads)
Entrar em detalhe sobre assuntos espec√≠ficos do pacote <code>java.util.concurrent</code> - <code>Futures</code>, <code>Executors</code>, <code>Synchronizers</code>, Cole√ß√µes <em>Thread-Safe</em>, etc. Para isso, recomendo o<a href="https://www.youtube.com/watch?v=VKjFuX91G5Q&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW">curso gratuito de Java</a> do DevDojo</p></blockquote><h1 id=virtual-threads>Virtual Threads<a hidden class=anchor aria-hidden=true href=#virtual-threads>#</a></h1><p>Virtual Threads √© uma feature que est√° dispon√≠vel para uso em um LTS desde o Java 21, tamb√©m chamado de project loom, √© o projeto de integrar maneiras mais f√°ceis de escrever programas concorrentes e reativos em JAVA, a fim de misturar performance e usabilidade</p><blockquote><p>üîë <strong><a href=https://cr.openjdk.org/~rpressler/loom/loom/sol1_part1.html>Pontos Chave</a></strong></p><ul><li>A virtual thread is a¬†<code>Thread</code>¬†‚Äî in code, at runtime, in the debugger and in the profiler.</li><li>A virtual thread is not a wrapper around an OS thread, but a Java entity.</li><li>Creating a virtual thread is cheap ‚Äî have millions, and don‚Äôt pool them!</li><li>Blocking a virtual thread is cheap ‚Äî be synchronous!</li><li>No language changes are needed.</li><li>Pluggable schedulers offer the flexibility of asynchronous programming.</li></ul></blockquote><hr><blockquote><p>‚úÖ <strong><a href=https://openjdk.org/jeps/444>Objetivos</a></strong></p><ul><li>Enable server applications written in the simple thread-per-request style to scale with near-optimal hardware utilization.</li><li>Enable existing code that uses the java.lang.Thread API to adopt virtual threads with minimal change.</li><li>Enable easy troubleshooting, debugging, and profiling of virtual threads with existing JDK tools.</li></ul></blockquote><hr><blockquote><p>‚ùå <strong><a href=https://openjdk.org/jeps/444>N√£o Objetivos</a></strong></p><ul><li>It is not a goal to remove the traditional implementation of threads, or to silently migrate existing applications to use virtual threads.</li><li>It is not a goal to change the basic concurrency model of Java.</li><li>It is not a goal to offer a new data parallelism construct in either the Java language or the Java libraries. The¬†<a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/package-summary.html>Stream API</a>¬†remains the preferred way to process large data sets in parallel.</li></ul></blockquote><h1 id=conceitos>Conceitos<a hidden class=anchor aria-hidden=true href=#conceitos>#</a></h1><p>De maneira geral, usamos as virtual threads por um motivo: Aumentar o throughput (vaz√£o) da nossa aplica√ß√£o (n√£o velocidade, que est√° relacionado √† lat√™ncia. Por enquanto, a maneira mais comum √© uma: <a href=https://en.wikipedia.org/wiki/Reactive_programming>Programa√ß√£o Reativa</a>, vamos entender como a programa√ß√£o reativa era no passado, e como vamos implement√°-la com as virtual threads.</p><blockquote><p>üí° <strong>Throughput?</strong></p><p>Throughput diz respeito √† quantidade de elementos que voc√™ processa por uma medida de tempo (exemplo: Requests/Segundo em uma aplica√ß√£o HTTP, Mensagens Processadas por Segundo em um message broker).</p></blockquote><h2 id=programa√ß√£o-ass√≠ncrona-e-concorrente>Programa√ß√£o Ass√≠ncrona e Concorrente<a hidden class=anchor aria-hidden=true href=#programa√ß√£o-ass√≠ncrona-e-concorrente>#</a></h2><p>A maior parte do c√≥digo que escrevemos √© s√≠ncrono, isso significa que o c√≥digo vai ser executado imediatamente quando chegar naquela instru√ß√£o, o c√≥digo ass√≠ncrono √© um c√≥digo que vai ser executado, em algum momento no futuro, como uma promessa de execu√ß√£o.
C√≥digos ass√≠ncronos n√£o significam a mesma coisa que concorrentes, um forEach ass√≠nrono, por exemplo, roda na thread principal de um programa, um c√≥digo concorrente significa que ele vai ser executado em outra thread!</p><p>Podemos criar tarefas (<strong>Tasks</strong>) para rodarem em Threads, e para criarmos uma Thread, temos duas maneiras:</p><ol><li>Criar uma Thread a partir de seu construtor, e passar √† ela sua Task</li><li>Usar uma pool (piscina) de Threads e deixar com que o executor entregue a tarefa √† uma thread dispon√≠vel (se ela existir)<ol><li>Essa Abordagem √© muito comum pois Threads s√£o recursos limitados que n√£o s√£o leves de criar e destruir</li><li>Conex√µes de Banco de dados tamb√©m passam ficam em um &ldquo;Pool&rdquo; quando usamos frameworks como o Spring, a biblioteca que cuida da cria√ß√£o de um Pool de Conex√µes √© o <a href=https://github.com/brettwooldridge/HikariCP>Hikari</a></li></ol></li></ol><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/sf7z1q17wimc33mk40oz.png alt="Image description"></p><p>Nesse cen√°rio, vamos criar uma task, submet√™-la ao Executor, e receberemos uma promessa de execu√ß√£o, por esse ponto de vista, essa tarefa √© ass√≠ncrona pois ser√° executada no futuro, mas tamb√©m √© concorrente, pois ser√° executada em uma thread diferente. Aqui os conceitos se encontram, <a href=https://sci-hub.se/10.1145/2846680.2846687>mas n√£o s√£o a mesma coisa c√≥digo concorrente √© ass√≠ncrono, mas nem todo c√≥digo ass√≠ncrono √© concorrente!</a></p><h2 id=execu√ß√£o-bloqueante>Execu√ß√£o Bloqueante<a hidden class=anchor aria-hidden=true href=#execu√ß√£o-bloqueante>#</a></h2><p>Uma execu√ß√£o bloqueante significa que uma instru√ß√£o est√° sendo executada pela sua CPU (ou por um core dela) e que <strong>nenhuma outra instru√ß√£o ir√° ocorrer enquanto a anterior ainda estiver acontecendo, mesmo que sua CPU n√£o esteja sendo utilizada</strong>, normalmente em uma espera de I/O ou para entrar em um bloco de c√≥digo sincronizado.
Nesse cen√°rio ir√° ocorrer uma troca de contexto, um processo relativamente &ldquo;caro&rdquo; para sua CPU que basicamente desaloca o processo at√© que ele exija algo novamente da CPU, por sua vez, o c√≥digo n√£o bloqueante garante que sua CPU evite trocas de contextos e esteja sempre sendo utilizada.</p><h1 id=o-cen√°rio-atual---por-qu√™-usar-virtual-threads>O Cen√°rio Atual - Por qu√™ usar Virtual Threads?<a hidden class=anchor aria-hidden=true href=#o-cen√°rio-atual---por-qu√™-usar-virtual-threads>#</a></h1><p>Primeiro, analise o c√≥digo JAVA que faz uma chamada HTTP padr√£o para um servidor:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>URI</span> <span class=n>url</span> <span class=o>=</span> <span class=n>URI</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=s>&#34;https://mydata.com/data&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>HttpClient</span> <span class=n>client</span> <span class=o>=</span> <span class=n>HttpClient</span><span class=o>.</span><span class=na>newBuilder</span><span class=o>().</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>HttpRequest</span> <span class=n>request</span> <span class=o>=</span> <span class=n>HttpRequest</span><span class=o>.</span><span class=na>newBuilder</span><span class=o>(</span><span class=n>url</span><span class=o>).</span><span class=na>GET</span><span class=o>().</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>var</span> <span class=n>response</span> <span class=o>=</span> <span class=n>client</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>request</span><span class=o>,</span> <span class=n>HttpResponse</span><span class=o>.</span><span class=na>BodyHandlers</span><span class=o>.</span><span class=na>ofString</span><span class=o>());</span>
</span></span></code></pre></div><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/samjnv68urucu2x14r0p.png alt="Image description"></p><p>Aqui, podemos ver que nossa CPU s√≥ √© realmente utilizada de maneira eficiente durante 200 nano segundos, e fica ociosa a maior parte do tempo, esperando a resposta da chamada.</p><p>Como podemos arrumar isso?</p><h2 id=0-o-patinho-lento---one-request-per-thread>0. O Patinho lento - One Request Per Thread<a hidden class=anchor aria-hidden=true href=#0-o-patinho-lento---one-request-per-thread>#</a></h2><p>A primeira ideia √© irmos no aspecto concorrente, quando sua thread estiver esperando, o Task Scheduler vai remover ela do n√∫cleo que est√° rodando (Context Switching) e coloca outra thread no lugar, executar uma request em cada thread (One-Request-Per-Thread) √© a maneira convencional, que v√™m sido utilizada h√° bons anos.</p><p>Nesse cen√°rio, precisar√≠amos de 500 mil de threads - advindo da propor√ß√£o entre tempo ocioso e trabalhado. 100ms/200ns - (requests) nesse n√∫cleo para alcan√ßarmos o uso de 100% de CPU, garantindo que sua CPU n√£o fique ociosa. Isso definitivamente n√£o boa bom, n√©?
As threads no JAVA encapsula uma thread do Sistema Operacional, tamb√©m chamada de Platform Thread ou Kernel Thread, o problema √© que o custo de cria√ß√£o de cria√ß√£o de uma Thread em JAVA, √© o mesmo de criar uma Thread no SO, que √© relativamente caro</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hlf4nnyggvqgc1pe8lak.png alt="Image description">
<a href=https://app.pluralsight.com/library/courses/java-concurrent-programming-virtual-threads/table-of-contents>Fonte</a></p><p>Recursos caros como threads s√£o colocados em &ldquo;Pools&rdquo; para lidar com eles de maneiras mais eficientes:</p><blockquote><p>‚ùù ‚ùû</p><p>Developers sometimes use thread pools to limit concurrent access to limited resources. For example, if a service cannot handle more than 20 concurrent requests then making all requests to the service via tasks submitted to a thread pool of size 20 will ensure that. This idiom has become ubiquitous because the high cost of platform threads has made thread pools ubiquitous
Fonte: <a href=https://openjdk.org/jeps/444>https://openjdk.org/jeps/444</a></p></blockquote><p>Perfeito, mas voltando ao exemplo anterior, precisamos de 500.000 threads, quanto isso vai nos custar?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Mem√≥ria: 500.000Mb
</span></span><span class=line><span class=cl>Tempo de in√≠cio: 500 Segundos
</span></span></code></pre></div><p>Com isso, entendemos que o modelo One Request Per Thread n√£o √© mais vi√°vel:
O artigo <a href=https://repositorio-aberto.up.pt/bitstream/10216/98156/2/31853.pdf>Transformation patterns for a reactive application, de Bruno Miguel Mendon√ßa Maia</a> pontua como caracter√≠stica desses sistemas :</p><h3 id=pontos-negativos>Pontos Negativos<a hidden class=anchor aria-hidden=true href=#pontos-negativos>#</a></h3><p><strong>( ‚Äì ) Concurrency</strong>. Synchronous programming is not the best suited model for dealing with concurrency as the execution will start and block the current thread while waiting for the result.
<strong>( ‚Äì ) Throughput</strong>. While a thread waits for the expensive execution to return its result, the OS can exchange active threads to promote concurrency, <strong>but this has overhead costs and hinders throughput due to thread context switching and cache invalidation.</strong>
<strong>( ‚Äì ) Latency</strong>. Thread blocking on execution and the lower throughput due to the OS exchanging active threads and consequently cache invalidation leads to poorer latency.</p><h3 id=pontos-positivos>Pontos Positivos<a hidden class=anchor aria-hidden=true href=#pontos-positivos>#</a></h3><p><strong>(+) Ease of use</strong>. The synchronous sequential model and its typical imperative programming style provides a familiar thinking model that results in ease of use.
<strong>(+) Maintainability</strong>. Synchronous programming and its sequential execution model provides an easy to reason with concept that in turn increase maintainability. Furthermore, error handling in sequential execution is easier to tackle.</p><h3 id=1-o-patinho-feio---processar-m√∫ltiplos-requests-em-uma-thread>1. O patinho feio - Processar m√∫ltiplos requests em uma Thread<a hidden class=anchor aria-hidden=true href=#1-o-patinho-feio---processar-m√∫ltiplos-requests-em-uma-thread>#</a></h3><p><strong>Essa abordagem √© a abordagem Reativa</strong>. A abordagem reativa tem um princ√≠pio simples de dividir uma request em pequenas por√ß√µes e nenhuma por√ß√£o pode conter c√≥digo bloqueantes:</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/h6e1tzwgce02w18uu2hu.png alt="Image description"></p><p>Aqui dividimos as etapas como foi acordado anteriormente (exceto pelo fato de que a step2 pode bloquear a CPU)
Com isso, precisamos usar um framework reativo que permita que usemos essas lambdas (aqui o exemplo √© completableFuture, que faz a mesma coisa, mas usando a pool de threads, mas serve bem para explicar.):</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ilug3azfhsxzf8kbju2f.png alt="Image description"></p><p>Seu framework de execu√ß√£o ter√° a responsabilidade de conectar as lambdas para que o resultado delas seja passado para a pr√≥xima fun√ß√£o corretamente, √© seu trabalho n√£o escrever c√≥digo bloqueante nesse caso. <strong>Como seu framework vai ter pouqu√≠ssimas threads (talvez s√≥ uma por n√∫cleo), e muitas requests v√£o ser processadas em uma mesma thread, escrever c√≥digo bloqueante vai impactar MUITO sua performance.</strong></p><p>Nesse caso em espec√≠fico, a thread n√£o ser√° bloqueada pois CompletableFuture conhece o HttpRequest.send() e registra um callback, que ser√° executado quando a fun√ß√£o terminar de rodar.</p><h2 id=pontos-negativos-1>Pontos Negativos<a hidden class=anchor aria-hidden=true href=#pontos-negativos-1>#</a></h2><ul><li>C√≥digo dif√≠cil de ler</li><li>C√≥digo dif√≠cil de dar manuten√ß√£o</li><li>√â f√°cil de arruinar a performance com um peda√ßo de c√≥digo bloqueante.</li><li>Dif√≠cil de testar</li></ul><h2 id=2-o-patinho-que-existe---futures-e-callback-hell>2. O Patinho que Existe - Futures e Callback Hell<a hidden class=anchor aria-hidden=true href=#2-o-patinho-que-existe---futures-e-callback-hell>#</a></h2><p>Aqui, usamos ainda do One Request Per Thread, mas com estrat√©gias um pouco diferentes, usamos <code>Futures</code> para escrever c√≥digo paraleliz√°vel e concorrente, ganhando performance.</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/9u2kplp87s53uxo6t209.png alt="Image description">
Fonte <a href=https://blog.soaresdev.com/funcoes-callback-em-javascript/>https://blog.soaresdev.com/funcoes-callback-em-javascript/</a></p><p>O post <a href=https://blogs.oracle.com/javamagazine/post/virtual-threads-futures>Virtual threads: Are futures a thing of the past?</a>, na Java Magazine, retrata a hist√≥ria do c√≥digo concorrente em Java. L√°, √© retratado o uso de Futures para colocar suas Threads para rodar por√ß√µes bloqueantes em paralelo:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handleRequest</span><span class=o>(</span><span class=n>Socket</span> <span class=n>socket</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>request</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Request</span><span class=o>(</span><span class=n>socket</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureWeather</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Weather</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureRestaurants</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Restaurants</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureTheaters</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Theaters</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>new</span> <span class=n>Page</span><span class=o>(</span><span class=n>request</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>setWeather</span><span class=o>(</span><span class=n>futureWeather</span><span class=o>.</span><span class=na>join</span><span class=o>())</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>setRestaurants</span><span class=o>(</span><span class=n>futureRestaurants</span><span class=o>.</span><span class=na>join</span><span class=o>())</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>setTheaters</span><span class=o>(</span><span class=n>futureTheaters</span><span class=o>.</span><span class=na>join</span><span class=o>())</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>send</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>A ordem em que as tr√™s tasks esperam pelo resultado n√£o importa, a thread coloca os 3 Jobs para rodar, e depois bloqueia (espera) at√© que elas tenham terminado. Mas pera, &ldquo;e depois bloqueia (espera) at√© que elas tenham terminado&rdquo;&mldr; Exato, ainda podemos melhorar isso bastante, bloquear Threads tem um custo:</p><ol><li><a href=https://blogs.oracle.com/javamagazine/post/virtual-threads-futures>Esse blocking traz a possibilidade de deadlocks acontecerem</a>. Aqui, teremos uma pool para computar recursos e para lidar com requests.</li><li>Bloquear e desbloquear threads traz perda de performance. Claramente sua CPU n√£o vai ficar 2 Segundos esperando a sua resposta de I/O e vai colocar outra thread para trabalhar nesse meio termo, apesar disso, existe um custo n√£o s√≥ para fazer a troca de contexto, mas isso tamb√©m ir√° causar perda de dados em cache no processador, resultando em <em>cache misses</em> quando a thread estiver de volta.</li></ol><p>Podemos &ldquo;resolver&rdquo; isso usando callbacks!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Server</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kd>final</span> <span class=n>ServerSocket</span> <span class=n>server</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ServerSocket</span><span class=o>(</span><span class=n>port</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kd>final</span> <span class=n>ExecutorService</span> <span class=n>exec</span> <span class=o>=</span> <span class=n>Executors</span><span class=o>.</span><span class=na>newFixedThreadPool</span><span class=o>(</span><span class=mi>16</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=o>(!</span><span class=n>server</span><span class=o>.</span><span class=na>isClosed</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>var</span> <span class=n>socket</span> <span class=o>=</span> <span class=n>server</span><span class=o>.</span><span class=na>accept</span><span class=o>();</span>
</span></span><span class=line><span class=cl>      <span class=n>exec</span><span class=o>.</span><span class=na>execute</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>handleRequest</span><span class=o>(</span><span class=n>socket</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>handleRequest</span><span class=o>(</span><span class=n>Socket</span> <span class=n>socket</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>request</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Request</span><span class=o>(</span><span class=n>socket</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>futureWeather</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Weather</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>futureRestaurants</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Restaurants</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>futureTheaters</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Theaters</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>page</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Page</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>futureWeather</span><span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>weather</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>futureRestaurants</span><span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>restaurants</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=n>futureTheaters</span><span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>theaters</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>page</span><span class=o>.</span><span class=na>setWeather</span><span class=o>(</span><span class=n>weather</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=o>.</span><span class=na>setRestaurants</span><span class=o>(</span><span class=n>restaurants</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=o>.</span><span class=na>setTheaters</span><span class=o>(</span><span class=n>theaters</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=o>.</span><span class=na>send</span><span class=o>())));</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Future.thenAccept recebe como argumento um consumer, que ir√° consumir o resultado dessa future, a invoca√ß√£o de thenAccept s√≥ registra o c√≥digo para uma execu√ß√£o futura, ele n√£o espera o c√≥digo ser completado, registrando um callback.
Nesse cen√°rio, as threads nunca s√£o bloqueadas e uma √∫nica pool n√£o muito vasta pode ser usada. O c√≥digo tamb√©m est√° livre de deadlocks.</p><p>Callbacks s√£o dif√≠ceis de escrever e de debugar, voc√™ pode ter percebido que nesse simples evento, j√° temos 3 n√≠veis de aninhamento de c√≥digo, podemos melhorar isso usando outras features para lidar com futures de maneira n√£o bloqueantes, como usando <code>thenCombine</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handleRequest</span><span class=o>(</span><span class=n>Socket</span> <span class=n>socket</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>request</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Request</span><span class=o>(</span><span class=n>socket</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureWeather</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Weather</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureRestaurants</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Restaurants</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureTheaters</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>Theaters</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>),</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span><span class=k>new</span> <span class=n>Page</span><span class=o>(</span><span class=n>request</span><span class=o>))</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureWeather</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setWeather</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureRestaurants</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setRestaurants</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureTheaters</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setTheaters</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>Page</span><span class=o>::</span><span class=n>send</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Nesse cen√°rio, o √∫nico processamento que a thread que lida com as conex√µes performa √© a cria√ß√£o da p√°gina base, mas isso tamb√©m poderia ser ass√≠ncrono:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Server</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kd>final</span> <span class=n>ServerSocket</span> <span class=n>server</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ServerSocket</span><span class=o>(</span><span class=n>port</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kd>final</span> <span class=n>ExecutorService</span> <span class=n>exec</span> <span class=o>=</span> <span class=n>Executors</span><span class=o>.</span><span class=na>newFixedThreadPool</span><span class=o>(</span><span class=mi>16</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=o>(!</span><span class=n>server</span><span class=o>.</span><span class=na>isClosed</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>var</span> <span class=n>socket</span> <span class=o>=</span> <span class=n>server</span><span class=o>.</span><span class=na>accept</span><span class=o>();</span>
</span></span><span class=line><span class=cl>      <span class=n>handleRequest</span><span class=o>(</span><span class=n>socket</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>handleRequest</span><span class=o>(</span><span class=n>Socket</span> <span class=n>socket</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>futureRequest</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>Request</span><span class=o>(</span><span class=n>socket</span><span class=o>),</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>futureWeather</span> <span class=o>=</span> <span class=n>futureRequest</span><span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Weather</span><span class=o>::</span><span class=n>fetch</span><span class=o>,</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>futureRestaurants</span> <span class=o>=</span> <span class=n>futureRequest</span><span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Restaurants</span><span class=o>::</span><span class=n>fetch</span><span class=o>,</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>futureTheaters</span> <span class=o>=</span> <span class=n>futureRequest</span><span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Theaters</span><span class=o>::</span><span class=n>fetch</span><span class=o>,</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>futureRequest</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Page</span><span class=o>::</span><span class=k>new</span><span class=o>,</span> <span class=n>exec</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureWeather</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setWeather</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureRestaurants</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setRestaurants</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureTheaters</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setTheaters</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>Page</span><span class=o>::</span><span class=n>send</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=3-o-patinho-bonito---construir-uma-thread-virtual-mais-leve-que-platform-threads>3. O Patinho bonito - Construir uma thread virtual, mais leve que Platform Threads.<a hidden class=anchor aria-hidden=true href=#3-o-patinho-bonito---construir-uma-thread-virtual-mais-leve-que-platform-threads>#</a></h3><p>As virtual threads s√£o exatamente isso, conseguimos performance, simplicidade e boa capacidade de manuten√ß√£o evitando c√≥digos reativos e sem ter medo de c√≥digos bloqueantes.</p><blockquote><p>‚ùù ‚ùû Implica√ß√µes</p><p>Virtual threads are cheap and plentiful, and thus <strong>should never be pooled</strong>: A new virtual thread should be created for every application task. <strong>Most virtual threads will thus be short-lived and have shallow call stacks, performing as little as a single HTTP client call or a single JDBC query.</strong> Platform threads, by contrast, are heavyweight and expensive, and thus often must be pooled. They tend to be long-lived, have deep call stacks, and be shared among many tasks.
<strong>In summary, virtual threads preserve the reliable thread-per-request style that is harmonious with the design of the Java Platform while utilizing the available hardware optimally.</strong> Using virtual threads does not require learning new concepts, though it may require unlearning habits developed to cope with today&rsquo;s high cost of threads.
Virtual threads will not only help application developers ‚Äî they will also help framework designers provide easy-to-use APIs that are compatible with the platform&rsquo;s design without compromising on scalability.</p></blockquote><blockquote><p>‚ùó Refor√ßando!</p><p>N√£o crie pools de threads virtuais!</p></blockquote><h1 id=escrevendo-virtual-threads>Escrevendo Virtual Threads<a hidden class=anchor aria-hidden=true href=#escrevendo-virtual-threads>#</a></h1><p>As maneiras que podemos criar virtual s√£o simples:</p><ol><li>Via factory</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Thread</span> <span class=n>t3</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>ofVirtual</span><span class=o>()</span>  
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>name</span><span class=o>(</span><span class=s>&#34;Thread virtual!&#34;</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>start</span><span class=o>(</span><span class=n>task</span><span class=o>);</span>  
</span></span><span class=line><span class=cl><span class=n>t3</span><span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span></code></pre></div><ol start=2><li>Thread.startVirtualThread(task)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Thread</span> <span class=n>t4</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>startVirtualThread</span><span class=o>(</span><span class=n>task</span><span class=o>);</span>  
</span></span><span class=line><span class=cl><span class=n>t4</span><span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span></code></pre></div><ol start=3><li>Usando um executorService (com o m√©todo <code>newVirtualThreadPerTaskExecutor</code>):</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>execute</span><span class=o>(){</span>  
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>set</span> <span class=o>=</span> <span class=n>ConcurrentHashMap</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>newKeySet</span><span class=o>();</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=n>Runnable</span> <span class=n>task</span> <span class=o>=</span> <span class=o>()</span> <span class=o>-&gt;</span> <span class=n>set</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>toString</span><span class=o>());</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>N_TASKS</span> <span class=o>=</span> <span class=mi>500</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>(</span><span class=n>var</span> <span class=n>executorService</span> <span class=o>=</span> <span class=n>Executors</span><span class=o>.</span><span class=na>newVirtualThreadPerTaskExecutor</span><span class=o>())</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=n>N_TASKS</span><span class=o>;</span> <span class=n>index</span><span class=o>++)</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>            <span class=n>executorService</span><span class=o>.</span><span class=na>submit</span><span class=o>(</span><span class=n>task</span><span class=o>);</span>  
</span></span><span class=line><span class=cl>        <span class=o>}</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;# threads used = &#34;</span> <span class=o>+</span> <span class=n>set</span><span class=o>.</span><span class=na>size</span><span class=o>());</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=como-virtual-threads-funcionam>Como Virtual Threads funcionam<a hidden class=anchor aria-hidden=true href=#como-virtual-threads-funcionam>#</a></h2><p><strong>Uma virtual thread √© executada em cima de uma platform thread, que chamamos de Carrier Thread.</strong> Essas carrier threads s√£o organizadas em uma √∫nica <code>ForkJoinPool</code>, onde cada Platform (tamb√©m carrier) ter√° uma waitlist de virtual threads associadas √† ela.</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/amnt7rx42xq8p0t8ajlp.png alt="Image description"></p><p>Para evitar <strong><a href=https://en.wikipedia.org/wiki/Starvation_(computer_science)>Starvation</a></strong> das threads do Sistema Operacional, se uma waitlist de uma Platform Thread zerar, ela vai &ldquo;roubar&rdquo; tarefas de outras threads.
Com isso, percebemos que executar um &ldquo;runnable&rdquo; em uma virtual thread, na realidade roda ele em uma thread real, portanto, se formos executar uma opera√ß√£o completamente n√£o bloqueante, virtual threads s√£o mais caras, √© um overhead, se for o caso, rode-as diretamente na thread comum. <strong>Virtual Threads s√£o feitas para executar c√≥digos bloqueantes!</strong></p><blockquote><p>‚ö†Ô∏è Aviso</p><p><strong>Virtual Threads n√£o s√£o feitas para rodar opera√ß√µes em mem√≥ria!</strong></p></blockquote><p><strong>Quando opera√ß√µes bloqueantes rodam em virtual threads, elas se separam de sua Carrier Thread</strong>, usando &ldquo;yield&rdquo; para basicamente suspender a execu√ß√£o desse c√≥digo, <strong>liberando a thread principal para trabalhar com outras coisas</strong>, ent√£o essa virtual thread √© guardada na mem√≥ria principal (heap) e quando estiver pronta, √© colocada de novo na waitlist das threads principais, atrav√©s de um callback, mas isso tudo √© feito de maneira transparente!</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xr4ag965np9jk2o156nk.png alt="Image description"></p><p>Note que <code>Continuation.yield()</code> respons√°vel por garantir esse processo para que a thread principal n√£o seja bloqueada, precisa ser implementado em opera√ß√µes bloqueantes (isso j√° est√° feito).</p><p>Por exemplo, nessa linha de c√≥digo:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>response</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>future1</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>+</span> <span class=n>future2</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span></code></pre></div><p>Essas opera√ß√µes v√£o fazer com que a thread virutal monte e desmonte de sua <em>carrier thread</em> diversas vezes, provavelmente uma para cada call para <code>get()</code>e poss√≠velmente muitas outras vezes ao longo da execu√ß√£o de .send() gra√ßas √†s opera√ß√µes de I/O.</p><h2 id=exemplos>Exemplos<a hidden class=anchor aria-hidden=true href=#exemplos>#</a></h2><ol><li>Exemplo usando um executor que cria uma virtual thread para cada task bloqueante.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handle</span><span class=o>(</span><span class=n>Request</span> <span class=n>request</span><span class=o>,</span> <span class=n>Response</span> <span class=n>response</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>url1</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>url2</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>(</span><span class=n>var</span> <span class=n>executor</span> <span class=o>=</span> <span class=n>Executors</span><span class=o>.</span><span class=na>newVirtualThreadPerTaskExecutor</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>var</span> <span class=n>future1</span> <span class=o>=</span> <span class=n>executor</span><span class=o>.</span><span class=na>submit</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>fetchURL</span><span class=o>(</span><span class=n>url1</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>var</span> <span class=n>future2</span> <span class=o>=</span> <span class=n>executor</span><span class=o>.</span><span class=na>submit</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>fetchURL</span><span class=o>(</span><span class=n>url2</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>response</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>future1</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>+</span> <span class=n>future2</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>ExecutionException</span> <span class=o>|</span> <span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>response</span><span class=o>.</span><span class=na>fail</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=nf>fetchURL</span><span class=o>(</span><span class=n>URL</span> <span class=n>url</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>IOException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>(</span><span class=n>var</span> <span class=n>in</span> <span class=o>=</span> <span class=n>url</span><span class=o>.</span><span class=na>openStream</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>in</span><span class=o>.</span><span class=na>readAllBytes</span><span class=o>(),</span> <span class=n>StandardCharsets</span><span class=o>.</span><span class=na>UTF_8</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ol start=2><li>Mesmo procedimento usado no cap√≠tulo [[#2. O Patinho que Existe - Futures e Callback Hell]], mas usando virtual threads, que n√£o bloqueiam sua CPU!</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handleRequest</span><span class=o>(</span><span class=n>Socket</span> <span class=n>socket</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>request</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Request</span><span class=o>(</span><span class=n>socket</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureWeather</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Weather</span><span class=o>&gt;();</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureRestaurants</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Restaurants</span><span class=o>&gt;();</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureTheaters</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Theaters</span><span class=o>&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Thread</span><span class=o>.</span><span class=na>startVirtualThread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>futureWeather</span><span class=o>.</span><span class=na>complete</span><span class=o>(</span><span class=n>Weather</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>  <span class=n>Thread</span><span class=o>.</span><span class=na>startVirtualThread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>futureRestaurants</span><span class=o>.</span><span class=na>complete</span><span class=o>(</span><span class=n>Restaurants</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>  <span class=n>Thread</span><span class=o>.</span><span class=na>startVirtualThread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>futureTheaters</span><span class=o>.</span><span class=na>complete</span><span class=o>(</span><span class=n>Theaters</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>new</span> <span class=n>Page</span><span class=o>(</span><span class=n>request</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>setWeather</span><span class=o>(</span><span class=n>futureWeather</span><span class=o>.</span><span class=na>join</span><span class=o>())</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>setRestaurants</span><span class=o>(</span><span class=n>futureRestaurants</span><span class=o>.</span><span class=na>join</span><span class=o>())</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>setTheaters</span><span class=o>(</span><span class=n>futureTheaters</span><span class=o>.</span><span class=na>join</span><span class=o>())</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>send</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ol start=3><li>Parecido com o exemplo 2, mas com um aroma mais funcional (Considerando que o executorService prov√™ virtual threads.)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handleRequest</span><span class=o>(</span><span class=n>Socket</span> <span class=n>socket</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureRequest</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>Request</span><span class=o>(</span><span class=n>socket</span><span class=o>),</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureWeather</span> <span class=o>=</span> <span class=n>futureRequest</span><span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Weather</span><span class=o>::</span><span class=n>fetch</span><span class=o>,</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureRestaurants</span> <span class=o>=</span> <span class=n>futureRequest</span><span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Restaurants</span><span class=o>::</span><span class=n>fetch</span><span class=o>,</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>futureTheaters</span> <span class=o>=</span> <span class=n>futureRequest</span><span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Theaters</span><span class=o>::</span><span class=n>fetch</span><span class=o>,</span> <span class=n>exec</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>futureRequest</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Page</span><span class=o>::</span><span class=k>new</span><span class=o>,</span> <span class=n>exec</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureWeather</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setWeather</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureRestaurants</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setRestaurants</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenCombine</span><span class=o>(</span><span class=n>futureTheaters</span><span class=o>,</span> <span class=n>Page</span><span class=o>::</span><span class=n>setTheaters</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>Page</span><span class=o>::</span><span class=n>send</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ol start=4><li>Uma maneira imperativa, sem o uso de futures</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handleRequest</span><span class=o>(</span><span class=n>Socket</span> <span class=n>socket</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>request</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Request</span><span class=o>(</span><span class=n>socket</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>page</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Page</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>Thread</span> <span class=n>t1</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>startVirtualThread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>page</span><span class=o>.</span><span class=na>setWeather</span><span class=o>(</span><span class=n>Weather</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>    <span class=n>Thread</span> <span class=n>t2</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>startVirtualThread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>page</span><span class=o>.</span><span class=na>setRestaurants</span><span class=o>(</span><span class=n>Restaurants</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>    <span class=n>Thread</span> <span class=n>t3</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>startVirtualThread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>page</span><span class=o>.</span><span class=na>setTheaters</span><span class=o>(</span><span class=n>Theaters</span><span class=o>.</span><span class=na>fetch</span><span class=o>(</span><span class=n>request</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>t1</span><span class=o>.</span><span class=na>join</span><span class=o>();</span> <span class=n>t2</span><span class=o>.</span><span class=na>join</span><span class=o>();</span> <span class=n>t3</span><span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>page</span><span class=o>.</span><span class=na>send</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span></code></pre></div><p>Um ponto negativo aqui √© que a Pagina deve ser thread safe e deve ser constru√≠da antes do uso dos fetches pois todos esses m√©todos podem alterar e acessar esse recurso ao mesmo tempo.
Nesse caso, algum tipo de sincroniza√ß√£o ou lock ter√° de ocorrer (<em>pinning</em> nesse caso n√£o soa t√£o ruim pelo contexto que a cria√ß√£o/set de um objeto Page √© r√°pido)</p><p>Mais uma imagem de exemplo:</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qde67241rpbr6anzh21w.png alt="Image description"></p><blockquote><p>‚ö†Ô∏è Aviso</p><p>Como movemos coisas para a mem√≥ria e trazemos-as de volta, teremos problemas se estivermos usando ponteiros diretamente, mas voc√™ provavelmente n√£o vai fazer isso em JAVA.
Apesar disso, o bloco &ldquo;synchronized&rdquo;, faz isso, e quando isso acontece, a task executa de maneira bloqueante na platform thread, sem ir para a heap memory como as virtual threads fazem, ou seja, o <code>yield</code> n√£o acontece.
Chamamos isso de <strong>pinning</strong>, se voc√™ precisar usar &ldquo;synchronized&rdquo; em um bloco que leva uma quantidade consider√°vel de tempo (milisegundos), refatore-o para usar <strong>ReentrantLock</strong>, sen√£o voc√™ vai bloquear sua pequena quantidade de platform threads por bastante tempo :(</p><p>Adicionalmente, voc√™ pode observar com facilidade os <em>pinnings</em> de platform threads: New diagnostics assist in migrating code to virtual threads and in assessing whether you should replace a particular use of¬†<code>synchronized</code>¬†with a¬†<code>java.util.concurrent</code>¬†lock:</p><ul><li>A JDK Flight Recorder (JFR) event is emitted when a thread blocks while pinned (see¬†<a href=https://openjdk.org/jeps/444#JDK-Flight-Recorder-JFR>JDK Flight Recorder</a>).</li></ul></blockquote><h2 id=habilitando-no-spring>Habilitando no Spring<a hidden class=anchor aria-hidden=true href=#habilitando-no-spring>#</a></h2><p>Para habilitar virtual threads no SPRING, use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spring</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nt>threads</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nt>virtual</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c>## ou</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>spring.threads.virtual.enabled=true</span><span class=w>
</span></span></span></code></pre></div><p>Essa altera√ß√£o j√° far√° com que seu servidor deixe de trabalhar com o antigo cen√°rio de uma thread por request, poss√≠velmente melhorando sua performance, mesmo sem muitas altera√ß√µes (No caso, isso provavelmente s√≥ ocorrer√° se voc√™ j√° estiver recebendo uma quantidade de chamadas o suficiente para esgotar sua pool de platform threads, que √© 200).</p><h1 id=concorr√™ncia-estruturada-----feature-preview>Concorr√™ncia Estruturada - Feature Preview<a hidden class=anchor aria-hidden=true href=#concorr√™ncia-estruturada-----feature-preview>#</a></h1><p><a href=https://openjdk.org/jeps/453>A feature de Concorr√™ncia Estruturada</a>, tem como foco a escrita simples de c√≥digos
concorentes, usando o paradigma imperativo.</p><p>Em um passado distante, os c√≥digos que eram escritos eram recheados de &ldquo;go-tos&rdquo;, o que dificultava muito o custo de manuten√ß√£o pela dificuldade de entender o fluxo de execu√ß√£o do programa, estar dentro de um else n√£o significava necessariamente, que seu <em>if</em> falhou.</p><p>O problema disso √© que c√≥digo concorrente, em sua forma atual √© como usar um go-to, voc√™ n√£o consegue saber quem invocou a instru√ß√£o que est√° rodando na thread.</p><blockquote><p>‚úÖ <a href=https://bugs.openjdk.org/browse/JDK-8306641>Objetivos</a></p><ul><li>Promover um estilo de programa√ß√£o concorrente que pode evitar riscos comuns associados ao uso de c√≥digos concorrentes e paralelizado</li><li>Melhorar a observabilidade desse tipo de c√≥digo</li></ul></blockquote><blockquote><p>‚ùå N√£o-Objetivos</p><ul><li>Substituir maneiras de trabalhar com c√≥digo concorrente, como : <code>ExecutorService</code>¬†e¬†<code>Future</code>.</li><li>Definir a API definitiva de Concorr√™ncia Estruturada para a plataforma java, permitindo que outras formas surjam em novas bibliotecas ou releases da JDK</li><li>Definir maneiras de compartilhar <em>streams</em> de dados entre diferentes threads (exemplo: canais)</li><li>Substituir o mecanismo de interrup√ß√£o de thread j√° existente, mas pode ser no futuro.</li></ul></blockquote><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/9ojnardqehu1oj9glscf.png alt="Image description"></p><blockquote><p>‚ö°‚ò†Ô∏è Structured Concurrency √© uma Feature Preview no JAVA 21</p><p>Ou seja, essa API pode sofrer altera√ß√µes ao longo do tempo, e para utiliz√°-la, precisamos explicitamente liberar seu uso.</p></blockquote><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/inddyc6d27nraeaihpt7.png alt="Image description"></p><p>Com structured concurrency, criamos um escopo onde tarefas ir√£o rodar de maneira ass√≠ncrona com fork e join, e depois retornamos o resultado dessas opera√ß√µes</p><h1 id=papos-t√©cnicos-para-nerds>Papos T√©cnicos para nerds<a hidden class=anchor aria-hidden=true href=#papos-t√©cnicos-para-nerds>#</a></h1><h2 id=o-fork-join-pool-das-threads-que-as-virtuals-usam>O Fork-Join-Pool das Threads que as Virtuals usam<a hidden class=anchor aria-hidden=true href=#o-fork-join-pool-das-threads-que-as-virtuals-usam>#</a></h2><ul><li>Comentamos anteriormente como as Virtual Threads funcionavam em cima de threads reais: O scheduler de virtual threads √© um &lsquo;work-stealing&rsquo;¬†<a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html><code>ForkJoinPool</code></a>¬†que opera usando FIFO mode. O¬†<em>paralelismo</em>¬†padr√£o do scheduler √© a quantidade padr√£o de <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Runtime.html#availableProcessors()>processadores (ou quantidade de threads dos seus processadores :)</a> que sua m√°quina tem. D√° para alterar isso na prop:¬†<code>jdk.virtualThreadScheduler.parallelism</code>. Esse¬†<code>ForkJoinPool</code>¬†especificamente √© tunado de uma maneira diferente de um <a href=%5Bcommon%20pool%5D(https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#commonPool())>pool normal</a>, que opera usando LIFO.</li></ul><h2 id=mais>Mais<a hidden class=anchor aria-hidden=true href=#mais>#</a></h2><h1 id=refer√™ncias>Refer√™ncias<a hidden class=anchor aria-hidden=true href=#refer√™ncias>#</a></h1><p><a href=https://openjdk.org/jeps/444>JEP 444: Virtual Threads</a></p><p><a href=https://cr.openjdk.org/~rpressler/loom/loom/sol1_part1.html>State of Loom</a></p><p><a href="https://er.ucu.edu.ua/bitstream/handle/1/4470/Petro%20Karabyn.pdf?sequence=1">Performance and scalability analysis of Java IO and NIO based server models, their implementation and comparison, Karabyn Petro. 2019</a></p><p><a href=https://blogs.oracle.com/javamagazine/post/virtual-threads-futures>Virtual threads: Are futures a thing of the past? - Java Magazine</a></p><p><a href=https://blog.rockthejvm.com/ultimate-guide-to-java-virtual-threads>The Ultimate Guide to Java Virtual Threads - Rock the JVM Blog</a>/</p><p><a href=https://davidvlijmincx.com/posts/virtual-threads-with-completablefuture>CompletableFuture with Virtual threads</a>/</p><p><a href=https://medium.com/codex/java-virtual-threads-9fad6c362890>Java Virtual Threads</a> - Esse n√£o foi usado diretamente no texto, mas foi uma boa fonte de conhecimentos.</p><p><a href="https://www.youtube.com/watch?v=YQ6EpIk7KgY">https://www.youtube.com/watch?v=YQ6EpIk7KgY</a> - Pelo engenheiro chefe respons√°vel pela concep√ß√£o da JEP das virtual threads.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kaue.cat/tags/architecture/>ARCHITECTURE</a></li></ul><nav class=paginav><a class=prev href=https://kaue.cat/posts/integracao_testcontainers/><span class=title>¬´ P√°gina Anterior</span><br><span>TestContainers em Java: Testes de integra√ß√£o, reposit√≥rios e outras coisas!</span></a>
<a class=next href=https://kaue.cat/posts/database-replication/><span class=title>Pr√≥xima P√°gina ¬ª</span><br><span>[WIP] Replica√ß√£o de Banco de Dados</span></a></nav><div class=share-buttons><a>Compartilhar:</a><br><a target=_blank rel="noopener noreferrer" aria-label="share [WIP] Virtual Threads em Java! on x" href="https://x.com/intent/tweet/?text=%5bWIP%5d%20Virtual%20Threads%20em%20Java%21&url=https%3a%2f%2fkaue.cat%2fposts%2fvirtual-threads%2f&hashtags=ARCHITECTURE"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [WIP] Virtual Threads em Java! on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkaue.cat%2fposts%2fvirtual-threads%2f&title=%5bWIP%5d%20Virtual%20Threads%20em%20Java%21&summary=%5bWIP%5d%20Virtual%20Threads%20em%20Java%21&source=https%3a%2f%2fkaue.cat%2fposts%2fvirtual-threads%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [WIP] Virtual Threads em Java! on whatsapp" href="https://api.whatsapp.com/send?text=%5bWIP%5d%20Virtual%20Threads%20em%20Java%21%20-%20https%3a%2f%2fkaue.cat%2fposts%2fvirtual-threads%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//www-kaue-cat.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://kaue.cat>Kaue Gatto</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>