<!doctype html><html lang=pt dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares | Kaue Gatto</title><meta name=keywords content="EDA,ARCHITECTURE"><meta name=description content="Discussões gerais sobre arquitetura de software e meios de comunicação assíncronos."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="G-6MZTJBEG75"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=apple-touch-icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=mask-icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=pt href=https://kaue.cat/posts/eda/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6MZTJBEG75"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6MZTJBEG75",{anonymize_ip:!1})}</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-6MZTJBEG75","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6MZTJBEG75"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6MZTJBEG75",{anonymize_ip:!1})}</script><meta property="og:title" content="Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares"><meta property="og:description" content="Discussões gerais sobre arquitetura de software e meios de comunicação assíncronos."><meta property="og:type" content="article"><meta property="og:url" content="https://kaue.cat/posts/eda/"><meta property="og:image" content="https://kaue.cat/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-25T17:00:03+00:00"><meta property="article:modified_time" content="2025-04-25T17:00:03+00:00"><meta property="og:site_name" content="Kaue Gatto - Blog de Desenvolvimento"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kaue.cat/%3Cimage%20path/url%3E"><meta name=twitter:title content="Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares"><meta name=twitter:description content="Discussões gerais sobre arquitetura de software e meios de comunicação assíncronos."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kaue.cat/posts/"},{"@type":"ListItem","position":3,"name":"Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares","item":"https://kaue.cat/posts/eda/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares","name":"Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares","description":"Discussões gerais sobre arquitetura de software e meios de comunicação assíncronos.","keywords":["EDA","ARCHITECTURE"],"articleBody":"Arquitetura Orientada à Eventos, Microserviços e Monolitos Se você é desenvolvedor, é provável que já tenha ouvido falar sobre alguns conceitos comuns: SOLID, Acoplamento, Coesão, etc. Ao trabalhar com sistemas, conhecemos vantagens e desafios de diferentes tipos de arquiteturas à nível de software e solução, e entendemos como esses conceitos impactam a experiência, tempo e qualidade de um software.\nDesde a última década, Microserviços se tornaram um desses conceitos fundamentais, e suas vantagens e desvantagens começaram a ser mais palpáveis conforme a adoção desse tipo de arquitetura em sistemas reais. Sistemas distribuídos orientados à serviços são frequentemente vendidos como a solução ideal para todos os sistemas, enquanto isso, outros autores argumentam exatamente o contrário.\nSam Newmann, em seu livro “Construindo Microserviços”:\n“Infelizmente as pessoas passaram a ver os sistemas monolíticos como algo a ser evitado, isto é, algo que é inerentemente problemático. Uma arquitetura monolítica é uma opção, e uma opção válida. Eu poderia ir além e dizer que, em minha opinião, é a opção padrão sensata como estilo de arquitetura. Em outras palavras, estou procurando um motivo para ser convencido a utilizar microserviços, em vez de procurar um motivo para não usar”\nNo mesmo livro, outras arquiteturas são apresentadas, dentre elas o “Sistema Monolítico Modular”:\n“Para muitas empresas, o sistema monolítico modular pode ser uma excelente opção. Se as fronteiras dos módulos forem bem definidas, é possível ter um grau elevado de paralelismo nos trabalhos, ao mesmo tempo que os problemas da arquitetura de microserviços, mais distribuída, são evitados, pois há uma topologia muito mais simples para implantação. A Shopify é um ótimo exemplo de uma empresa que empregou essa técnica como uma alternativa à decomposição em microserviços e parece fnucionar muito bem para essa empresa”\nE então:\n“Um sistema distribuído é um sistema no qual a falha de um computador que você nem sabia que existia pode deixar seu prório computador inutilizável” - Leslie Lampert\nUm ponto que favorece bastante monolitos modularizados é a fácil capacidade de transformar módulos em serviços independentes (Microserviços), conforme a necessidade passe a existir. Aproveitando o baixo acoplamento entre os módulos, essa alteração se torna mais simples pois evita mexer em outras partes do sistema (No máximo nos adaptadores, responsáveis por se comunicar com esse novo serviço), visto que módulos agem como uma camada de isolamento.\nDe maneira geral, tendo a pensar que para organizações menores, prova de conceitos ou outros casos de uso, microserviços podem não ser o ideal para você, apesar disso, o foco do artigo é menos nesses dois tipos de arquitetura, e sim como ambos podem se beneficiar (ou não) de um sistema de comunicação assí baseado em eventos.\nIndependente se você está produzindo seu software em uma arquitetura realmente distribuída ou só modularizada, um ponto importante é garantir o baixo acomplamento e alta coesão desses módulos ou serviços.\nProtegendo seu código de acoplamento ruim Acoplamento sempre existirá, livros como “OOP e Solid para Ninjas” - de Mauricio Aniche e “Desbravando SOLID” - de Alexandre Aquiles enfatizam isso, mas principalmente, a diferença entre um acoplamento bom e ruim.\nDe maneira geral, acoplamento está intrinsecamente relacionado à coesão. Módulos com pouco acoplamento ruim são coesos, se elementos de código mudam em conjunto, eles devem se manter em conjunto, assim, quando algum desses elementos mudar, isso não exige alteração em múltiplas partes de seu sistema de uma vez, o que seria um forte indicativo que a coesão do seu sistema não é das melhores.\nUm exemplo: Regras de negócio de compras devem se manter no módulo e contexto de compras, se esse módulo começar a fazer suposições e uso de partes que não pertencem a esse módulo, isso com certeza não é um acoplamento tão bom. Agora suponha que você está fazendo um código que com certeza não tem perspectivas de mudar de ORM, criar camadas de abstração talvez seja um trabalho desnecessário, que pode inclusive poluir sua base de código.\nAo desenhar e modelar um Sistema Modular, queremos sempre que os módulos possuam baixo acoplamento entre si. Como isso fica no código? Uma forma interessante é, sempre que possível, expor contratos entre diferentes módulos, evitando uma comunicação direta. Outra maneira de evitar acoplamento é evitar que um módulo acesse recursos como banco de dados de outro sob responsabilidade de outro módulo - isso é frequentemente chamado de database-per-service- isso provavelmente traria para o módulo consumidor preocupações sobre tratamento de dados que deveriam estar no módulo que é o responsável pelo banco.\nModelos de Comunicação Síncronos e Assíncronos Aqui, entraremos em um debate sobre padrões de comunicação síncronos e assíncronos. Recomendo a leitura de dois excelentes posts do Matheus Fidelis que se aprofundam bem mais no tema: 2. https://fidelissauro.dev/padroes-de-comunicacao-sincronos/ 3. https://fidelissauro.dev/mensageria-eventos-streaming/\nSe tratando de Sistemas Modulares (sejam eles Microserviços ou não), um fator principal a ser levado em consideração é o acoplamento entre sistemas. A maneira com que eles se comunicam é um alto contribuínte nessa “métrica”:\nDe maneira geral, podemos dividir a comunicação em duas grandes categorias:\nPadrão síncrono - Request/response A chamada é feita por um cliente à um servidor, que eventualmente response a chamada pela mesma conexão, que se mantém aberta até a resposta acontecer. Note que aqui, o protocolo de comunicação é síncrono, mesmo que você crie alguma thread para processar esse tipo de mensagem de forma assíncrona, de maneira não bloqueante, isso não torna seu protocolo assíncrono, apenas seu processamento.\nPadrão de Comunicação Assíncrono A conexão entre quem pede a mensagem e o servidor não fica aberta esperando pela resposta em um tempo específico. Em algum momento, o servidor notifica o processamento da informação, normalmente o servidor faz a chamada proativa de chamar seus clientes via webhook ou simplesmente publica mensagens ou eventos sem se preocupar com quem e quando essa notificação será processada.\nBaseado em Mensagens - Aqui, sabemos qual nosso destinatário, normalmente enviamos comandos para outros serviços, como por exemplo: Atualize o Pedido x. (Figura 1). Existe uma variação assíncrona do modelo Request/Response comummente chamada de request-reply, onde a comunicação entre cliente/servidor se dá por meio de filas. Baseado em Eventos - Aqui, sua aplicação notifica eventos, coisas que aconteceram sob seu domínio. Se um pedido é pago, o serviço de pagamentos é responsável por enviar um evento de “Pagamento Concluído”, para que quem necessitar dessa informação, use-a. Aqui, a aplicação que propaga eventos não sabe quem irá consumi-los. (Figura 2) Costumamos chamar esses eventos de “Eventos de Integração”, pois se comunica com um “Bounded Context” diferente. Eventos normalmente são publicados em um sistema apartado, conhecido como Event Bus. Kafka é capaz de realizar a tarefa que um event bus realiza, RabbitMQ é um event bus, NATS.io também. *Figura 1. Extraído de .NET Microservices: Architecture for Containerized .NET Applications\nFigura 2. Extraído de .NET Microservices: Architecture for Containerized .NET Applications\nSincronismo Vs Assíncronismo [❗] NOTA Ao usar event bus externo com um monolito, fazer chamadas de rede é algo que deve ser evitado.\nO Caminho Síncrono Uma abordagem popular é implementar microsserviços baseados em HTTP (REST), devido à sua simplicidade. Uma abordagem baseada em HTTP é perfeitamente aceitável; a questão aqui está relacionada a como você a utiliza. Se você usa requisições e respostas HTTP apenas para interagir com seus microsserviços a partir de aplicações cliente ou de API Gateways, tudo bem. Mas se você criar longas cadeias de chamadas HTTP síncronas entre microsserviços, comunicando-se através de suas fronteiras como se os microsserviços fossem objetos em uma aplicação monolítica, sua aplicação eventualmente terá problemas. .NET Microservices: Architecture for Containerized .NET Applications pg.35\nO problema aqui se dá principalmente pela cadeia de serviços, se você se comunica de maneira síncrona com um serviço, ele provavelmente pode se comunicar de maneira síncrona com outro, em uma cadeia que pode ser infinita. Caso um desses sistemas falhe (e eventualmente vão falhar), você terá um problema.\nNa verdade, se seus microsserviços internos estão se comunicando criando cadeias de requisições HTTP como descrito, pode-se argumentar que você tem uma aplicação monolítica, mas baseada em HTTP entre processos em vez de mecanismos de comunicação intra-processo. .NET Microservices: Architecture for Containerized .NET Applications pg.35\nApesar disso, note que programar um serviço síncrono provê código muito mais simples de ser seguido pelo fluxo de execução natural, mais simples de ser desenvolvido, mas provavelmente menos resiliente. Caso queira forçar resiliência em padrões síncronos, com retries com backoff exponencial, circuit breakers, você acaba perdendo o que na minha opinião é a maior vantagem desse tipo de comunicação, a simplicidade.\nO Caminho Assíncrono Um código orientado à eventos possui uma boa quantidade de desafios associados - Consistência Eventual, Duplicação de mensagens, configuração de um serviço externo, mas oferece mais resiliência de forma que processos assíncronos podem ser feitos em algum momento no futuro, podendo deixar seu sistema parcialmente operante em casos de falha de alguns módulos. Note que isso aqui nos remete fortemente ao teorema CAP, onde temos que escolher entre Consistência e Disponibilidade. Não temos como manter nossa aplicação consistente se algum de nossos serviços caiu e precisamos nos comunicar com ele naquele momento.\nEm um sistema de e-commerce, você não quer que sua aplicação deixe de receber pedidos porquê o adquirente que está integrado caiu, ou porquê seu módulo de processamento está bugado, ao deixar esses eventos / pedidos guardados para reprocessamento no futuro, você evita qualquer perda financeira.\nEsse texto, como uma explicação para decisões e desafios acerca de um projeto pessoal, reflete minha decisão: Nesse projeto, fui com a arquitetura orientada à eventos principalmente por questões de aprendizado.\nConceitos Importantes de uma comunicação assíncrona Consistência Eventual Revisitando o exemplo anterior do E-commerce, onde você não quer deixar de registrar pedidos: Supondo que você registre os pedidos, mas por algum tipo de falha, não consiga enviar esse pedido para o Event Bus, isso significa que outras aplicações não receberão essa notificação que o pedido foi feito, o mesmo pode acontecer para qualquer domínio. Esse tipo de atraso na atualização de alguns dados é chamado de consistência eventual, o seu sistema, eventualmente, se tornará consistente. É importante avisar ao usuário como a consistência eventual pode o impactar, resultando que pedidos pagos não mostrem na hora, que dados salvos em seu perfil não apareçam imediatamente, etc.\n[❗] NOTA Em alguns lugares, é capaz que o termo *“Consistência Posterior”* seja empregado, pela semântica da palavra “Eventual” no português, que está mais próximo do “Ocasionalmente”. Quando falamos de consistência “eventual”, o sistema irá ficar consistente em algum momento no futuro.\nEntregas de Mensagens Sistemas que tratam envio de mensagens trabalham com diferentes tipos de garantia (que podem, ou não, ser configurados)\nAt Least Once Em sistemas que garantem entrega “At Least Once”, toda mensagem será entregue pelo menos uma vez ao consumidor. Isso significa que, em casos de falha ou timeout, o sistema pode reenviar a mesma mensagem, resultando em possíveis duplicatas. Esse modelo é especialmente útil quando perder uma mensagem é inaceitável - por exemplo, em sistemas de pagamento onde perder uma transação seria catastrófico. Em um sistema que tenta automaticamente se recuperar de falhas, a mesma mensagem poderia ser enviada múltiplas vezes. Graças à falhas de hardware e rede, o receptor deve ser capaz de implementar uma operação de processamento dessas mensagens que seja idempotente.\nAt Most Once Na garantia “At Most Once”, o sistema garante que uma mensagem será entregue no máximo uma vez. Se houver falha na entrega, a mensagem será perdida ao invés de ser reenviada. Esse modelo é útil em cenários onde duplicatas são mais problemáticas que perdas - como em sistemas de métricas ou logs, onde perder algumas mensagens é aceitável, mas duplicatas poderiam distorcer análises.\nDEDUP (Deduplicação) A deduplicação é uma estratégia fundamental, especialmente quando se usa “At Least Once”. Deduplicação é exatamente o que seu nome implica, removendo mensagens duplicadas de uma lista. Existem várias formas de implementar deduplicação, como identificadores únicos para uma mesma mensagem. Note que dedup garante Idempotência, onde diferentes requisições ou eventos com o mesmo conteúdo têm o mesmo resultado. Frequentemente sistemas garantem à você at-least-once, e ter idempotência é uma obrigatoriedade! A maior parte dos Event Buses possuem jeitos de lidar com a deduplicação de mensagens, mas também podemos fazer isso no código de destino do seu Microserviço (como verificar um messageId, ou se for um evento de pedido pago, o OrderId, visto que um pedido não pode ser pago mais de uma vez), talvez ter as validações em ambas as pontas seja a melhor opção.\nOutros Problemas Outros problemas que podem surgir ao lidar com sistemas assícronos são:\nOrdenação de mensagens, happens-before. Vídeo sobre o assunto. Transações distribuidas. Artigo sobre o assunto Garantindo a Publicação de Eventos e Consistência Ao publicar em um Event Bus, diversos problemas podem acontecer: Partições de rede, indisponibilidade do bus, queda do seu módulo. Todos esses cenários podem resultar na perda de mensagens. Outro problema é a alteração no estado interno de um objeto de domínio dentro do seu bounded context ser notificada de maneira errônea E se nossa mensagem nem for enviada? Outro ponto importante e frequente, que decidi dar um pouco mais de prioridade é: E se nossa mensagem nem for enviada ao event bus? e se ele cair?\nExistem alguns padrões e técnicas que nos permitem lidar com esse tipo de situação, uma delas é o Outbox, onde temos uma tabela em algum armazenamento persistente (normalmente um banco de dados) responsável por informar que um evento está pendente de ser enviado: Fazemos a alteração da nossa entidade de domínio em uma transação junto com a inserção do evento como “pendente”. Caso dê errado, nem nosso objeto nem o evento ficam inconsistentes\nCaso essa transação seja concluída, temos essa tabela, avisando que o evento deve ocorrer, e um outro serviço (normalmente chamado de worker) processará ele em caso de falhas, reenviando o evento.\nNote que com essa abordagem, você persiste apenas os eventos de integração de origem de cada microserviço. Outras abordagens (Como Event Sourcing - Que não irei abordar aqui), podem necessitar que você armazene mais eventos.\nExemplo real if (catalogItem == null) return NotFound(); bool raiseProductPriceChangedEvent = false; IntegrationEvent priceChangedEvent = null; if (catalogItem.Price != productToUpdate.Price) raiseProductPriceChangedEvent = true; if (raiseProductPriceChangedEvent) // Create event if price has changed { var oldPrice = catalogItem.Price; priceChangedEvent = new ProductPriceChangedIntegrationEvent(catalogItem.Id, productToUpdate.Price, oldPrice); } // Update current product catalogItem = productToUpdate; // Just save the updated product if the Product's Price hasn't changed. if (!raiseProductPriceChangedEvent) { await _catalogContext.SaveChangesAsync(); } else // Publish to event bus only if product price changed { // Achieving atomicity between original DB and the IntegrationEventLog // with a local transaction using (var transaction = _catalogContext.Database.BeginTransaction()) { _catalogContext.CatalogItems.Update(catalogItem); await _catalogContext.SaveChangesAsync(); await _integrationEventLogService.SaveEventAsync(priceChangedEvent); transaction.Commit(); } // Publish the integration event through the event bus _eventBus.Publish(priceChangedEvent); _integrationEventLogService.MarkEventAsPublishedAsync( priceChangedEvent); } return Ok(); } Ou seja:\nSe o Banco cair? Se essa operação for uma reação à um evento, a mensagem não será processada, para que possa ser processada em um momento futuro. Mantemos consistência e faremos o que for necessário, assim que possível. Se for fruto de uma chamada síncrona, podemos retornar um erro. De qualquer forma, o sistema não fica inconsistente. Se não conseguirmos publicar no event bus? Será publicado depois, teremos um log de que o evento está pronto para a publicação, nosso domínio interno estará atualizado, mas os outros não. Como trabalhamos com consistência eventual, é um cenário completamente ok! Se o banco cair na hora de salvarmos como enviado, enviaremos o evento novamente, por isso a importância da idempotência Esse tipo de cenário enfatiza como a alta resiliência de uma aplicação pode ser alcançada com mais facilidade usando um padrão de comunicação assíncrono por meio de eventos e mensagens\nConclusão A função deste texto é dar introdução à arquiteturas síncronas, assíncronas e orientadas à eventos, mostrando vantagens, desafios e técnicas comuns. Os posts posteriores darão mais ênfase na arquitetura à nivel dos módulos - Como desenhar os bounded contexts, quanto de informação colocar nos eventos de integração, etc.\nEspero que tenham gostado!\nReferências Construindo Microserviços - Sam newman OOP e SOLID para ninjas Desbravando SOLID EVENT STORMING - DOMAIN DRIVEN DESIGN, EVENT SOURCING E CQRS! - YouTube Message Driven Architecture to DECOUPLE a Monolith - YouTube Long live the Monolith! Monolithic Architecture != Big Ball of Mud - YouTube # .NET Microservices: Architecture for Containerized .NET Applications https://newsletter.simpleaws.dev/p/distributed-transactions-event-driven-architectures Mensageria, Eventos, Streaming e Arquitetura Assincrona Padrões de Comunicação Síncronos ","wordCount":"2717","inLanguage":"pt","image":"https://kaue.cat/%3Cimage%20path/url%3E","datePublished":"2025-04-25T17:00:03Z","dateModified":"2025-04-25T17:00:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kaue.cat/posts/eda/"},"publisher":{"@type":"Organization","name":"Kaue Gatto","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kaue.cat accesskey=h title="Home (Alt + H)"><img src=https://kaue.cat/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://kaue.cat/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://kaue.cat/archives title=Arquivo><span>Arquivo</span></a></li><li><a href=https://kaue.cat/search/ title=Buscar><span>Buscar</span></a></li><li><a href=https://kaue.cat/series/ title=Séries><span>Séries</span></a></li><li><a href=https://kaue.cat/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kaue.cat>Início</a>&nbsp;»&nbsp;<a href=https://kaue.cat/posts/>Posts</a></div><h1 class=post-title>Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares</h1><div class=post-description>Discussões gerais sobre arquitetura de software e meios de comunicação assíncronos.</div><div class=post-meta><span title='2025-04-25 17:00:03 +0000 UTC'>25 de abril , 2025</span>&nbsp;·&nbsp;13 minutos&nbsp;·&nbsp;2717 palavras&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/kauegatto/kauedotcat/content/posts/EDA.md rel="noopener noreferrer" target=_blank>Sugerir Alterações</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Conteúdo</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#modelos-de-comunicação-síncronos-e-assíncronos>Modelos de Comunicação Síncronos e Assíncronos</a></li><li><a href=#sincronismo-vs-assíncronismo>Sincronismo Vs Assíncronismo</a><ul><li><a href=#o-caminho-síncrono>O Caminho Síncrono</a></li><li><a href=#o-caminho-assíncrono>O Caminho Assíncrono</a></li></ul></li></ul><ul><li><a href=#consistência-eventual>Consistência Eventual</a></li><li><a href=#entregas-de-mensagens>Entregas de Mensagens</a><ul><li><a href=#at-least-once>At Least Once</a></li><li><a href=#at-most-once>At Most Once</a></li><li><a href=#dedup-deduplicação>DEDUP (Deduplicação)</a></li></ul></li><li><a href=#outros-problemas>Outros Problemas</a></li></ul><ul><li><a href=#e-se-nossa-mensagem-nem-for-enviada>E se nossa mensagem nem for enviada?</a><ul><li><a href=#exemplo-real>Exemplo real</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=arquitetura-orientada-à-eventos-microserviços-e-monolitos>Arquitetura Orientada à Eventos, Microserviços e Monolitos<a hidden class=anchor aria-hidden=true href=#arquitetura-orientada-à-eventos-microserviços-e-monolitos>#</a></h1><p>Se você é desenvolvedor, é provável que já tenha ouvido falar sobre alguns conceitos comuns: <strong>SOLID</strong>, <strong>Acoplamento</strong>, <strong>Coesão</strong>, etc. Ao trabalhar com sistemas, conhecemos vantagens e desafios de diferentes tipos de arquiteturas à nível de software e solução, e entendemos como esses conceitos impactam a experiência, tempo e qualidade de um software.</p><p>Desde a última década, <strong>Microserviços</strong> se tornaram um desses conceitos fundamentais, e suas vantagens e desvantagens começaram a ser mais palpáveis conforme a adoção desse tipo de arquitetura em sistemas reais. Sistemas distribuídos orientados à serviços são frequentemente vendidos como a solução ideal para todos os sistemas, enquanto isso, outros autores argumentam exatamente o contrário.</p><p>Sam Newmann, em seu livro &ldquo;Construindo Microserviços&rdquo;:</p><blockquote><p>&ldquo;Infelizmente as pessoas passaram a ver os sistemas monolíticos como algo a ser evitado, isto é, algo que é inerentemente problemático. Uma arquitetura monolítica é uma opção, e uma opção válida. Eu poderia ir além e dizer que, em minha opinião, é a opção padrão sensata como estilo de arquitetura.
Em outras palavras, estou procurando um motivo para ser convencido a utilizar microserviços, em vez de procurar um motivo para não usar&rdquo;</p></blockquote><p>No mesmo livro, outras arquiteturas são apresentadas, dentre elas o &ldquo;Sistema Monolítico Modular&rdquo;:</p><blockquote><p>&ldquo;Para muitas empresas, o sistema monolítico modular pode ser uma excelente opção. Se as fronteiras dos módulos forem bem definidas, é possível ter um grau elevado de paralelismo nos trabalhos, ao mesmo tempo que os problemas da arquitetura de microserviços, mais distribuída, são evitados, pois há uma topologia muito mais simples para implantação. A Shopify é um ótimo exemplo de uma empresa que empregou essa técnica como uma alternativa à decomposição em microserviços e parece fnucionar muito bem para essa empresa&rdquo;</p></blockquote><p>E então:</p><blockquote><p>&ldquo;Um sistema distribuído é um sistema no qual a falha de um computador que você nem sabia que existia pode deixar seu prório computador inutilizável&rdquo; - Leslie Lampert</p></blockquote><p>Um ponto que favorece bastante monolitos modularizados é a fácil capacidade de transformar módulos em serviços independentes (Microserviços), conforme a necessidade passe a existir. Aproveitando o baixo acoplamento entre os módulos, essa alteração se torna mais simples pois evita mexer em outras partes do sistema (No máximo nos <em>adaptadores</em>, responsáveis por se comunicar com esse novo serviço), visto que módulos agem como uma camada de isolamento.</p><p>De maneira geral, tendo a pensar que para organizações menores, prova de conceitos ou outros casos de uso, microserviços podem não ser o ideal para você, apesar disso, o foco do artigo é menos nesses dois tipos de arquitetura, e sim como ambos podem se beneficiar (ou não) de um sistema de comunicação assí baseado em eventos.</p><p>Independente se você está produzindo seu software em uma arquitetura realmente distribuída ou só modularizada, um ponto importante é garantir o baixo acomplamento e alta coesão desses módulos ou serviços.</p><h1 id=protegendo-seu-código-de-acoplamento-ruim>Protegendo seu código de acoplamento ruim<a hidden class=anchor aria-hidden=true href=#protegendo-seu-código-de-acoplamento-ruim>#</a></h1><p>Acoplamento sempre existirá, livros como <em><strong>&ldquo;OOP e Solid para Ninjas&rdquo;</strong></em> - de Mauricio Aniche e <em><strong>&ldquo;Desbravando SOLID&rdquo;</strong></em> - de Alexandre Aquiles enfatizam isso, mas principalmente, a diferença entre um acoplamento bom e ruim.</p><p>De maneira geral, acoplamento está intrinsecamente relacionado à coesão. Módulos com pouco acoplamento ruim são coesos, se elementos de código mudam em conjunto, eles devem se manter em conjunto, assim, quando algum desses elementos mudar, isso não exige alteração em múltiplas partes de seu sistema de uma vez, o que seria um forte indicativo que a coesão do seu sistema não é das melhores.</p><p>Um exemplo: Regras de negócio de compras devem se manter no módulo e <strong>contexto</strong> de compras, se esse módulo começar a fazer suposições e uso de partes que não pertencem a esse módulo, isso com certeza não é um acoplamento tão bom. Agora suponha que você está fazendo um código que <strong>com certeza</strong> não tem perspectivas de mudar de ORM, criar camadas de abstração talvez seja um trabalho desnecessário, que pode inclusive poluir sua base de código.</p><p>Ao desenhar e modelar um Sistema Modular, queremos sempre que os módulos possuam <strong>baixo acoplamento</strong> entre si. Como isso fica no código? Uma forma interessante é, sempre que possível, expor <strong>contratos</strong> entre diferentes módulos, evitando uma comunicação direta. Outra maneira de evitar acoplamento é evitar que um módulo acesse recursos como banco de dados de outro sob responsabilidade de outro módulo - isso é frequentemente chamado de <em>database-per-service</em>- isso provavelmente traria para o módulo consumidor preocupações sobre tratamento de dados que deveriam estar no módulo que é o responsável pelo banco.</p><h2 id=modelos-de-comunicação-síncronos-e-assíncronos>Modelos de Comunicação Síncronos e Assíncronos<a hidden class=anchor aria-hidden=true href=#modelos-de-comunicação-síncronos-e-assíncronos>#</a></h2><p>Aqui, entraremos em um debate sobre <strong>padrões de comunicação</strong> síncronos e assíncronos.
Recomendo a leitura de dois excelentes posts do Matheus Fidelis que se aprofundam bem mais no tema:
2. <a href=https://fidelissauro.dev/padroes-de-comunicacao-sincronos/>https://fidelissauro.dev/padroes-de-comunicacao-sincronos/</a>
3. <a href=https://fidelissauro.dev/mensageria-eventos-streaming/>https://fidelissauro.dev/mensageria-eventos-streaming/</a></p><p>Se tratando de Sistemas Modulares (sejam eles Microserviços ou não), um fator principal a ser levado em consideração é o acoplamento entre sistemas. A maneira com que eles se comunicam é um alto contribuínte nessa &ldquo;métrica&rdquo;:</p><p>De maneira geral, podemos dividir a comunicação em duas grandes categorias:</p><ol><li><p>Padrão síncrono - Request/response
A chamada é feita por um cliente à um servidor, que eventualmente response a chamada pela mesma conexão, que se mantém aberta até a resposta acontecer.
Note que aqui, o protocolo de comunicação é síncrono, mesmo que você crie alguma thread para processar esse tipo de mensagem de forma assíncrona, de maneira não bloqueante, <strong>isso não torna seu protocolo assíncrono, apenas seu processamento.</strong></p></li><li><p>Padrão de Comunicação Assíncrono
A conexão entre quem pede a mensagem e o servidor não fica aberta esperando pela resposta em um tempo específico. Em algum momento, o servidor notifica o processamento da informação, normalmente o servidor faz a chamada proativa de chamar seus clientes via webhook ou simplesmente publica mensagens ou eventos sem se preocupar com quem e quando essa notificação será processada.</p><ol><li>Baseado em Mensagens - Aqui, sabemos qual nosso destinatário, normalmente enviamos <strong>comandos</strong> para outros serviços, como por exemplo: Atualize o Pedido x. (Figura 1). Existe uma variação assíncrona do modelo Request/Response comummente chamada de request-reply, onde a comunicação entre cliente/servidor se dá por meio de filas.</li><li>Baseado em Eventos - Aqui, sua aplicação notifica eventos, coisas que aconteceram sob seu domínio. Se um pedido é pago, o serviço de pagamentos é responsável por enviar um evento de &ldquo;Pagamento Concluído&rdquo;, para que <strong>quem necessitar</strong> dessa informação, use-a. Aqui, a aplicação que propaga eventos não sabe quem irá consumi-los. (Figura 2)<ol><li>Costumamos chamar esses eventos de <em>&ldquo;Eventos de Integração&rdquo;</em>, pois se comunica com um <em>&ldquo;Bounded Context&rdquo;</em> diferente.</li><li>Eventos normalmente são publicados em um sistema apartado, conhecido como Event Bus. Kafka é capaz de realizar a tarefa que um event bus realiza, RabbitMQ é um event bus, NATS.io também.</li></ol></li></ol></li></ol><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/tleok3v9g8d5j30u5r8g.png alt="Image description">
*Figura 1. Extraído de <a href=https://learn.microsoft.com/en-us/dotnet/architecture/microservices/>.NET Microservices: Architecture for Containerized .NET Applications</a></p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/go6ujat3mpsmewd35kq4.png alt="Image description">
Figura 2. Extraído de <a href=https://learn.microsoft.com/en-us/dotnet/architecture/microservices/>.NET Microservices: Architecture for Containerized .NET Applications</a></p><h2 id=sincronismo-vs-assíncronismo>Sincronismo Vs Assíncronismo<a hidden class=anchor aria-hidden=true href=#sincronismo-vs-assíncronismo>#</a></h2><blockquote><p>[❗] NOTA
Ao usar event bus externo com um monolito, fazer chamadas de rede é algo que deve ser evitado.</p></blockquote><h3 id=o-caminho-síncrono>O Caminho Síncrono<a hidden class=anchor aria-hidden=true href=#o-caminho-síncrono>#</a></h3><blockquote><p>Uma abordagem popular é implementar microsserviços baseados em HTTP (REST), devido à sua simplicidade. Uma abordagem baseada em HTTP é perfeitamente aceitável; a questão aqui está relacionada a como você a utiliza. Se você usa requisições e respostas HTTP apenas para interagir com seus microsserviços a partir de aplicações cliente ou de API Gateways, tudo bem. Mas se você criar longas cadeias de chamadas HTTP síncronas entre microsserviços, comunicando-se através de suas fronteiras como se os microsserviços fossem objetos em uma aplicação monolítica, sua aplicação eventualmente terá problemas.
<a href=https://learn.microsoft.com/en-us/dotnet/architecture/microservices/>.NET Microservices: Architecture for Containerized .NET Applications</a> pg.35</p></blockquote><p>O problema aqui se dá principalmente pela cadeia de serviços, se você se comunica de maneira síncrona com um serviço, ele provavelmente pode se comunicar de maneira síncrona com outro, em uma cadeia que pode ser infinita. Caso um desses sistemas falhe (e eventualmente vão falhar), você terá um problema.</p><blockquote><p>Na verdade, se seus microsserviços internos estão se comunicando criando cadeias de requisições HTTP como descrito, pode-se argumentar que você tem uma aplicação monolítica, mas baseada em HTTP entre processos em vez de mecanismos de comunicação intra-processo.
<a href=https://learn.microsoft.com/en-us/dotnet/architecture/microservices/>.NET Microservices: Architecture for Containerized .NET Applications</a> pg.35</p></blockquote><p>Apesar disso, note que programar um serviço síncrono provê código muito mais simples de ser seguido pelo fluxo de execução natural, mais simples de ser desenvolvido, mas provavelmente menos resiliente. Caso queira forçar resiliência em padrões síncronos, com retries com backoff exponencial, circuit breakers, você acaba perdendo o que <em>na minha opinião</em> é a maior vantagem desse tipo de comunicação, a simplicidade.</p><h3 id=o-caminho-assíncrono>O Caminho Assíncrono<a hidden class=anchor aria-hidden=true href=#o-caminho-assíncrono>#</a></h3><p>Um código orientado à eventos possui uma boa quantidade de desafios associados - Consistência Eventual, Duplicação de mensagens, configuração de um serviço externo, <strong>mas oferece mais resiliência de forma que processos assíncronos podem ser feitos em algum momento no futuro, podendo deixar seu sistema <em>parcialmente</em> operante em casos de falha de alguns módulos.</strong> Note que isso aqui nos remete fortemente ao teorema CAP, onde temos que escolher entre <em>Consistência</em> e <em>Disponibilidade</em>. Não temos como manter nossa aplicação consistente se algum de nossos serviços caiu e precisamos nos comunicar com ele naquele momento.</p><p><strong>Em um sistema de e-commerce, você não quer que sua aplicação deixe de receber pedidos porquê o adquirente que está integrado caiu, ou porquê seu módulo de processamento está bugado, ao deixar esses eventos / pedidos guardados para reprocessamento no futuro, você evita qualquer perda financeira.</strong></p><p>Esse texto, como uma explicação para decisões e desafios acerca de um projeto pessoal, reflete minha decisão: Nesse projeto, fui com a arquitetura orientada à eventos principalmente por questões de aprendizado.</p><h1 id=conceitos-importantes-de-uma-comunicação-assíncrona>Conceitos Importantes de uma comunicação assíncrona<a hidden class=anchor aria-hidden=true href=#conceitos-importantes-de-uma-comunicação-assíncrona>#</a></h1><h2 id=consistência-eventual>Consistência Eventual<a hidden class=anchor aria-hidden=true href=#consistência-eventual>#</a></h2><p>Revisitando o exemplo anterior do E-commerce, onde você não quer deixar de registrar pedidos:
Supondo que você registre os pedidos, mas por algum tipo de falha, não consiga enviar esse pedido para o <em>Event Bus</em>, isso significa que outras aplicações não receberão essa notificação que o pedido foi feito, o mesmo pode acontecer para qualquer domínio. <strong>Esse tipo de atraso na atualização de alguns dados é chamado de consistência eventual, o seu sistema, eventualmente, se tornará consistente.</strong> É importante avisar ao usuário como a consistência eventual pode o impactar, resultando que pedidos pagos não mostrem na hora, que dados salvos em seu perfil não apareçam imediatamente, etc.</p><blockquote><p>[❗] NOTA
Em alguns lugares, é capaz que o termo *<a href=https://pt.wikipedia.org/wiki/Consist%C3%AAncia_posterior>&ldquo;Consistência Posterior&rdquo;*</a> seja empregado, pela semântica da palavra &ldquo;Eventual&rdquo; no português, que está mais próximo do &ldquo;Ocasionalmente&rdquo;. Quando falamos de consistência &ldquo;<em>eventual</em>&rdquo;, o sistema <strong>irá</strong> ficar consistente em algum momento no futuro.</p></blockquote><h2 id=entregas-de-mensagens>Entregas de Mensagens<a hidden class=anchor aria-hidden=true href=#entregas-de-mensagens>#</a></h2><p>Sistemas que tratam envio de mensagens trabalham com diferentes tipos de garantia (que podem, ou não, ser configurados)</p><h3 id=at-least-once>At Least Once<a hidden class=anchor aria-hidden=true href=#at-least-once>#</a></h3><p>Em sistemas que garantem entrega &ldquo;At Least Once&rdquo;, toda mensagem será entregue pelo menos uma vez ao consumidor. Isso significa que, em casos de falha ou timeout, o sistema pode reenviar a mesma mensagem, resultando em possíveis duplicatas. Esse modelo é especialmente útil quando perder uma mensagem é inaceitável - por exemplo, em sistemas de pagamento onde perder uma transação seria catastrófico.
Em um sistema que tenta automaticamente se recuperar de falhas, a mesma mensagem poderia ser enviada múltiplas vezes. Graças à falhas de hardware e rede, o receptor deve ser capaz de implementar uma operação de processamento dessas mensagens que seja idempotente.</p><h3 id=at-most-once>At Most Once<a hidden class=anchor aria-hidden=true href=#at-most-once>#</a></h3><p>Na garantia &ldquo;At Most Once&rdquo;, o sistema garante que uma mensagem será entregue no máximo uma vez. Se houver falha na entrega, a mensagem será perdida ao invés de ser reenviada. Esse modelo é útil em cenários onde duplicatas são mais problemáticas que perdas - como em sistemas de métricas ou logs, onde perder algumas mensagens é aceitável, mas duplicatas poderiam distorcer análises.</p><h3 id=dedup-deduplicação>DEDUP (Deduplicação)<a hidden class=anchor aria-hidden=true href=#dedup-deduplicação>#</a></h3><p>A deduplicação é uma estratégia fundamental, especialmente quando se usa &ldquo;At Least Once&rdquo;. Deduplicação é exatamente o que seu nome implica, removendo mensagens duplicadas de uma lista.
Existem várias formas de implementar deduplicação, como identificadores únicos para uma mesma mensagem. Note que dedup garante Idempotência, onde diferentes requisições ou eventos com o mesmo conteúdo têm o mesmo resultado. Frequentemente sistemas garantem à você at-least-once, e ter idempotência é uma obrigatoriedade!
A maior parte dos <em>Event Buses</em> possuem jeitos de lidar com a deduplicação de mensagens, mas também podemos fazer isso no código de destino do seu Microserviço (como verificar um messageId, ou se for um evento de pedido pago, o OrderId, visto que um pedido não pode ser pago mais de uma vez), talvez ter as validações em ambas as pontas seja a melhor opção.</p><h2 id=outros-problemas>Outros Problemas<a hidden class=anchor aria-hidden=true href=#outros-problemas>#</a></h2><p>Outros problemas que podem surgir ao lidar com sistemas assícronos são:</p><ol><li>Ordenação de mensagens, happens-before. <a href="https://www.youtube.com/watch?v=OKHIdpOAxto">Vídeo sobre o assunto</a>.</li><li>Transações distribuidas. <a href=https://newsletter.simpleaws.dev/p/distributed-transactions-event-driven-architectures>Artigo sobre o assunto</a></li></ol><h1 id=garantindo-a-publicação-de-eventos-e-consistência>Garantindo a Publicação de Eventos e Consistência<a hidden class=anchor aria-hidden=true href=#garantindo-a-publicação-de-eventos-e-consistência>#</a></h1><ul><li>Ao publicar em um Event Bus, diversos problemas podem acontecer: Partições de rede, indisponibilidade do bus, queda do seu módulo. Todos esses cenários podem resultar na perda de mensagens.</li><li>Outro problema é a alteração no estado interno de um objeto de domínio dentro do seu bounded context ser notificada de maneira errônea</li></ul><h2 id=e-se-nossa-mensagem-nem-for-enviada>E se nossa mensagem nem for enviada?<a hidden class=anchor aria-hidden=true href=#e-se-nossa-mensagem-nem-for-enviada>#</a></h2><p>Outro ponto importante e frequente, que decidi dar um pouco mais de prioridade é: E se nossa mensagem nem for enviada ao event bus? e se ele cair?</p><p>Existem alguns padrões e técnicas que nos permitem lidar com esse tipo de situação, uma delas é o <strong>Outbox</strong>, onde temos uma <strong>tabela em algum armazenamento persistente (normalmente um banco de dados)</strong> responsável por informar que um evento está pendente de ser enviado:
Fazemos a alteração da nossa entidade de domínio em uma transação junto com a inserção do evento como &ldquo;pendente&rdquo;. Caso dê errado, nem nosso objeto nem o evento ficam inconsistentes</p><p>Caso essa transação seja concluída, temos essa tabela, avisando que o evento deve ocorrer, e um outro serviço (normalmente chamado de <em>worker</em>) processará ele em caso de falhas, reenviando o evento.</p><p>Note que com essa abordagem, você persiste apenas os eventos de <strong>integração</strong> de origem de cada microserviço. Outras abordagens (Como Event Sourcing - Que não irei abordar aqui), podem necessitar que você armazene mais eventos.</p><h3 id=exemplo-real>Exemplo real<a hidden class=anchor aria-hidden=true href=#exemplo-real>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>catalogItem</span> <span class=p>==</span> <span class=k>null</span><span class=p>)</span> <span class=k>return</span> <span class=n>NotFound</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>raiseProductPriceChangedEvent</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>IntegrationEvent</span> <span class=n>priceChangedEvent</span> <span class=p>=</span> <span class=k>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>catalogItem</span><span class=p>.</span><span class=n>Price</span> <span class=p>!=</span> <span class=n>productToUpdate</span><span class=p>.</span><span class=n>Price</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>raiseProductPriceChangedEvent</span> <span class=p>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>raiseProductPriceChangedEvent</span><span class=p>)</span> <span class=c1>// Create event if price has changed</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>var</span> <span class=n>oldPrice</span> <span class=p>=</span> <span class=n>catalogItem</span><span class=p>.</span><span class=n>Price</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>priceChangedEvent</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ProductPriceChangedIntegrationEvent</span><span class=p>(</span><span class=n>catalogItem</span><span class=p>.</span><span class=n>Id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>productToUpdate</span><span class=p>.</span><span class=n>Price</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>oldPrice</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Update current product</span>
</span></span><span class=line><span class=cl><span class=n>catalogItem</span> <span class=p>=</span> <span class=n>productToUpdate</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Just save the updated product if the Product&#39;s Price hasn&#39;t changed.</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(!</span><span class=n>raiseProductPriceChangedEvent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>await</span> <span class=n>_catalogContext</span><span class=p>.</span><span class=n>SaveChangesAsync</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=c1>// Publish to event bus only if product price changed</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Achieving atomicity between original DB and the IntegrationEventLog</span>
</span></span><span class=line><span class=cl>	<span class=c1>// with a local transaction</span>
</span></span><span class=line><span class=cl>	<span class=k>using</span> <span class=p>(</span><span class=kt>var</span> <span class=n>transaction</span> <span class=p>=</span> <span class=n>_catalogContext</span><span class=p>.</span><span class=n>Database</span><span class=p>.</span><span class=n>BeginTransaction</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>_catalogContext</span><span class=p>.</span><span class=n>CatalogItems</span><span class=p>.</span><span class=n>Update</span><span class=p>(</span><span class=n>catalogItem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>await</span> <span class=n>_catalogContext</span><span class=p>.</span><span class=n>SaveChangesAsync</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>await</span> <span class=n>_integrationEventLogService</span><span class=p>.</span><span class=n>SaveEventAsync</span><span class=p>(</span><span class=n>priceChangedEvent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>transaction</span><span class=p>.</span><span class=n>Commit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Publish the integration event through the event bus</span>
</span></span><span class=line><span class=cl>	<span class=n>_eventBus</span><span class=p>.</span><span class=n>Publish</span><span class=p>(</span><span class=n>priceChangedEvent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>_integrationEventLogService</span><span class=p>.</span><span class=n>MarkEventAsPublishedAsync</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=n>priceChangedEvent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>Ok</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Ou seja:</p><ol><li>Se o Banco cair?<ol><li>Se essa operação for uma reação à um evento, a mensagem não será processada, para que possa ser processada em um momento futuro. Mantemos consistência e faremos o que for necessário, assim que possível.</li><li>Se for fruto de uma chamada síncrona, podemos retornar um erro. De qualquer forma, o sistema não fica inconsistente.</li></ol></li><li>Se não conseguirmos publicar no event bus?<ol><li>Será publicado depois, teremos um log de que o evento está pronto para a publicação, nosso domínio interno estará atualizado, mas os outros não. Como trabalhamos com consistência eventual, é um cenário completamente ok!</li><li>Se o banco cair na hora de salvarmos como enviado, enviaremos o evento novamente, por isso a importância da idempotência</li></ol></li></ol><p>Esse tipo de cenário enfatiza como a alta resiliência de uma aplicação pode ser alcançada com mais facilidade usando um padrão de comunicação assíncrono por meio de eventos e mensagens</p><h1 id=conclusão>Conclusão<a hidden class=anchor aria-hidden=true href=#conclusão>#</a></h1><p>A função deste texto é dar introdução à arquiteturas síncronas, assíncronas e orientadas à eventos, mostrando vantagens, desafios e técnicas comuns. Os posts posteriores darão mais ênfase na arquitetura à nivel dos módulos - Como desenhar os bounded contexts, quanto de informação colocar nos eventos de integração, etc.</p><p>Espero que tenham gostado!</p><h1 id=referências>Referências<a hidden class=anchor aria-hidden=true href=#referências>#</a></h1><ol><li>Construindo Microserviços - Sam newman</li><li>OOP e SOLID para ninjas</li><li>Desbravando SOLID</li><li><a href="https://www.youtube.com/watch?v=s8cvn2TUXoM&t=136s">EVENT STORMING - DOMAIN DRIVEN DESIGN, EVENT SOURCING E CQRS! - YouTube</a></li><li><a href="https://www.youtube.com/watch?v=bxGkavGaEiM&t=626s">Message Driven Architecture to DECOUPLE a Monolith - YouTube</a></li><li><a href="https://www.youtube.com/watch?v=VGShtGU3hOc&t=9s">Long live the Monolith! Monolithic Architecture != Big Ball of Mud - YouTube</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/architecture/microservices/># .NET Microservices: Architecture for Containerized .NET Applications</a></li><li><a href=https://newsletter.simpleaws.dev/p/distributed-transactions-event-driven-architectures>https://newsletter.simpleaws.dev/p/distributed-transactions-event-driven-architectures</a></li><li><a href=https://fidelissauro.dev/mensageria-eventos-streaming/>Mensageria, Eventos, Streaming e Arquitetura Assincrona</a></li><li><a href=https://fidelissauro.dev/padroes-de-comunicacao-sincronos/>Padrões de Comunicação Síncronos</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://kaue.cat/tags/eda/>EDA</a></li><li><a href=https://kaue.cat/tags/architecture/>ARCHITECTURE</a></li></ul><nav class=paginav><a class=next href=https://kaue.cat/posts/software-architecture-basics/><span class=title>Próxima Página »</span><br><span>Arquitetura de Software para devs: MVC, Hexagonal, DDD</span></a></nav><div class=share-buttons><a>Compartilhar:</a><br><a target=_blank rel="noopener noreferrer" aria-label="share Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares on x" href="https://x.com/intent/tweet/?text=Arquiteturas%20Orientadas%20%c3%a0%20Eventos%2c%20Microservi%c3%a7os%20e%20Monolitos%20Modulares&url=https%3a%2f%2fkaue.cat%2fposts%2feda%2f&hashtags=EDA%2cARCHITECTURE"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkaue.cat%2fposts%2feda%2f&title=Arquiteturas%20Orientadas%20%c3%a0%20Eventos%2c%20Microservi%c3%a7os%20e%20Monolitos%20Modulares&summary=Arquiteturas%20Orientadas%20%c3%a0%20Eventos%2c%20Microservi%c3%a7os%20e%20Monolitos%20Modulares&source=https%3a%2f%2fkaue.cat%2fposts%2feda%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Arquiteturas Orientadas à Eventos, Microserviços e Monolitos Modulares on whatsapp" href="https://api.whatsapp.com/send?text=Arquiteturas%20Orientadas%20%c3%a0%20Eventos%2c%20Microservi%c3%a7os%20e%20Monolitos%20Modulares%20-%20https%3a%2f%2fkaue.cat%2fposts%2feda%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//www-kaue-cat.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://kaue.cat>Kaue Gatto</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copiar";function s(){t.innerHTML="copiado!",setTimeout(()=>{t.innerHTML="copiar"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>