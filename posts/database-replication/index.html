<!doctype html><html lang=pt dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[WIP] Replicação de Banco de Dados | Kaue Gatto</title><meta name=keywords content="ARCHITECTURE"><meta name=description content="Vamos explorar como fazer testes em java!"><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=apple-touch-icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><link rel=mask-icon href=https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=pt href=https://kaue.cat/posts/database-replication/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6MZTJBEG75"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6MZTJBEG75",{anonymize_ip:!1})}</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-6MZTJBEG75","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6MZTJBEG75"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6MZTJBEG75",{anonymize_ip:!1})}</script><meta property="og:title" content="[WIP] Replicação de Banco de Dados"><meta property="og:description" content="Vamos explorar como fazer testes em java!"><meta property="og:type" content="article"><meta property="og:url" content="https://kaue.cat/posts/database-replication/"><meta property="og:image" content="https://kaue.cat/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-03T16:30:03+00:00"><meta property="article:modified_time" content="2024-01-03T16:30:03+00:00"><meta property="og:site_name" content="Kaue Gatto - Blog de Desenvolvimento"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kaue.cat/%3Cimage%20path/url%3E"><meta name=twitter:title content="[WIP] Replicação de Banco de Dados"><meta name=twitter:description content="Vamos explorar como fazer testes em java!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kaue.cat/posts/"},{"@type":"ListItem","position":3,"name":"[WIP] Replicação de Banco de Dados","item":"https://kaue.cat/posts/database-replication/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[WIP] Replicação de Banco de Dados","name":"[WIP] Replicação de Banco de Dados","description":"Vamos explorar como fazer testes em java!","keywords":["ARCHITECTURE"],"articleBody":"[WIP] Replicação de Banco de Dados A Replicação refere-se ao processo de manter uma cópia dos mesmos dados em várias máquinas conectadas através de uma rede. Existem várias razões para replicar dados:\nPara manter os dados geograficamente próximos aos usuários, reduzindo a latência. Para manter a funcionalidade do sistema mesmo que partes falhem (Tolerância à falhas), aumentando a disponibilidade. Para escalar o número de máquinas read-only, aumentando assim o throughput de leitura. Para esse artigo, vamos supor que o conjunto de dados seja pequeno o suficiente para que cada máquina possa conter uma cópia completa. Em outro momento podemos discutir o particionamento de banco de dados (sharding).\nSe os dados à serem replicados forem estáticos, a replicação é direta: Copie os dados para cada nó uma vez. No entanto, os dados frequentemente mudam ao longo do tempo.\nVamos explorar três algoritmos populares para replicar mudanças entre nós: replicação com um único líder, múltiplos líderes e sem líder.\nLíderes e Seguidores Como garantimos que todos os dados sejam replicados com precisão? Uma solução comum é a chamada replicação baseada em líder:\nPapel do Líder: Uma réplica é designada como líder (também conhecida como mestre ou primário). Para escritas no banco de dados, os clientes devem enviar solicitações ao líder, que grava os novos dados no seu armazenamento local.\nPapel do Seguidor: As outras réplicas, conhecidas como seguidores (réplicas de leitura), recebem mudanças de dados do líder como parte de um log de replicação ou fluxo de mudança. Cada seguidor atualiza seu banco de dados local aplicando todas as escritas na mesma ordem que o líder.\n1. Replicação Baseada em único Líder A replicação baseada em único líder é um recurso integrado nativamente na maioria dos grandes bancos de dados relacionais e alguns bancos de dados não relacionais. Ela também é usada em corretores de mensagens distribuídas como Kafka e RabbitMQ.\nReplicação Síncrona Versus Assíncrona Um aspecto importante dos sistemas replicados é se a replicação é síncrona ou assíncrona. Considere um usuário atualizando a imagem do seu perfil em um site. A sequência de eventos é:\nO cliente envia a solicitação de atualização ao líder. O líder recebe a solicitação e encaminha a mudança de dados aos seguidores. O líder notifica o cliente sobre a atualização bem-sucedida. O momento que o sucesso será dado ao usuário depende da sincronização dos seguidores.\nSe a replicação for síncrona, os seguidores devem primeiros ficar consistentes para que o usuário receba seu ok. Se for assíncrona, os dados eventualmente serão consistentes - Isso significa que alguns bancos de dados ainda manterão os dados antigos por um tempo, mas eles serão atualizados para alcançar o estado do líder eventualmente A letra “E” do acrônimo BASE, usado frequentemente para explicar um tipo específico de banco de dados que preza por disponibilidade diz respeito à Eventual Consistency - A Consistência eventual Há circunstâncias em que os seguidores podem ficar vários minutos ou mais atrás do líder; por exemplo, se um seguidor estiver se recuperando de uma falha, se o sistema estiver operando próximo à capacidade máxima, ou se houver problemas de rede entre os nós. Totalmente Síncrono ou Totalmente Assíncrono Frequentemente, a replicação baseada em líder é completamente assíncrona - Isso significa que uma escrita não é garantida como durável (se o líder falhar e não for recuperável, suas mudanças não serão propagadas mesmo que tenham sido confirmadas ao cliente). No entanto, uma configuração totalmente assíncrona tem a vantagem de que o líder pode continuar processando escritas, mesmo que todos os seus seguidores estejam atrasados.\nIsso é bom para certos cenários onde queremos alta disponibilidade e velocidade, e perder alguns registros não é o fim do mundo Em sistemas com muitas leituras, o atraso não é necessariamente um problema e pode ser considerado usar diversas cópias assíncronas, receber um tweet com 2 minutos de atraso não é grande coisa, Enfraquecer a durabilidade dos dados pode parecer uma má troca, mas a replicação assíncrona é amplamente utilizada, especialmente se houver muitos seguidores ou se eles estiverem geograficamente distribuídos. A replicação síncrona garante que os dados sejam replicados para um número especificado de seguidores antes de confirmar o sucesso ao cliente. Isso significa que a configuração não é binária, e você não precisa seguir a linha de seguidores totalmente síncronos.\nNa prática, ter todos os seguidores síncronos é impraticável, pois qualquer falha de nó paralisaria o sistema. Tipicamente, um seguidor é síncrono, com os outros sendo assíncronos. Isso garante uma cópia atualizada dos dados em pelo menos dois nós: o líder e um seguidor síncrono. Se o seguidor síncrono se tornar indisponível ou lento, um dos seguidores assíncronos é feito síncrono.\nFalha do Líder: Failover Lidar com a falha do líder é um desafio: um dos seguidores precisa ser promovido a novo líder, os clientes precisam ser reconfigurados para enviar suas escritas ao novo líder, e os outros seguidores precisam começar a consumir mudanças de dados do novo líder. Esse processo é chamado de failover.\nO failover pode acontecer manualmente (um administrador é notificado de que o líder falhou e toma as medidas necessárias para criar um novo líder) ou automaticamente.\nO processo de failover se dá dessa forma:\nDeterminar que o Líder Falhou. Escolher um Novo Líder. Isso pode envolver um processo de eleição entre as réplicas restantes, ou um novo líder pode ser nomeado por um nó controlador previamente eleito. O melhor candidato é frequentemente a réplica com as mudanças de dados mais atualizadas do antigo líder, para minimizar a perda de dados. Reconfigurar o Sistema para o Novo Líder. Os clientes agora precisam enviar suas solicitações de escrita ao novo líder. Se o antigo líder voltar, ele deve se tornar um seguidor e reconhecer o novo líder, já que pode ainda acreditar que é o líder. Problemas Se estiver usando replicação assíncrona, o novo líder pode não ter todas as escritas do antigo líder antes da sua falha. Se o antigo líder se reintegrar, há uma questão sobre o que acontece com suas escritas não replicadas, especialmente se o novo líder recebeu escritas conflitantes. Comumente, as escritas não replicadas do antigo líder são descartadas, violando potencialmente as expectativas de durabilidade, o que já discutimos.\nDescartar escritas é perigoso se estiver coordenando com sistemas de armazenamento externos fora do banco de dados. Por exemplo, um incidente no GitHub envolveu a promoção de um seguidor desatualizado do MySQL a líder. O banco de dados usava um contador autoincrementado para chaves primárias, mas o contador do novo líder estava atrasado, levando à reutilização de chaves primárias previamente atribuídas pelo antigo líder. Essas chaves também eram usadas em um armazenamento Redis, resultando em inconsistências entre o MySQL e o Redis e causando a divulgação de dados privados para usuários incorretos.\nProblemas com Atraso na Replicação Ser capaz de tolerar falhas de nós é apenas uma razão para querer replicação. Outras razões incluem escalabilidade (processar mais solicitações do que uma única máquina pode lidar) e latência (colocar réplicas geograficamente mais próximas dos usuários).\nA replicação baseada em líder exige que todas as escritas passem por um único nó, mas consultas somente de leitura podem ser direcionadas a qualquer réplica. Em cargas de trabalho que são principalmente de leitura com é comum criar muitos seguidores e distribuir as solicitações de leitura entre eles. Essa abordagem reduz a carga sobre o líder e permite atender solicitações de leitura por réplicas próximas.\nInfelizmente, ler de um seguidor assíncrono pode resultar em informações desatualizadas se o seguidor estiver atrasado. Isso leva a inconsistências aparentes no banco de dados: a mesma consulta executada no líder e em um seguidor simultaneamente pode produzir resultados diferentes porque nem todas as escritas foram refletidas no seguidor.\nEssa inconsistência temporária é conhecida como consistência eventual. O termo “eventualmente” é intencionalmente vago. Geralmente, não há limite para o quanto uma réplica pode ficar para trás.\nQuando o atraso se torna significativo, pode se tornar um problema real, é vamos ver alguns problemas e soluções a seguir\nLer Suas Próprias Escritas Muitas aplicações permitem que os usuários enviem dados (como um registro em um banco de dados de clientes ou um comentário em um fórum de discussão) e depois vejam o que enviaram. Novos dados devem ser enviados ao líder, mas a visualização dos dados pode ser feita a partir de um seguidor. Isso é apropriado se os dados são frequentemente visualizados, mas apenas ocasionalmente escritos.\nCom a replicação assíncrona, surge um problema: Se o usuário visualizar os dados logo após uma escrita, os novos dados podem ainda não estar na réplica. Para o usuário, parece que sua alteração não foi feita com sucesso.\nNessa situação, é válida a consistência de de ler-suas-próprias-escritas. Isso garante que, se o usuário recarregar a página, ele sempre verá quaisquer atualizações que tenha enviado. Isso não promete visibilidade imediata das atualizações de outros usuários, mas não dá a falsa impressão que suas alterações foram um fracasso.\nAo ler algo que o usuário possa ter modificado, obtenha-o do líder (Ou de um seguidor síncrono!). Caso contrário, use um seguidor. Isso requer um método para determinar modificações potenciais sem realmente consultar. Por exemplo, em uma rede social, o perfil de um usuário normalmente é editável apenas por ele mesmo. Assim, uma regra simples é: sempre leia o perfil do próprio usuário do líder e os perfis de outros usuários de um seguidor.\nLeituras Monotônicas Uma segunda anomalia com seguidores assíncronos é a possibilidade de os usuários perceberem o tempo retrocedendo. Isso ocorre se um usuário ler de diferentes réplicas em momentos diferentes. Por exemplo, um usuário pode consultar um seguidor com pouco atraso e depois um seguidor com maior atraso, resultando nele vendo dados mais recentes primeiro e depois dados mais antigos.\nPara alcançar leituras monotônicas, garanta que cada usuário sempre leia da mesma réplica, embora diferentes usuários possam ler de réplicas diferentes.\nLeituras de Prefixo Consistentes O terceiro exemplo de anomalias devido ao atraso na replicação envolve violações de causalidade. Se algumas partições replicarem mais lentamente do que outras, é possível observar o resultado (resposta) antes da causa (pergunta).\nPara mais detalhes sobre os últimos tópicos, consulte “Designing Data-Intensive Applications” (DDIA), página 164 e 165.\n2. Replicação Multi-Líder A principal limitação da replicação baseada em líder é sua restrição de único líder: todas as escritas devem passar por um líder. Se você não puder se conectar ao líder, talvez devido a uma interrupção de rede, não poderá escrever no banco de dados.\nUma extensão natural é a replicação multi-líder (também conhecida como replicação ativa/ativa), onde mais de um nó pode aceitar escritas. A replicação ocorre como de costume: cada nó que processa uma escrita encaminha a mudança de dados para todos os outros nós.\nCasos de Uso para Replicação Multi-Líder Usar uma configuração multi-líder dentro de um único datacenter raramente é benéfico devido à sua complexidade. No entanto, pode ser vantajoso em certos cenários:\nOperação Multi-datacenter Considere um banco de dados com réplicas em vários datacenters, seja para tolerância a falhas ou proximidade com os usuários. Em uma configuração padrão baseada em líder, um datacenter abriga o líder, e todas as escritas devem passar por ele.\nEm uma configuração multi-líder, cada datacenter pode ter seu próprio líder, enquanto o líder de cada datacenter replica mudanças para os líderes nos outros datacenters.\nVamos comparar como as configurações de líder único e multi-líder se saem em uma implantação multi-datacenter:\nClientes com Operação Offline Aplicações que precisam funcionar enquanto desconectadas da internet, como aplicativos de calendário em telefones celulares e laptops. Esses aplicativos requerem a capacidade de visualizar e inserir dados a qualquer momento, independentemente da conectividade com a internet, com mudanças sincronizadas quando o dispositivo estiver novamente online. Implementação: Cada dispositivo tem um banco de dados local atuando como um líder, com um processo de replicação multi-líder assíncrona entre todas as réplicas do dispositivo. O atraso na replicação pode variar de horas a dias.\nSemelhante à replicação multi-líder entre datacenters, mas com cada dispositivo como um “datacenter”.\nDesvantagens da Replicação Multi-Líder: Modificações concorrentes podem levar a conflitos de escrita que precisam ser resolvidos, isso não necessariamente é simples e é o principal lado negativo da replicação com múltiplos líderes. Esse padrão é até mesmo considerado negativo na maior parte dos casos.\nChaves autoincrementadas, gatilhos e restrições de integridade podem ser problemáticos, tornando a replicação multi-líder uma escolha arriscada para casos de uso comuns.\nFor example, autoincrementing keys, triggers, and integrity constraints can be problematic. For this reason, multi-leader replication is often considered dangerous territory that should be avoided if possible.\nSe o seu caso de uso pede (ou realmente vê benefícios na arquitetura com múltiplos líderes, recomendo a leitura do livro DDIA no capítulo correspondente para entender com detalhes os desafios e recomendações de como lidar com os conflitos.\nComparativos Desempenho Configuração de Líder Único: Cada escrita deve passar pela internet até o datacenter com o líder, potencialmente adicionando latência significativa e contrariando o propósito de múltiplos datacenters. Configuração Multi-Líder: As escritas são processadas no datacenter local e replicadas de forma assíncrona para outros datacenters, ocultando o atraso da rede inter-datacenter e potencialmente melhorando o desempenho percebido.\nTolerância a Falhas de Datacenter Líder Único: Se o datacenter com o líder falhar, o failover pode promover um seguidor em outro datacenter a líder. Multi-Líder: Cada datacenter continua operando independentemente, com a replicação se atualizando quando o datacenter com falha voltar a funcionar.\nReplicação Sem Líder As abordagens de replicação discutidas até agora — líder único e multi-líder — baseiam-se no envio de solicitações de escrita para um nó (o líder), com o sistema de banco de dados copiando essa escrita para outras réplicas.\nO líder determina a ordem das escritas, e os seguidores as aplicam nessa ordem. A replicação sem líder, uma abordagem diferente, abandona o conceito de líder e permite que qualquer réplica aceite escritas diretamente dos clientes. Este estilo, repopularizado pelo sistema Dynamo da Amazon, também é encontrado outras soluções como o Cassandra.\nEm alguns sistemas sem líder, os clientes enviam escritas diretamente para várias réplicas, enquanto em outros, um nó coordenador faz isso em nome do cliente.\nEscrevendo no Banco de Dados Quando um Nó Está Inativo Considere um banco de dados com três réplicas, sendo uma delas atualmente indisponível. Em uma configuração baseada em líder, a continuação do processamento de escritas pode exigir um failover. Em contraste, uma configuração sem líder não tem failover. O cliente envia a escrita para todas as três réplicas, e as duas disponíveis a aceitam. Se o reconhecimento de duas em três réplicas for suficiente, a escrita é considerada bem-sucedida, apesar de uma réplica ter perdido.\nQuando o nó indisponível volta a funcionar, ele não possui as escritas feitas durante seu tempo de inatividade. Leituras desse nó podem retornar valores desatualizados. Para resolver isso, as solicitações de leitura são enviadas a vários nós simultaneamente, com números de versão usados para determinar o valor mais recente.\nReparo de Leitura e Anti-Entropia Para garantir a consistência eventual, dois mecanismos são usados:\nReparo de Leitura: Quando um cliente lê de vários nós e detecta respostas desatualizadas, ele escreve o valor mais novo de volta para o nó com informações desatualizadas. Isso é eficaz para valores frequentemente lidos. Processo Anti-Entropia: Alguns repositórios de dados executam um processo em segundo plano para encontrar diferenças de dados entre réplicas e copiar os dados ausentes de acordo. Este processo não segue uma ordem específica para copiar escritas e pode ter um atraso significativo antes que os dados sejam replicados. Operação Multi-Datacenter A replicação entre datacenters, conforme discutido no contexto da replicação multi-líder, também é aplicável na replicação sem líder. Este modelo é projetado para lidar com escritas concorrentes conflitantes, interrupções de rede e picos de latência.\nImplementação em Cassandra Em Cassandra, o suporte multi-datacenter é integrado ao modelo sem líder:\nO número total de réplica, n, inclui nós em todos os datacenters.\nA configuração permite especificar o número de réplicas em cada datacenter. Cada escrita do cliente é enviada para todas as réplicas, independentemente da localização do datacenter. Os clientes normalmente aguardam o reconhecimento de um quórum de nós dentro do seu datacenter local, minimizando o impacto dos atrasos de link entre datacenters. As escritas para outros datacenters costumam ser configuradas para serem assíncronas, com alguma flexibilidade de configuração. Detectando Escritas Concorrentes Bancos de dados estilo Dynamo, que permitem escritas concorrentes na mesma chave por vários clientes, enfrentam conflitos semelhantes à replicação multi-líder (“Tratamento de Conflitos de Escrita” na página 171). Conflitos podem surgir durante o reparo de leitura ou a transferência sugerida.\nAtrasos variáveis na rede e falhas parciais podem levar a diferentes nós recebendo eventos em ordens diferentes. Por exemplo:\nO Nó 1 recebe uma escrita do Cliente A, mas perde a escrita do Cliente B devido a uma falha. O Nó 2 primeiro recebe a escrita do Cliente A, seguida pela do Cliente B. O Nó 3 recebe primeiro a escrita do Cliente B e depois a do Cliente A. Se cada nó simplesmente sobrescrever valores ao receber solicitações de escrita, inconsistências permanentes surgem, como ilustrado no cenário final de solicitação de obtenção: O Nó 2 vê o valor final de X como B, enquanto os outros o veem como A.\nPara alcançar a consistência eventual e convergir para o mesmo valor, é necessário um mecanismo de resolução de conflitos adequado. Infelizmente, muitas implementações de banco de dados exigem um profundo entendimento de seus mecanismos internos de tratamento de conflitos por parte do desenvolvedor da aplicação para evitar perda de dados.\nPara informações detalhadas sobre a resolução de conflitos de escrita, consulte o livro de referência na página 171.\nBibliografia Designing Data-Intensive Applications (DDIA) - Martin Kleppmann. https://dataintensive.net/\nhttps://fidelissauro.dev/teorema-cap/\n","wordCount":"2932","inLanguage":"pt","image":"https://kaue.cat/%3Cimage%20path/url%3E","datePublished":"2024-01-03T16:30:03Z","dateModified":"2024-01-03T16:30:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kaue.cat/posts/database-replication/"},"publisher":{"@type":"Organization","name":"Kaue Gatto","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/kauegatto/hugo-PaperMod/6aab706f2e2053433e33f8fd45dbec615f4d479f/images/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kaue.cat accesskey=h title="Home (Alt + H)"><img src=https://kaue.cat/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://kaue.cat/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://kaue.cat/archives title=Arquivo><span>Arquivo</span></a></li><li><a href=https://kaue.cat/search/ title=Buscar><span>Buscar</span></a></li><li><a href=https://kaue.cat/series/ title=Séries><span>Séries</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kaue.cat>Início</a>&nbsp;»&nbsp;<a href=https://kaue.cat/posts/>Posts</a></div><h1 class=post-title>[WIP] Replicação de Banco de Dados</h1><div class=post-description>Vamos explorar como fazer testes em java!</div><div class=post-meta><span title='2024-01-03 16:30:03 +0000 UTC'>janeiro 3, 2024</span>&nbsp;·&nbsp;14 minutos&nbsp;·&nbsp;2932 palavras&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/kauegatto/kauedotcat/content/posts/database-replication.md rel="noopener noreferrer" target=_blank>Sugerir Alterações</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Conteúdo</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#replicação-síncrona-versus-assíncrona>Replicação Síncrona Versus Assíncrona</a></li><li><a href=#totalmente-síncrono-ou-totalmente-assíncrono>Totalmente Síncrono ou Totalmente Assíncrono</a></li><li><a href=#falha-do-líder-failover>Falha do Líder: Failover</a><ul><li><a href=#problemas>Problemas</a></li></ul></li><li><a href=#problemas-com-atraso-na-replicação>Problemas com Atraso na Replicação</a><ul><li><a href=#ler-suas-próprias-escritas>Ler Suas Próprias Escritas</a></li></ul></li><li><a href=#leituras-monotônicas>Leituras Monotônicas</a><ul><li><a href=#leituras-de-prefixo-consistentes>Leituras de Prefixo Consistentes</a></li></ul></li></ul><ul><li><a href=#casos-de-uso-para-replicação-multi-líder>Casos de Uso para Replicação Multi-Líder</a><ul><li><a href=#operação-multi-datacenter>Operação Multi-datacenter</a></li><li><a href=#clientes-com-operação-offline>Clientes com Operação Offline</a></li></ul></li><li><a href=#desvantagens-da-replicação-multi-líder>Desvantagens da Replicação Multi-Líder:</a></li><li><a href=#comparativos>Comparativos</a><ul><li><a href=#desempenho>Desempenho</a></li><li><a href=#tolerância-a-falhas-de-datacenter>Tolerância a Falhas de Datacenter</a></li></ul></li></ul><ul><li><a href=#escrevendo-no-banco-de-dados-quando-um-nó-está-inativo>Escrevendo no Banco de Dados Quando um Nó Está Inativo</a></li><li><a href=#reparo-de-leitura-e-anti-entropia>Reparo de Leitura e Anti-Entropia</a></li><li><a href=#operação-multi-datacenter-1>Operação Multi-Datacenter</a><ul><li><a href=#implementação-em-cassandra>Implementação em Cassandra</a></li></ul></li><li><a href=#detectando-escritas-concorrentes>Detectando Escritas Concorrentes</a></li></ul></nav></div></details></div><div class=post-content><h1 id=wip-replicação-de-banco-de-dados>[WIP] Replicação de Banco de Dados<a hidden class=anchor aria-hidden=true href=#wip-replicação-de-banco-de-dados>#</a></h1><p>A Replicação refere-se ao processo de manter uma cópia dos mesmos dados em várias máquinas conectadas através de uma rede. Existem várias razões para replicar dados:</p><ul><li>Para manter os dados geograficamente próximos aos usuários, reduzindo a latência.</li><li>Para manter a funcionalidade do sistema mesmo que partes falhem (Tolerância à falhas), aumentando a disponibilidade.</li><li>Para escalar o número de máquinas read-only, aumentando assim o throughput de leitura.</li></ul><p>Para esse artigo, vamos supor que o conjunto de dados seja pequeno o suficiente para que cada máquina possa conter uma cópia completa. Em outro momento podemos discutir o particionamento de banco de dados (sharding).</p><p>Se os dados à serem replicados forem estáticos, a replicação é direta: Copie os dados para cada nó uma vez. No entanto, os dados frequentemente mudam ao longo do tempo.</p><p>Vamos explorar três algoritmos populares para replicar mudanças entre nós: replicação com um único líder, múltiplos líderes e sem líder.</p><h1 id=líderes-e-seguidores>Líderes e Seguidores<a hidden class=anchor aria-hidden=true href=#líderes-e-seguidores>#</a></h1><p>Como garantimos que todos os dados sejam replicados com precisão? Uma solução comum é a chamada replicação baseada em líder:</p><p><strong>Papel do Líder:</strong> Uma réplica é designada como líder (também conhecida como mestre ou primário). <strong>Para escritas</strong> no banco de dados, <strong>os clientes devem enviar solicitações ao líder</strong>, que grava os novos dados no seu armazenamento local.</p><p><strong>Papel do Seguidor:</strong> As outras réplicas, conhecidas como seguidores (réplicas de leitura), recebem mudanças de dados do líder como parte de um log de replicação ou fluxo de mudança. Cada seguidor atualiza seu banco de dados local aplicando todas as escritas na mesma ordem que o líder.</p><h1 id=1-replicação-baseada-em-único-líder>1. Replicação Baseada em único Líder<a hidden class=anchor aria-hidden=true href=#1-replicação-baseada-em-único-líder>#</a></h1><p>A replicação baseada em único líder é um recurso integrado nativamente na maioria dos grandes bancos de dados relacionais e alguns bancos de dados não relacionais. Ela também é usada em corretores de mensagens distribuídas como Kafka e RabbitMQ.</p><h2 id=replicação-síncrona-versus-assíncrona>Replicação Síncrona Versus Assíncrona<a hidden class=anchor aria-hidden=true href=#replicação-síncrona-versus-assíncrona>#</a></h2><p>Um aspecto importante dos sistemas replicados é se a replicação é síncrona ou assíncrona. Considere um usuário atualizando a imagem do seu perfil em um site. A sequência de eventos é:</p><ul><li>O cliente envia a solicitação de atualização ao líder.</li><li>O líder recebe a solicitação e encaminha a mudança de dados aos seguidores.</li><li>O líder notifica o cliente sobre a atualização bem-sucedida.</li></ul><p>O momento que o sucesso será dado ao usuário depende da sincronização dos seguidores.</p><ul><li>Se a replicação for síncrona, os seguidores devem primeiros ficar consistentes para que o usuário receba seu ok.</li><li>Se for assíncrona, os dados <strong>eventualmente serão consistentes</strong> - Isso significa que alguns bancos de dados ainda manterão os dados antigos por um tempo, mas eles serão atualizados para alcançar o estado do líder eventualmente<ul><li>A letra “<strong>E”</strong> do acrônimo BASE, usado frequentemente para explicar um tipo específico de banco de dados que preza por disponibilidade diz respeito à Eventual Consistency - A Consistência eventual</li></ul></li><li>Há circunstâncias em que os seguidores podem ficar vários minutos ou mais atrás do líder; por exemplo, se um seguidor estiver se recuperando de uma falha, se o sistema estiver operando próximo à capacidade máxima, ou se houver problemas de rede entre os nós.</li></ul><h2 id=totalmente-síncrono-ou-totalmente-assíncrono>Totalmente Síncrono ou Totalmente Assíncrono<a hidden class=anchor aria-hidden=true href=#totalmente-síncrono-ou-totalmente-assíncrono>#</a></h2><p>Frequentemente, a replicação baseada em líder é completamente assíncrona - Isso significa que uma escrita <strong>não é garantida como durável</strong> (se o líder falhar e não for recuperável, <strong>suas mudanças não serão propagadas mesmo que tenham sido confirmadas ao cliente</strong>). No entanto, <strong>uma configuração totalmente assíncrona tem a vantagem de que o líder pode continuar processando escritas, mesmo que todos os seus seguidores estejam atrasados.</strong></p><ul><li>Isso é bom para certos cenários onde queremos alta disponibilidade e velocidade, e perder alguns registros não é o fim do mundo</li><li>Em sistemas com muitas leituras, o atraso não é necessariamente um problema e pode ser considerado usar diversas cópias assíncronas, receber um tweet com 2 minutos de atraso não é grande coisa,</li><li>Enfraquecer a durabilidade dos dados pode parecer uma má troca, mas a replicação assíncrona é amplamente utilizada, especialmente se houver muitos seguidores ou se eles estiverem geograficamente distribuídos.</li></ul><p>A replicação síncrona garante que os dados sejam replicados <strong>para um número especificado de seguidores antes de confirmar o sucesso ao cliente</strong>. Isso significa que a configuração não é binária, e você não precisa seguir a linha de seguidores totalmente síncronos.</p><p>Na prática, ter todos os seguidores síncronos é impraticável, pois qualquer falha de nó paralisaria o sistema. Tipicamente, um seguidor é síncrono, com os outros sendo assíncronos. <strong>Isso garante uma cópia atualizada dos dados em pelo menos dois nós: o líder e um seguidor síncrono.</strong> Se o seguidor síncrono se tornar indisponível ou lento, um dos seguidores assíncronos é feito síncrono.</p><h2 id=falha-do-líder-failover>Falha do Líder: Failover<a hidden class=anchor aria-hidden=true href=#falha-do-líder-failover>#</a></h2><p>Lidar com a falha do líder é um desafio: um dos seguidores precisa ser promovido a novo líder, os clientes precisam ser reconfigurados para enviar suas escritas ao novo líder, e os outros seguidores precisam começar a consumir mudanças de dados do novo líder. Esse processo é chamado de failover.</p><p>O failover pode acontecer manualmente (um administrador é notificado de que o líder falhou e toma as medidas necessárias para criar um novo líder) ou automaticamente.</p><p>O processo de failover se dá dessa forma:</p><ul><li>Determinar que o Líder Falhou.</li><li>Escolher um Novo Líder. Isso pode envolver um processo de eleição entre as réplicas restantes, ou um novo líder pode ser nomeado por um nó controlador previamente eleito. O melhor candidato é frequentemente a réplica com as mudanças de dados mais atualizadas do antigo líder, para minimizar a perda de dados.</li><li>Reconfigurar o Sistema para o Novo Líder. Os clientes agora precisam enviar suas solicitações de escrita ao novo líder. Se o antigo líder voltar, ele deve se tornar um seguidor e reconhecer o novo líder, já que pode ainda acreditar que é o líder.</li></ul><h3 id=problemas>Problemas<a hidden class=anchor aria-hidden=true href=#problemas>#</a></h3><p>Se estiver usando replicação assíncrona, o novo líder pode não ter todas as escritas do antigo líder antes da sua falha. Se o antigo líder se reintegrar, há uma questão sobre o que acontece com suas escritas não replicadas, especialmente se o novo líder recebeu escritas conflitantes. Comumente, as escritas não replicadas do antigo líder são descartadas, violando potencialmente as expectativas de durabilidade, o que já discutimos.</p><p>Descartar escritas é perigoso se estiver coordenando com sistemas de armazenamento externos fora do banco de dados. Por exemplo, um incidente no GitHub envolveu a promoção de um seguidor desatualizado do MySQL a líder. O banco de dados usava um contador autoincrementado para chaves primárias, mas o contador do novo líder estava atrasado, levando à reutilização de chaves primárias previamente atribuídas pelo antigo líder. Essas chaves também eram usadas em um armazenamento Redis, resultando em inconsistências entre o MySQL e o Redis e causando a divulgação de dados privados para usuários incorretos.</p><h2 id=problemas-com-atraso-na-replicação>Problemas com Atraso na Replicação<a hidden class=anchor aria-hidden=true href=#problemas-com-atraso-na-replicação>#</a></h2><p>Ser capaz de tolerar falhas de nós é apenas uma razão para querer replicação. Outras razões incluem escalabilidade (processar mais solicitações do que uma única máquina pode lidar) e latência (colocar réplicas geograficamente mais próximas dos usuários).</p><p>A replicação baseada em líder exige que todas as escritas passem por um único nó, mas consultas somente de leitura podem ser direcionadas a qualquer réplica. Em cargas de trabalho que são principalmente de leitura com é comum criar muitos seguidores e distribuir as solicitações de leitura entre eles. Essa abordagem reduz a carga sobre o líder e permite atender solicitações de leitura por réplicas próximas.</p><p>Infelizmente, ler de um seguidor assíncrono pode resultar em informações desatualizadas se o seguidor estiver atrasado. Isso leva a inconsistências aparentes no banco de dados: a mesma consulta executada no líder e em um seguidor simultaneamente pode produzir resultados diferentes porque nem todas as escritas foram refletidas no seguidor.</p><p>Essa <strong>inconsistência temporária</strong> é conhecida como consistência eventual. O termo “eventualmente” é intencionalmente vago. Geralmente, não há limite para o quanto uma réplica pode ficar para trás.</p><p>Quando o atraso se torna significativo, pode se tornar um problema real, é vamos ver alguns problemas e soluções a seguir</p><h3 id=ler-suas-próprias-escritas>Ler Suas Próprias Escritas<a hidden class=anchor aria-hidden=true href=#ler-suas-próprias-escritas>#</a></h3><p>Muitas aplicações permitem que os usuários enviem dados (como um registro em um banco de dados de clientes ou um comentário em um fórum de discussão) e depois vejam o que enviaram. Novos dados devem ser enviados ao líder, mas a visualização dos dados pode ser feita a partir de um seguidor. Isso é apropriado se os dados são frequentemente visualizados, mas apenas ocasionalmente escritos.</p><p>Com a replicação assíncrona, surge um problema: Se o usuário visualizar os dados logo após uma escrita, os novos dados podem ainda não estar na réplica. Para o usuário, parece que sua alteração não foi feita com sucesso.</p><p>Nessa situação, é válida a consistência de de ler-suas-próprias-escritas. Isso garante que, se o usuário recarregar a página, ele sempre verá quaisquer atualizações que tenha enviado. Isso não promete visibilidade imediata das atualizações de outros usuários, mas não dá a falsa impressão que suas alterações foram um fracasso.</p><p>Ao ler algo que o usuário possa ter modificado, obtenha-o do líder (Ou de um seguidor síncrono!). Caso contrário, use um seguidor. Isso requer um método para determinar modificações potenciais sem realmente consultar. Por exemplo, em uma rede social, o perfil de um usuário normalmente é editável apenas por ele mesmo. Assim, uma regra simples é: sempre leia o perfil do próprio usuário do líder e os perfis de outros usuários de um seguidor.</p><h2 id=leituras-monotônicas>Leituras Monotônicas<a hidden class=anchor aria-hidden=true href=#leituras-monotônicas>#</a></h2><p>Uma segunda anomalia com seguidores assíncronos é a possibilidade de os usuários perceberem o tempo retrocedendo. Isso ocorre se um usuário ler de diferentes réplicas em momentos diferentes. Por exemplo, um usuário pode consultar um seguidor com pouco atraso e depois um seguidor com maior atraso, resultando nele vendo dados mais recentes primeiro e depois dados mais antigos.</p><p>Para alcançar leituras monotônicas, garanta que cada usuário sempre leia da mesma réplica, embora diferentes usuários possam ler de réplicas diferentes.</p><h3 id=leituras-de-prefixo-consistentes>Leituras de Prefixo Consistentes<a hidden class=anchor aria-hidden=true href=#leituras-de-prefixo-consistentes>#</a></h3><p>O terceiro exemplo de anomalias devido ao atraso na replicação envolve violações de causalidade. Se algumas partições replicarem mais lentamente do que outras, é possível observar o resultado (resposta) antes da causa (pergunta).</p><p>Para mais detalhes sobre os últimos tópicos, consulte &ldquo;Designing Data-Intensive Applications&rdquo; (DDIA), página 164 e 165.</p><h1 id=2-replicação-multi-líder>2. Replicação Multi-Líder<a hidden class=anchor aria-hidden=true href=#2-replicação-multi-líder>#</a></h1><p>A principal limitação da replicação baseada em líder é sua restrição de único líder: todas as escritas devem passar por um líder. Se você não puder se conectar ao líder, talvez devido a uma interrupção de rede, não poderá escrever no banco de dados.</p><p>Uma extensão natural é a replicação multi-líder (também conhecida como replicação ativa/ativa), onde mais de um nó pode aceitar escritas. A replicação ocorre como de costume: cada nó que processa uma escrita encaminha a mudança de dados para todos os outros nós.</p><h2 id=casos-de-uso-para-replicação-multi-líder>Casos de Uso para Replicação Multi-Líder<a hidden class=anchor aria-hidden=true href=#casos-de-uso-para-replicação-multi-líder>#</a></h2><p>Usar uma configuração multi-líder dentro de um único datacenter raramente é benéfico devido à sua complexidade. No entanto, pode ser vantajoso em certos cenários:</p><h3 id=operação-multi-datacenter>Operação Multi-datacenter<a hidden class=anchor aria-hidden=true href=#operação-multi-datacenter>#</a></h3><p>Considere um banco de dados com réplicas em vários datacenters, seja para tolerância a falhas ou proximidade com os usuários. Em uma configuração padrão baseada em líder, um datacenter abriga o líder, e todas as escritas devem passar por ele.</p><p>Em uma configuração multi-líder, cada datacenter pode ter seu próprio líder, enquanto o líder de cada datacenter replica mudanças para os líderes nos outros datacenters.</p><p>Vamos comparar como as configurações de líder único e multi-líder se saem em uma implantação multi-datacenter:</p><h3 id=clientes-com-operação-offline>Clientes com Operação Offline<a hidden class=anchor aria-hidden=true href=#clientes-com-operação-offline>#</a></h3><p>Aplicações que precisam funcionar enquanto desconectadas da internet, como aplicativos de calendário em telefones celulares e laptops. Esses aplicativos requerem a capacidade de visualizar e inserir dados a qualquer momento, independentemente da conectividade com a internet, com mudanças sincronizadas quando o dispositivo estiver novamente online.
<strong>Implementação:</strong> Cada dispositivo tem um banco de dados local atuando como um líder, com um processo de replicação multi-líder assíncrona entre todas as réplicas do dispositivo. O atraso na replicação pode variar de horas a dias.</p><p>Semelhante à replicação multi-líder entre datacenters, mas com cada dispositivo como um &ldquo;datacenter&rdquo;.</p><h2 id=desvantagens-da-replicação-multi-líder>Desvantagens da Replicação Multi-Líder:<a hidden class=anchor aria-hidden=true href=#desvantagens-da-replicação-multi-líder>#</a></h2><p>Modificações concorrentes podem levar a conflitos de escrita que precisam ser resolvidos, isso não necessariamente é simples e é o principal lado negativo da replicação com múltiplos líderes. Esse padrão é até mesmo considerado negativo na maior parte dos casos.</p><p>Chaves autoincrementadas, gatilhos e restrições de integridade podem ser problemáticos, tornando a replicação multi-líder uma escolha arriscada para casos de uso comuns.</p><blockquote><p><em>For example, autoincrementing keys, triggers, and integrity constraints can be problematic. For this reason, multi-leader replication is often considered dangerous territory that should be avoided if possible.</em></p></blockquote><p>Se o seu caso de uso pede (ou realmente vê benefícios na arquitetura com múltiplos líderes, recomendo a leitura do livro DDIA no capítulo correspondente para entender com detalhes os desafios e recomendações de como lidar com os conflitos.</p><h2 id=comparativos>Comparativos<a hidden class=anchor aria-hidden=true href=#comparativos>#</a></h2><h3 id=desempenho>Desempenho<a hidden class=anchor aria-hidden=true href=#desempenho>#</a></h3><p>Configuração de Líder Único: Cada escrita deve passar pela internet até o datacenter com o líder, potencialmente adicionando latência significativa e contrariando o propósito de múltiplos datacenters.
Configuração Multi-Líder: As escritas são processadas no datacenter local e replicadas de forma assíncrona para outros datacenters, ocultando o atraso da rede inter-datacenter e potencialmente melhorando o desempenho percebido.</p><h3 id=tolerância-a-falhas-de-datacenter>Tolerância a Falhas de Datacenter<a hidden class=anchor aria-hidden=true href=#tolerância-a-falhas-de-datacenter>#</a></h3><p>Líder Único: Se o datacenter com o líder falhar, o failover pode promover um seguidor em outro datacenter a líder.
Multi-Líder: Cada datacenter continua operando independentemente, com a replicação se atualizando quando o datacenter com falha voltar a funcionar.</p><h1 id=replicação-sem-líder>Replicação Sem Líder<a hidden class=anchor aria-hidden=true href=#replicação-sem-líder>#</a></h1><p>As abordagens de replicação discutidas até agora — líder único e multi-líder — baseiam-se no envio de solicitações de escrita para um nó (o líder), com o sistema de banco de dados copiando essa escrita para outras réplicas.</p><p>O líder determina a ordem das escritas, e os seguidores as aplicam nessa ordem. A replicação sem líder, uma abordagem diferente, abandona o conceito de líder e permite que qualquer réplica aceite escritas diretamente dos clientes. Este estilo, repopularizado pelo sistema Dynamo da Amazon, também é encontrado outras soluções como o Cassandra.</p><p>Em alguns sistemas sem líder, os clientes enviam escritas diretamente para várias réplicas, enquanto em outros, um nó coordenador faz isso em nome do cliente.</p><h2 id=escrevendo-no-banco-de-dados-quando-um-nó-está-inativo>Escrevendo no Banco de Dados Quando um Nó Está Inativo<a hidden class=anchor aria-hidden=true href=#escrevendo-no-banco-de-dados-quando-um-nó-está-inativo>#</a></h2><p>Considere um banco de dados com três réplicas, sendo uma delas atualmente indisponível. Em uma configuração baseada em líder, a continuação do processamento de escritas pode exigir um failover. Em contraste, uma configuração sem líder não tem failover. O cliente envia a escrita para todas as três réplicas, e as duas disponíveis a aceitam. Se o reconhecimento de duas em três réplicas for suficiente, a escrita é considerada bem-sucedida, apesar de uma réplica ter perdido.</p><p>Quando o nó indisponível volta a funcionar, ele não possui as escritas feitas durante seu tempo de inatividade. Leituras desse nó podem retornar valores desatualizados. Para resolver isso, <strong>as solicitações de leitura são enviadas a vários nós simultaneamente, com números de versão usados para determinar o valor mais recente.</strong></p><h2 id=reparo-de-leitura-e-anti-entropia>Reparo de Leitura e Anti-Entropia<a hidden class=anchor aria-hidden=true href=#reparo-de-leitura-e-anti-entropia>#</a></h2><p>Para garantir a consistência eventual, dois mecanismos são usados:</p><ul><li>Reparo de Leitura: Quando um cliente lê de vários nós e detecta respostas desatualizadas, ele escreve o valor mais novo de volta para o nó com informações desatualizadas. Isso é eficaz para valores frequentemente lidos.</li><li>Processo Anti-Entropia: Alguns repositórios de dados executam um processo em segundo plano para encontrar diferenças de dados entre réplicas e copiar os dados ausentes de acordo. Este processo não segue uma ordem específica para copiar escritas e pode ter um atraso significativo antes que os dados sejam replicados.</li></ul><h2 id=operação-multi-datacenter-1>Operação Multi-Datacenter<a hidden class=anchor aria-hidden=true href=#operação-multi-datacenter-1>#</a></h2><p>A replicação entre datacenters, conforme discutido no contexto da replicação multi-líder, também é aplicável na replicação sem líder. Este modelo é projetado para lidar com escritas concorrentes conflitantes, interrupções de rede e picos de latência.</p><h3 id=implementação-em-cassandra>Implementação em Cassandra<a hidden class=anchor aria-hidden=true href=#implementação-em-cassandra>#</a></h3><p>Em Cassandra, o suporte multi-datacenter é integrado ao modelo sem líder:</p><p>O número total de réplica, <em>n</em>, inclui nós em todos os datacenters.</p><ul><li>A configuração permite especificar o número de réplicas em cada datacenter.</li><li>Cada escrita do cliente é enviada para todas as réplicas, independentemente da localização do datacenter.</li><li>Os clientes normalmente aguardam o reconhecimento de um quórum de nós dentro do seu datacenter local, minimizando o impacto dos atrasos de link entre datacenters.</li><li>As escritas para outros datacenters costumam ser configuradas para serem assíncronas, com alguma flexibilidade de configuração.</li></ul><h2 id=detectando-escritas-concorrentes>Detectando Escritas Concorrentes<a hidden class=anchor aria-hidden=true href=#detectando-escritas-concorrentes>#</a></h2><p>Bancos de dados estilo <em>Dynamo</em>, que permitem escritas concorrentes na mesma chave por vários clientes, enfrentam conflitos semelhantes à replicação multi-líder (&ldquo;Tratamento de Conflitos de Escrita&rdquo; na página 171). Conflitos podem surgir durante o reparo de leitura ou a transferência sugerida.</p><p>Atrasos variáveis na rede e falhas parciais podem levar a diferentes nós recebendo eventos em ordens diferentes. Por exemplo:</p><ol><li>O Nó 1 recebe uma escrita do Cliente A, mas perde a escrita do Cliente B devido a uma falha.</li><li>O Nó 2 primeiro recebe a escrita do Cliente A, seguida pela do Cliente B.</li><li>O Nó 3 recebe primeiro a escrita do Cliente B e depois a do Cliente A.</li></ol><p>Se cada nó simplesmente sobrescrever valores ao receber solicitações de escrita, inconsistências permanentes surgem, como ilustrado no cenário final de solicitação de obtenção: O Nó 2 vê o valor final de X como B, enquanto os outros o veem como A.</p><p>Para alcançar a consistência eventual e convergir para o mesmo valor, é necessário um mecanismo de resolução de conflitos adequado. Infelizmente, muitas implementações de banco de dados exigem um profundo entendimento de seus mecanismos internos de tratamento de conflitos por parte do desenvolvedor da aplicação para evitar perda de dados.</p><p>Para informações detalhadas sobre a resolução de conflitos de escrita, consulte o livro de referência na página 171.</p><h1 id=bibliografia>Bibliografia<a hidden class=anchor aria-hidden=true href=#bibliografia>#</a></h1><p>Designing Data-Intensive Applications (DDIA) - Martin Kleppmann. <a href=https://dataintensive.net/>https://dataintensive.net/</a></p><p><a href=https://fidelissauro.dev/teorema-cap/>https://fidelissauro.dev/teorema-cap/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kaue.cat/tags/architecture/>ARCHITECTURE</a></li></ul><nav class=paginav><a class=prev href=https://kaue.cat/posts/virtual-threads/><span class=title>« Página Anterior</span><br><span>[WIP] Virtual Threads em Java!</span></a>
<a class=next href=https://kaue.cat/posts/testes_java/><span class=title>Próxima Página »</span><br><span>[WIP] Testes em Java - JUnit, Mockito, Integração e TestContainers</span></a></nav><div class=share-buttons><a>Compartilhar:</a><br><a target=_blank rel="noopener noreferrer" aria-label="share [WIP] Replicação de Banco de Dados on x" href="https://x.com/intent/tweet/?text=%5bWIP%5d%20Replica%c3%a7%c3%a3o%20de%20Banco%20de%20Dados&url=https%3a%2f%2fkaue.cat%2fposts%2fdatabase-replication%2f&hashtags=ARCHITECTURE"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [WIP] Replicação de Banco de Dados on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkaue.cat%2fposts%2fdatabase-replication%2f&title=%5bWIP%5d%20Replica%c3%a7%c3%a3o%20de%20Banco%20de%20Dados&summary=%5bWIP%5d%20Replica%c3%a7%c3%a3o%20de%20Banco%20de%20Dados&source=https%3a%2f%2fkaue.cat%2fposts%2fdatabase-replication%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [WIP] Replicação de Banco de Dados on whatsapp" href="https://api.whatsapp.com/send?text=%5bWIP%5d%20Replica%c3%a7%c3%a3o%20de%20Banco%20de%20Dados%20-%20https%3a%2f%2fkaue.cat%2fposts%2fdatabase-replication%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//www-kaue-cat.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://kaue.cat>Kaue Gatto</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>